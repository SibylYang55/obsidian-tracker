/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  HabitTrackerView: () => HabitTrackerView,
  default: () => TrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.dataset.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || value === void 0;
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNonPrimitive(n) {
  return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
}
function isNumber(n) {
  return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, vScale, _parsed } = meta;
    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      );
      if (spanGaps) {
        const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        start -= Math.max(0, distanceToDefinedLo);
      }
      start = _limitValue(start, 0, pointCount - 1);
    }
    if (maxDefined) {
      let end = Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      );
      if (spanGaps) {
        const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        end += Math.max(0, distanceToDefinedHi);
      }
      count = _limitValue(end, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
function getDatasetClipArea(chart, meta) {
  const clip = meta._clip;
  if (clip.disabled) {
    return false;
  }
  const area = getDatasetArea(meta, chart.chartArea);
  return {
    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
  };
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options.all) {
    return 0;
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = (meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      const result = lookupMethod(data, axis, value);
      if (spanGaps) {
        const { vScale } = controller._cachedMeta;
        const { _parsed } = metaset;
        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.lo -= Math.max(0, distanceToDefinedLo);
        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.hi += Math.max(0, distanceToDefinedHi);
      }
      return result;
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.9";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    const clip = getDatasetClipArea(this, meta);
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (clip) {
      clipArea(ctx, clip);
    }
    meta.controller.draw();
    if (clip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
  return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
    if (!options.forceOverride && containsColorDefenition) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { chart, index: index2, line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  const meta = chart.getDatasetMeta(index2);
  const clip = getDatasetClipArea(chart, meta);
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis,
      clip
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale, clip } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property,
      clip
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property,
    clip
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale, clip } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, clip, bounds) {
  const chartArea = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x" || property === "y") {
    let left, top, right, bottom;
    if (property === "x") {
      left = start;
      top = chartArea.top;
      right = end;
      bottom = chartArea.bottom;
    } else {
      left = chartArea.left;
      top = start;
      right = chartArea.right;
      bottom = end;
    }
    ctx.beginPath();
    if (clip) {
      left = Math.max(left, clip.left);
      right = Math.min(right, clip.right);
      top = Math.max(top, clip.top);
      bottom = Math.min(bottom, clip.bottom);
    }
    ctx.rect(left, top, right - left, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash || []);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// main.ts
Chart.register(...registerables);
var HABIT_TRACKER_VIEW_TYPE = "habit-tracker-view";
var DEFAULT_SETTINGS = {
  mySetting: "default",
  habits: [],
  // Initialize with an empty array of habits
  completionData: {},
  // Initialize with an empty object for completion data
  weekStartsOn: 0
  // Default to Sunday
};
var TrackerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "open-habit-tracker-view",
      name: "Open Habit Tracker View",
      callback: () => {
        this.activateView(HABIT_TRACKER_VIEW_TYPE);
      }
    });
    this.registerView(
      HABIT_TRACKER_VIEW_TYPE,
      (leaf) => new HabitTrackerView(leaf, this)
      // Pass the plugin instance to the view
    );
    this.addRibbonIcon("check-circle", "Open Habit Tracker", () => {
      this.activateView(HABIT_TRACKER_VIEW_TYPE);
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
    });
    this.registerInterval(window.setInterval(() => console.log("interval"), 5 * 60 * 1e3));
  }
  ounload() {
    this.app.workspace.detachLeavesOfType(HABIT_TRACKER_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.migrateSettings();
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Helper method for data migration
  migrateSettings() {
    console.log("[Habit Tracker] Checking for data migration...");
    let migrationNeeded = false;
    for (const date in this.settings.completionData) {
      const dailyData = this.settings.completionData[date];
      for (const habitName in dailyData) {
        const rawStatus = dailyData[habitName];
        const habitDef = this.settings.habits.find((h) => h.name === habitName);
        if (habitDef && habitDef.type === "boolean") {
          if (rawStatus === false) {
            console.log(`[Habit Tracker] Migrating boolean 'false' to 'null' for "${habitName}" on ${date}.`);
            dailyData[habitName] = null;
            migrationNeeded = true;
          }
          if (typeof rawStatus === "number" && habitDef.frequency === "day" && (habitDef.completionGoal === void 0 || habitDef.completionGoal <= 1)) {
            console.warn(`[Habit Tracker] Unexpected number data for boolean habit "${habitName}" on ${date}. Setting to null.`);
            dailyData[habitName] = null;
            migrationNeeded = true;
          }
        } else if (habitDef && habitDef.type === "number") {
          if (typeof rawStatus === "number" && !Array.isArray(rawStatus)) {
            console.log(`[Habit Tracker] Migrating number data from single value to array for "${habitName}" on ${date}.`);
            dailyData[habitName] = [rawStatus];
            migrationNeeded = true;
          } else if (rawStatus === null || rawStatus === void 0) {
            dailyData[habitName] = null;
          } else if (!Array.isArray(rawStatus) && typeof rawStatus !== "number") {
            console.warn(`[Habit Tracker] Unexpected non-array/non-number data for number habit "${habitName}" on ${date}. Setting to null.`);
            dailyData[habitName] = null;
            migrationNeeded = true;
          }
        } else if (habitDef && habitDef.type === "text") {
          if (rawStatus !== null && typeof rawStatus !== "string") {
            console.warn(`[Habit Tracker] Unexpected non-string data for text habit "${habitName}" on ${date}. Setting to null.`);
            dailyData[habitName] = null;
            migrationNeeded = true;
          } else if (rawStatus === void 0) {
            dailyData[habitName] = null;
          }
        } else if (!habitDef && rawStatus !== void 0) {
          console.warn(`[Habit Tracker] Data found for unknown habit "${habitName}" on ${date}.`);
        }
      }
      const hasEntries = Object.values(dailyData).some((value) => value !== null && value !== void 0);
      if (!hasEntries) {
        console.log(`[Habit Tracker] Clearing empty date entry for ${date}.`);
        delete this.settings.completionData[date];
        migrationNeeded = true;
      }
    }
    this.settings.habits.forEach((habit) => {
      if (habit.statsType === void 0) {
        console.log(`[Habit Tracker] Adding default statsType for habit "${habit.name}".`);
        habit.statsType = habit.type === "number" ? "bar" : "heatmap";
        migrationNeeded = true;
      }
      if (habit.type === "number" && habit.statsType === "heatmap") {
        console.log(`[Habit Tracker] Changing statsType from 'heatmap' to 'bar' for number habit "${habit.name}".`);
        habit.statsType = "bar";
        migrationNeeded = true;
      }
      if ((habit.type === "boolean" || habit.type === "text") && habit.statsType !== "heatmap") {
        console.log(`[Habit Tracker] Changing statsType to 'heatmap' for ${habit.type} habit "${habit.name}".`);
        habit.statsType = "heatmap";
        migrationNeeded = true;
      }
    });
    if (migrationNeeded) {
      console.log("[Habit Tracker] Data migration completed. Saving settings.");
    } else {
      console.log("[Habit Tracker] No data migration needed.");
    }
  }
  async activateView(viewType) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(viewType);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: viewType, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (viewType === HABIT_TRACKER_VIEW_TYPE && leaf.view instanceof HabitTrackerView) {
        leaf.view.renderView();
      }
    }
  }
};
var HabitTrackerView = class extends import_obsidian.ItemView {
  // Set the icon property for the merged view
  constructor(leaf, plugin) {
    super(leaf);
    // New state variable for Monthly Overview
    this.monthlyOverviewGridContainer = null;
    // Reference to the monthly overview grid container
    this.monthlyOverviewDateDisplayEl = null;
    // Reference to the date display element
    // State for Statistics Section
    this.currentStatsPeriod = "month";
    // Represents the start of the currently viewed month or year for Stats
    this.statsContentContainer = null;
    // Reference to the stats content container
    this.statsDateDisplayEl = null;
    // Reference to the date display element in stats
    this.chartInstances = /* @__PURE__ */ new Map();
    // To store Chart.js instances for each habit (using Chart type)
    // Define the icon for this view type
    this.icon = "check-circle";
    this.plugin = plugin;
    this.currentWeekStart = moment().startOf("week");
    this.currentMonthOverviewDate = moment().startOf("month");
    this.currentStatsDate = moment().startOf("month");
  }
  getViewType() {
    return HABIT_TRACKER_VIEW_TYPE;
  }
  getDisplayText() {
    return "Habit Tracker";
  }
  // onOpen is called when the view is opened
  async onOpen() {
    const { contentEl } = this;
    this.containerEl.addClass("habit-tracker-view");
    contentEl.empty();
    this.renderView();
  }
  // Main method to render the entire view structure
  renderView() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Habit Check-in" });
    this.addCheckinNavigationAndDateDisplay(contentEl);
    this.renderCheckinGrid(contentEl);
    contentEl.createEl("hr");
    contentEl.createEl("h2", { text: "Monthly Overview" });
    this.addMonthlyOverviewNavigation(contentEl);
    this.monthlyOverviewGridContainer = contentEl.createEl("div", { cls: "habit-monthly-overview-grid-container" });
    this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
    contentEl.createEl("hr");
    contentEl.createEl("h2", { text: "Habit Statistics" });
    let statsSectionContainer = contentEl.querySelector(".habit-stats-section-container");
    if (!statsSectionContainer) {
      statsSectionContainer = contentEl.createEl("div", { cls: "habit-stats-section-container" });
    }
    const existingControls = statsSectionContainer.querySelector(".habit-stats-controls");
    if (!existingControls) {
      console.log("[Habit Tracker] Adding stats controls and content container...");
      this.addStatsControls(statsSectionContainer);
    } else {
      console.log("[Habit Tracker] Stats controls and content container exist, updating view.");
      this.updateStatsView();
    }
  }
  // --- Check-in Section Rendering and Control Logic ---
  addCheckinNavigationAndDateDisplay(containerEl) {
    containerEl.findAll(".habit-grid-nav").forEach((el) => el.remove());
    const navContainer = containerEl.createEl("div", { cls: "habit-grid-nav" });
    const prevButton = navContainer.createEl("button", { text: "<< Prev", cls: "habit-grid-nav-button" });
    prevButton.addEventListener("click", (evt) => {
      evt.preventDefault();
      this.currentWeekStart.subtract(7, "days");
      this.renderView();
    });
    const dateRangeEl = navContainer.createEl("span", { cls: "habit-grid-date-range" });
    const nextButton = navContainer.createEl("button", { text: "Next >>", cls: "habit-grid-nav-button" });
    nextButton.addEventListener("click", (evt) => {
      evt.preventDefault();
      this.currentWeekStart.add(7, "days");
      this.renderView();
    });
  }
  // Add a method to render/re-render the weekly check-in grid
  renderCheckinGrid(containerEl) {
    var _a;
    (_a = containerEl.querySelector(".habit-grid-container")) == null ? void 0 : _a.remove();
    const habits = this.plugin.settings.habits;
    const completionData = this.plugin.settings.completionData;
    if (habits.length === 0) {
      const existingMsg = containerEl.querySelector(".no-habits-message");
      if (!existingMsg) {
        containerEl.createEl("p", { text: "No habits defined yet. Go to plugin settings to add habits.", cls: "no-habits-message" });
      }
      return;
    } else {
      containerEl.findAll(".no-habits-message").forEach((el) => el.remove());
    }
    const gridContainer = containerEl.createEl("div", { cls: "habit-grid-container" });
    const startOfWeek = this.currentWeekStart.clone();
    const weekDates = [];
    const dateFormat = "YYYY-MM-DD";
    for (let i = 0; i < 7; i++) {
      const currentDay = startOfWeek.clone().add(i, "days");
      weekDates.push(currentDay.format(dateFormat));
    }
    const dateRangeEl = containerEl.querySelector(".habit-grid-nav .habit-grid-date-range");
    if (dateRangeEl) {
      const start = moment(weekDates[0]);
      const end = moment(weekDates[6]);
      dateRangeEl.setText(`${start.format("YYYY MM.DD")}-${end.format("MM.DD")}`);
    }
    const headerRow = gridContainer.createEl("div", { cls: "habit-grid-header-row" });
    headerRow.createEl("div", { cls: "habit-grid-header-corner" });
    const dayOfWeekLabelsShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const orderedDaysOfWeek = [];
    const startDayIndex = this.plugin.settings.weekStartsOn;
    for (let i = 0; i < 7; i++) {
      orderedDaysOfWeek.push(dayOfWeekLabelsShort[(startDayIndex + i) % 7]);
    }
    orderedDaysOfWeek.forEach((dayLabel, i) => {
      const dayHeaderEl = headerRow.createEl("div", { cls: "habit-grid-day-header" });
      dayHeaderEl.createSpan({ text: dayLabel, cls: "habit-grid-day-name" });
      const dateForThisDayLabel = weekDates[i];
      if (dateForThisDayLabel) {
        dayHeaderEl.createSpan({ text: moment(dateForThisDayLabel).format("DD"), cls: "habit-grid-day-date" });
      } else {
        dayHeaderEl.createSpan({ text: "", cls: "habit-grid-day-date" });
      }
    });
    habits.forEach((habit) => {
      const habitRow = gridContainer.createEl("div", { cls: "habit-grid-row" });
      habitRow.createEl("div", { text: habit.name, cls: "habit-grid-habit-name" });
      weekDates.forEach((date) => {
        var _a2, _b, _c;
        const checkinCell = habitRow.createEl("div", {
          cls: "habit-grid-checkin-cell",
          attr: {
            "data-habit-name": habit.name,
            "data-date": date,
            "data-habit-type": habit.type
          }
        });
        const statusCircle = checkinCell.createEl("div", { cls: "status-circle" });
        const statusValueDisplay = checkinCell.createSpan({ cls: "status-value-display" });
        const rawStatus = (_b = (_a2 = this.plugin.settings.completionData[date]) == null ? void 0 : _a2[habit.name]) != null ? _b : null;
        let statusForAppearance = rawStatus;
        if (habit.type === "number" && Array.isArray(rawStatus)) {
          statusForAppearance = rawStatus.reduce((sum, current) => sum + current, 0);
        } else if (habit.type === "boolean" && habit.frequency === "day" && habit.completionGoal !== void 0 && habit.completionGoal > 1) {
          statusForAppearance = typeof rawStatus === "number" ? rawStatus : 0;
        }
        let weeklyPercentageForCell;
        if (habit.type === "boolean" && habit.frequency === "week") {
          const weekStartDate = moment(date, dateFormat).startOf("week");
          const weekEndDate = weekStartDate.clone().endOf("week");
          let weeklyCompletions = 0;
          const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
          let dayIterator = weekStartDate.clone();
          while (dayIterator.isSameOrBefore(weekEndDate, "day")) {
            const dayString = dayIterator.format(dateFormat);
            if (moment(dayString, dateFormat).isBetween(startOfWeek.clone().subtract(1, "day"), startOfWeek.clone().add(7, "days"), "day", "(]")) {
              const statusForDay = (_c = completionData[dayString]) == null ? void 0 : _c[habit.name];
              if (statusForDay === true) {
                weeklyCompletions++;
              }
            }
            dayIterator.add(1, "day");
          }
          weeklyPercentageForCell = completionGoal > 0 ? Math.min(weeklyCompletions / completionGoal * 100, 100) : 0;
        }
        this.updateCellAppearance(checkinCell, habit, statusForAppearance, weeklyPercentageForCell);
        checkinCell.addEventListener("click", async () => {
          var _a3;
          const clickedHabitName = checkinCell.getAttribute("data-habit-name");
          const clickedDate = checkinCell.getAttribute("data-date");
          const clickedHabitType = checkinCell.getAttribute("data-habit-type");
          const clickedHabit = this.plugin.settings.habits.find((h) => h.name === clickedHabitName);
          if (!clickedHabitName || !clickedDate || !clickedHabitType || !clickedHabit) {
            console.error("Clicked cell missing data attributes or habit not found!");
            return;
          }
          if (!this.plugin.settings.completionData[clickedDate]) {
            this.plugin.settings.completionData[clickedDate] = {};
          }
          if (clickedHabitType === "boolean") {
            const completionGoal = clickedHabit.completionGoal !== void 0 && clickedHabit.completionGoal !== null && clickedHabit.completionGoal > 0 ? clickedHabit.completionGoal : 1;
            if (clickedHabit.frequency === "day" && completionGoal > 1) {
              let currentCount = (_a3 = this.plugin.settings.completionData[clickedDate][clickedHabitName]) != null ? _a3 : 0;
              let newCount = currentCount + 1;
              if (newCount > completionGoal) {
                newCount = 0;
              }
              this.plugin.settings.completionData[clickedDate][clickedHabitName] = newCount > 0 ? newCount : null;
              await this.plugin.saveSettings();
              let noticeMessage = `${clickedHabitName} on ${clickedDate}: `;
              if (newCount === 0) {
                noticeMessage += "Count reset.";
              } else {
                noticeMessage += `Count: ${newCount}/${completionGoal}.`;
              }
              new import_obsidian.Notice(noticeMessage, 2e3);
            } else {
              const currentStatus = this.plugin.settings.completionData[clickedDate][clickedHabitName];
              let newStatus;
              if (currentStatus === true) {
                newStatus = null;
              } else {
                newStatus = true;
              }
              this.plugin.settings.completionData[clickedDate][clickedHabitName] = newStatus;
              await this.plugin.saveSettings();
              let noticeMessage = `${clickedHabitName} on ${clickedDate} `;
              if (newStatus === true)
                noticeMessage += "marked as Completed.";
              else
                noticeMessage += "entry cleared.";
              new import_obsidian.Notice(noticeMessage, 2e3);
            }
            this.renderView();
          } else if (clickedHabitType === "number") {
            new NumberInputModal(
              this.app,
              this.plugin,
              clickedDate,
              clickedHabitName,
              this.plugin.settings.completionData[clickedDate][clickedHabitName],
              // Pass raw array
              () => {
                this.renderView();
              }
            ).open();
          } else if (clickedHabitType === "text") {
            new TextInputModal(
              this.app,
              this.plugin,
              clickedDate,
              clickedHabitName,
              this.plugin.settings.completionData[clickedDate][clickedHabitName],
              () => {
                this.renderView();
              }
            ).open();
          }
        });
      });
    });
  }
  // Method to add monthly overview navigation controls
  addMonthlyOverviewNavigation(containerEl) {
    containerEl.findAll(".monthly-overview-header-nav").forEach((el) => el.remove());
    const navContainer = containerEl.createEl("div", { cls: "habit-grid-nav monthly-overview-header-nav" });
    const prevButton = navContainer.createEl("button", { text: "<< Prev", cls: "habit-grid-nav-button" });
    prevButton.addEventListener("click", (evt) => {
      evt.preventDefault();
      this.currentMonthOverviewDate.subtract(1, "month");
      if (this.monthlyOverviewGridContainer) {
        this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
      }
      if (this.monthlyOverviewDateDisplayEl) {
        this.updateMonthlyOverviewDateDisplay(this.monthlyOverviewDateDisplayEl);
      }
    });
    this.monthlyOverviewDateDisplayEl = navContainer.createEl("span", { cls: "habit-grid-date-range monthly-overview-date-display" });
    this.updateMonthlyOverviewDateDisplay(this.monthlyOverviewDateDisplayEl);
    const nextButton = navContainer.createEl("button", { text: "Next >>", cls: "habit-grid-nav-button" });
    nextButton.addEventListener("click", (evt) => {
      evt.preventDefault();
      this.currentMonthOverviewDate.add(1, "month");
      if (this.monthlyOverviewGridContainer) {
        this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
      }
      if (this.monthlyOverviewDateDisplayEl) {
        this.updateMonthlyOverviewDateDisplay(this.monthlyOverviewDateDisplayEl);
      }
    });
  }
  // Helper method to update the monthly overview date display
  updateMonthlyOverviewDateDisplay(dateDisplayEl) {
    dateDisplayEl.setText(this.currentMonthOverviewDate.format("YYYY MMMM"));
  }
  // --- Render Monthly Overview Grid Section ---
  // Modified to use currentMonthOverviewDate and revert to 1fr columns for flexible sizing
  // This method now takes the container element where it should render
  renderMonthlyOverviewGrid(containerEl) {
    containerEl.empty();
    const habits = this.plugin.settings.habits;
    const completionData = this.plugin.settings.completionData;
    if (habits.length === 0) {
      const noHabitsMessage = containerEl.createEl("p", { cls: "no-habits-message", text: "No habits defined to display monthly overview." });
      noHabitsMessage.style.textAlign = "center";
      noHabitsMessage.style.color = "var(--text-muted)";
      return;
    } else {
      containerEl.findAll(".no-habits-message").forEach((el) => el.remove());
    }
    const currentMonth = this.currentMonthOverviewDate.clone().startOf("month");
    const daysInMonth = currentMonth.daysInMonth();
    const dateFormat = "YYYY-MM-DD";
    containerEl.addClass("habit-monthly-overview-grid");
    const headerRow = containerEl.createEl("div", { cls: "habit-grid-header-row monthly-overview-header-row" });
    headerRow.createEl("div", { cls: "habit-grid-header-corner" });
    for (let day = 1; day <= daysInMonth; day++) {
      const dayHeaderCell = containerEl.createEl("div", { cls: "monthly-overview-day-header" });
      const dateMoment = currentMonth.clone().date(day);
      if (moment().isSame(dateMoment, "day")) {
        dayHeaderCell.addClass("is-today");
      }
      dayHeaderCell.createSpan({ text: String(day), cls: "daily-date-label" });
    }
    habits.forEach((habit) => {
      var _a, _b, _c;
      const habitRow = containerEl.createEl("div", { cls: "habit-grid-row monthly-overview-habit-row" });
      habitRow.createEl("div", { text: habit.name, cls: "habit-grid-habit-name" });
      for (let day = 1; day <= daysInMonth; day++) {
        const dateMoment = currentMonth.clone().date(day);
        const dateString = dateMoment.format(dateFormat);
        const dataCell = containerEl.createEl("div", {
          // Create directly in containerEl
          cls: "habit-grid-checkin-cell monthly-overview-data-cell",
          // Reuse checkin-cell class
          attr: {
            "data-habit-name": habit.name,
            "data-date": dateString,
            // Add date attribute for updateCellAppearance
            "data-habit-type": habit.type
            // Add type attribute
          }
        });
        const statusCircle = dataCell.createEl("div", { cls: "status-circle" });
        const statusValueDisplay = dataCell.createSpan({ cls: "status-value-display" });
        const rawStatus = (_b = (_a = this.plugin.settings.completionData[dateString]) == null ? void 0 : _a[habit.name]) != null ? _b : null;
        let statusForAppearance = rawStatus;
        if (habit.type === "number" && Array.isArray(rawStatus)) {
          statusForAppearance = rawStatus.reduce((sum, current) => sum + current, 0);
        } else if (habit.type === "boolean" && habit.frequency === "day" && habit.completionGoal !== void 0 && habit.completionGoal > 1) {
          statusForAppearance = typeof rawStatus === "number" ? rawStatus : 0;
        }
        let weeklyPercentageForCell;
        if (habit.type === "boolean" && habit.frequency === "week") {
          const weekStartDate = dateMoment.clone().startOf("week");
          const weekEndDate = weekStartDate.clone().endOf("week");
          let weeklyCompletions = 0;
          const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
          let dayIterator = weekStartDate.clone();
          while (dayIterator.isSameOrBefore(weekEndDate, "day")) {
            const dayString = dayIterator.format(dateFormat);
            if (moment(dayString, dateFormat).isBetween(currentMonth.clone().subtract(1, "day"), currentMonth.clone().endOf("month").add(1, "day"), "day", "(]")) {
              const statusForDay = (_c = completionData[dayString]) == null ? void 0 : _c[habit.name];
              if (statusForDay === true) {
                weeklyCompletions++;
              }
            }
            dayIterator.add(1, "day");
          }
          weeklyPercentageForCell = completionGoal > 0 ? Math.min(weeklyCompletions / completionGoal * 100, 100) : 0;
        }
        this.updateCellAppearance(dataCell, habit, statusForAppearance, weeklyPercentageForCell);
        if (moment().isSame(dateString, "day")) {
          dataCell.addClass("is-today");
        }
        dataCell.addEventListener("click", async () => {
          var _a2;
          const clickedHabitName = dataCell.getAttribute("data-habit-name");
          const clickedDate = dataCell.getAttribute("data-date");
          const clickedHabitType = dataCell.getAttribute("data-habit-type");
          const clickedHabit = this.plugin.settings.habits.find((h) => h.name === clickedHabitName);
          if (!clickedHabitName || !clickedDate || !clickedHabitType || !clickedHabit) {
            console.error("Clicked cell missing data attributes or habit not found!");
            return;
          }
          if (!this.plugin.settings.completionData[clickedDate]) {
            this.plugin.settings.completionData[clickedDate] = {};
          }
          if (clickedHabitType === "boolean") {
            const completionGoal = clickedHabit.completionGoal !== void 0 && clickedHabit.completionGoal !== null && clickedHabit.completionGoal > 0 ? clickedHabit.completionGoal : 1;
            if (clickedHabit.frequency === "day" && completionGoal > 1) {
              let currentCount = (_a2 = this.plugin.settings.completionData[clickedDate][clickedHabitName]) != null ? _a2 : 0;
              let newCount = currentCount + 1;
              if (newCount > completionGoal) {
                newCount = 0;
              }
              this.plugin.settings.completionData[clickedDate][clickedHabitName] = newCount > 0 ? newCount : null;
              await this.plugin.saveSettings();
              let noticeMessage = `${clickedHabitName} on ${clickedDate}: `;
              if (newCount === 0) {
                noticeMessage += "Count reset.";
              } else {
                noticeMessage += `Count: ${newCount}/${completionGoal}.`;
              }
              new import_obsidian.Notice(noticeMessage, 2e3);
            } else {
              const currentStatus = this.plugin.settings.completionData[clickedDate][clickedHabitName];
              let newStatus;
              if (currentStatus === true) {
                newStatus = null;
              } else {
                newStatus = true;
              }
              this.plugin.settings.completionData[clickedDate][clickedHabitName] = newStatus;
              await this.plugin.saveSettings();
              let noticeMessage = `${clickedHabitName} on ${clickedDate} `;
              if (newStatus === true)
                noticeMessage += "marked as Completed.";
              else
                noticeMessage += "entry cleared.";
              new import_obsidian.Notice(noticeMessage, 2e3);
            }
            if (this.monthlyOverviewGridContainer) {
              this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
            }
          } else if (clickedHabitType === "number") {
            new NumberInputModal(
              this.app,
              this.plugin,
              clickedDate,
              clickedHabitName,
              this.plugin.settings.completionData[clickedDate][clickedHabitName],
              // Pass raw array
              () => {
                if (this.monthlyOverviewGridContainer) {
                  this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
                }
              }
            ).open();
          } else if (clickedHabitType === "text") {
            new TextInputModal(
              this.app,
              this.plugin,
              clickedDate,
              clickedHabitName,
              this.plugin.settings.completionData[clickedDate][clickedName],
              () => {
                if (this.monthlyOverviewGridContainer) {
                  this.renderMonthlyOverviewGrid(this.monthlyOverviewGridContainer);
                }
              }
            ).open();
          }
        });
      }
    });
    const firstColumnWidth = "auto";
    const columnGap = "4px";
    containerEl.style.gridTemplateColumns = `${firstColumnWidth} repeat(${daysInMonth}, 1fr)`;
    containerEl.style.gap = columnGap;
  }
  // Helper function to update the visual state of a cell's content (shared logic)
  // This function now handles color based on completion count vs goal for boolean habits
  // The 'status' parameter now represents:
  // - Daily Boolean (goal <= 1): boolean (true/null)
  // - Daily Boolean (goal > 1): number (count)
  // - Weekly Boolean: boolean (true/null) - Needs to calculate weekly progress internally using raw data (OR receives percentage for heatmap)
  // - Number: number (sum of daily entries)
  // - Text: string (text entry)
  // Added optional weeklyPercentage parameter for heatmap cells (now also used for non-heatmap weekly boolean)
  updateCellAppearance(cellEl, habit, status, weeklyPercentage) {
    const isHeatmapCell = cellEl.hasClass("heatmap-cell");
    const statusCircleEl = isHeatmapCell ? null : cellEl.querySelector(".status-circle");
    const statusValueDisplayEl = isHeatmapCell ? null : cellEl.querySelector(".status-value-display");
    if (!isHeatmapCell && (!statusCircleEl || !statusValueDisplayEl)) {
      console.error("Missing status circle or value display element in non-heatmap cell!");
      return;
    }
    const targetEl = isHeatmapCell ? cellEl : statusCircleEl;
    if (targetEl) {
      targetEl.removeClass(
        "is-boolean",
        "is-mood",
        "is-text",
        "has-value",
        "has-emoji",
        "goal-met",
        "goal-progress-zero",
        "goal-progress-medium",
        "goal-progress-high",
        "has-value-no-goal",
        "is-incomplete",
        "is-completed",
        // Existing boolean states
        // Boolean progress states
        "progress-low",
        "progress-medium",
        "progress-high"
      );
      targetEl.style.border = "";
      targetEl.style.backgroundColor = "";
      targetEl.style.backgroundImage = "";
      targetEl.style.opacity = "";
    }
    if (statusCircleEl) {
      statusCircleEl.empty();
    }
    if (statusValueDisplayEl) {
      statusValueDisplayEl.empty();
      statusValueDisplayEl.style.display = "none";
    }
    if (habit.type === "boolean") {
      if (targetEl)
        targetEl.addClass("is-boolean");
      const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
      if (habit.frequency === "day") {
        let currentCompletions = 0;
        if (completionGoal > 1) {
          currentCompletions = typeof status === "number" ? status : 0;
          if (!isHeatmapCell && statusValueDisplayEl && currentCompletions > 0) {
            statusValueDisplayEl.style.display = "";
            statusValueDisplayEl.setText(String(currentCompletions));
          }
        } else {
          currentCompletions = status === true ? 1 : 0;
        }
        if (currentCompletions > 0) {
          if (targetEl)
            targetEl.addClass("has-value");
          if (completionGoal > 1) {
            const percentage = completionGoal > 0 ? Math.min(currentCompletions / completionGoal * 100, 100) : 0;
            if (percentage >= 100) {
              if (targetEl)
                targetEl.addClass("goal-met");
            } else if (percentage > 66) {
              if (targetEl)
                targetEl.addClass("progress-high");
            } else if (percentage > 33) {
              if (targetEl)
                targetEl.addClass("progress-medium");
            } else if (percentage > 0) {
              if (targetEl)
                targetEl.addClass("progress-low");
            }
          } else {
            if (targetEl)
              targetEl.addClass("is-completed");
          }
        } else {
          if (targetEl)
            targetEl.addClass("is-incomplete");
        }
      } else {
        const dailyStatus = status === true;
        const percentage = weeklyPercentage !== void 0 ? weeklyPercentage : 0;
        if (dailyStatus) {
          if (percentage >= 100) {
            if (targetEl) {
              targetEl.addClass("goal-met");
            }
          } else if (percentage > 66) {
            if (targetEl) {
              targetEl.addClass("progress-high");
            }
          } else if (percentage > 33) {
            if (targetEl) {
              targetEl.addClass("progress-medium");
            }
          } else if (percentage > 0) {
            if (targetEl) {
              targetEl.addClass("progress-low");
            }
          } else {
          }
        } else {
          targetEl == null ? void 0 : targetEl.removeClass("goal-met", "progress-high", "progress-medium", "progress-low");
        }
        if (dailyStatus) {
          if (targetEl) {
            targetEl.addClass("has-value");
            targetEl.removeClass("is-incomplete");
          }
        } else {
          if (targetEl) {
            targetEl.addClass("is-incomplete");
            targetEl.removeClass("has-value");
          }
        }
        if (!isHeatmapCell && statusCircleEl && dailyStatus) {
        }
      }
    } else if (habit.type === "number") {
      if (targetEl)
        targetEl.addClass("is-mood");
      if (status !== null && status !== void 0 && typeof status === "number") {
        if (status > 0 || status === 0 && habit.goal !== void 0 && habit.goal !== null && habit.goal > 0) {
          if (targetEl)
            targetEl.addClass("has-value");
        }
        if (!isHeatmapCell && statusValueDisplayEl) {
          statusValueDisplayEl.style.display = "";
          statusValueDisplayEl.createSpan({ text: status.toFixed(2) + (habit.unit || "") });
        }
        let percentage = 0;
        if (habit.goal !== void 0 && habit.goal !== null && habit.goal > 0) {
          percentage = Math.min(status / habit.goal * 100, 100);
        }
        if (percentage >= 100) {
          if (targetEl)
            targetEl.addClass("goal-met");
        } else if (percentage > 50) {
          if (targetEl)
            targetEl.addClass("goal-progress-high");
        } else if (percentage > 0) {
          if (targetEl)
            targetEl.addClass("goal-progress-medium");
        } else if (status === 0 && (habit.goal !== void 0 && habit.goal !== null && habit.goal > 0)) {
          if (targetEl)
            targetEl.addClass("goal-progress-zero");
        } else if (status > 0 && (habit.goal === void 0 || habit.goal === null || habit.goal <= 0)) {
          if (targetEl)
            targetEl.addClass("has-value-no-goal");
        } else {
          if (targetEl)
            targetEl.addClass("is-incomplete");
        }
      } else {
        if (targetEl)
          targetEl.addClass("is-incomplete");
        if (statusValueDisplayEl)
          statusValueDisplayEl.style.display = "none";
        if (targetEl)
          targetEl.removeClass("has-emoji");
      }
    } else if (habit.type === "text") {
      if (targetEl)
        targetEl.addClass("is-text");
      if (status !== null && status !== void 0 && typeof status === "string" && status.length > 0) {
        if (targetEl)
          targetEl.addClass("has-value");
        if (!isHeatmapCell) {
          const isLikelyEmoji = status.length > 0 && status.length <= 4;
          if (isLikelyEmoji) {
            statusCircleEl == null ? void 0 : statusCircleEl.empty();
            statusCircleEl == null ? void 0 : statusCircleEl.createSpan({ text: status, cls: "status-emoji" });
            if (statusCircleEl) {
              statusCircleEl.style.border = "none";
              statusCircleEl.style.backgroundColor = "transparent";
            }
            if (statusValueDisplayEl)
              statusValueDisplayEl.style.display = "none";
            if (targetEl)
              targetEl.addClass("has-emoji");
          } else {
            if (statusCircleEl) {
              statusCircleEl.style.border = "2px dashed var(--text-accent)";
              statusCircleEl.style.backgroundColor = "transparent";
            }
            if (statusValueDisplayEl) {
              statusValueDisplayEl.style.display = "";
              statusValueDisplayEl.createSpan({ text: status });
            }
            if (targetEl)
              targetEl.removeClass("has-emoji");
          }
        } else {
          if (status !== null && status !== void 0 && typeof status === "string" && status.length > 0) {
            if (targetEl) {
              targetEl.addClass("has-value");
              targetEl.removeClass("is-incomplete");
            }
          } else {
            if (targetEl) {
              targetEl.addClass("is-incomplete");
              targetEl.removeClass("has-value");
            }
          }
        }
      } else {
        if (targetEl) {
          targetEl.addClass("is-incomplete");
          targetEl.removeClass("has-value");
        }
        if (statusValueDisplayEl)
          statusValueDisplayEl.style.display = "none";
        if (targetEl)
          targetEl.removeClass("has-emoji");
      }
    }
    if (!isHeatmapCell) {
      cellEl.style.display = "flex";
      cellEl.style.alignItems = "center";
      cellEl.style.justifyContent = "center";
      cellEl.style.gap = "4px";
    } else {
      cellEl.style.display = "flex";
      cellEl.style.alignItems = "center";
      cellEl.style.justifyContent = "center";
      cellEl.style.gap = "";
    }
  }
  // Method to add statistics navigation controls
  addStatsControls(containerEl) {
    let controlsContainer = containerEl.querySelector(".habit-stats-controls");
    if (!controlsContainer) {
      controlsContainer = containerEl.createEl("div", { cls: "habit-stats-controls" });
    }
    controlsContainer.empty();
    const periodSwitch = controlsContainer.createEl("div", { cls: "habit-stats-period-switch" });
    const monthButton = periodSwitch.createEl("button", { text: "Month", cls: "habit-stats-period-button" });
    const yearButton = periodSwitch.createEl("button", { text: "Year", cls: "habit-stats-period-button" });
    monthButton.addEventListener("click", () => {
      if (this.currentStatsPeriod !== "month") {
        this.currentStatsPeriod = "month";
        this.currentStatsDate = moment().startOf("month");
        this.updateStatsView();
      }
    });
    yearButton.addEventListener("click", () => {
      if (this.currentStatsPeriod !== "year") {
        this.currentStatsPeriod = "year";
        this.currentStatsDate = moment().startOf("year");
        this.updateStatsView();
      }
    });
    const dateNav = controlsContainer.createEl("div", { cls: "habit-stats-date-nav" });
    const prevButton = dateNav.createEl("button", { text: "<<", cls: "habit-stats-nav-button" });
    this.statsDateDisplayEl = dateNav.createEl("span", { cls: "habit-stats-date-display" });
    const nextButton = dateNav.createEl("button", { text: ">>", cls: "habit-stats-nav-button" });
    prevButton.addEventListener("click", () => {
      if (this.currentStatsPeriod === "month") {
        this.currentStatsDate.subtract(1, "month");
      } else {
        this.currentStatsDate.subtract(1, "year");
      }
      this.updateStatsView();
    });
    nextButton.addEventListener("click", () => {
      if (this.currentStatsPeriod === "month") {
        this.currentStatsDate.add(1, "month");
      } else {
        this.currentStatsDate.add(1, "year");
      }
      this.updateStatsView();
    });
    const refreshButton = controlsContainer.createEl("button", { text: "Refresh Stats", cls: "habit-stats-refresh-button" });
    refreshButton.addEventListener("click", () => {
      this.updateStatsView();
    });
    this.statsContentContainer = containerEl.createEl("div", { cls: "habit-stats-content" });
    this.updateStatsView();
  }
  // Method to update statistics controls display and trigger stats content rendering
  updateStatsView() {
    const { contentEl } = this;
    const statsSectionContainer = contentEl.querySelector(".habit-stats-section-container");
    const controlsContainer = statsSectionContainer == null ? void 0 : statsSectionContainer.querySelector(".habit-stats-controls");
    const dateDisplayEl = this.statsDateDisplayEl;
    const periodButtons = controlsContainer == null ? void 0 : controlsContainer.querySelectorAll(".habit-stats-period-button");
    if (!controlsContainer || !dateDisplayEl || !periodButtons || !this.statsContentContainer) {
      console.warn("[Habit Tracker] Stats controls or content container not found when trying to update. Skipping updateStatsView logic.");
      if (!this.statsContentContainer) {
        console.error("[Habit Tracker] Stats content container is null. Cannot render stats.");
        return;
      }
      this.renderStatsContent(this.statsContentContainer);
      return;
    }
    periodButtons.forEach((button) => {
      var _a;
      if (((_a = button.textContent) == null ? void 0 : _a.toLowerCase()) === this.currentStatsPeriod) {
        button.addClass("is-active");
      } else {
        button.removeClass("is-active");
      }
    });
    let dateDisplay = "";
    if (this.currentStatsPeriod === "month") {
      dateDisplay = this.currentStatsDate.format("YYYY MMMM");
    } else {
      dateDisplay = this.currentStatsDate.format("YYYY");
    }
    dateDisplayEl.setText(dateDisplay);
    this.renderStatsContent(this.statsContentContainer);
  }
  // Method to render or re-render ONLY the statistics content (charts, heatmaps, summaries)
  renderStatsContent(statsContentContainer) {
    statsContentContainer.empty();
    this.chartInstances.forEach((chart) => chart.destroy());
    this.chartInstances.clear();
    const habits = this.plugin.settings.habits;
    const completionData = this.plugin.settings.completionData;
    if (habits.length === 0) {
      const noHabitsMessage = statsContentContainer.createEl("p", { cls: "no-habits-message", text: "No habits defined to display statistics." });
      noHabitsMessage.style.textAlign = "center";
      noHabitsMessage.style.color = "var(--text-muted)";
      return;
    } else {
      statsContentContainer.findAll(".no-habits-message").forEach((el) => el.remove());
    }
    const periodStartDate = this.currentStatsPeriod === "month" ? this.currentStatsDate.clone().startOf("month") : this.currentStatsDate.clone().startOf("year");
    const periodEndDate = this.currentStatsPeriod === "month" ? this.currentStatsDate.clone().endOf("month") : this.currentStatsDate.clone().endOf("year");
    const allDatesInPeriod = [];
    let dateIterator = periodStartDate.clone();
    const dateFormat = "YYYY-MM-DD";
    while (dateIterator.isSameOrBefore(periodEndDate, "day")) {
      allDatesInPeriod.push(dateIterator.format(dateFormat));
      dateIterator.add(1, "day");
    }
    const habitsToDisplay = habits.filter((habit) => {
      const habitStatsType = habit.statsType || (habit.type === "number" ? "bar" : "heatmap");
      if (this.currentStatsPeriod === "month") {
        return habit.type === "number" && (habitStatsType === "bar" || habitStatsType === "line" || habitStatsType === "combo");
      } else {
        return true;
      }
    });
    habitsToDisplay.forEach((habit) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const habitStatsSection = statsContentContainer.createEl("div", { cls: "habit-stats-section" });
      habitStatsSection.createEl("h3", { text: habit.name });
      let totalValuePeriod = 0;
      let completedCountPeriod = 0;
      let recordedDaysCountPeriod = 0;
      let textValueCounts = {};
      const weeklyBooleanPercentages = {};
      if (this.currentStatsPeriod === "year" && habit.type === "boolean" && habit.frequency === "week" && (habit.statsType || "heatmap") === "heatmap") {
        const yearStartDate = this.currentStatsDate.clone().startOf("year");
        const yearEndDate = this.currentStatsDate.clone().endOf("year");
        let weekIterator = yearStartDate.clone().startOf("week");
        const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
        while (weekIterator.isSameOrBefore(yearEndDate, "day")) {
          let weeklyCompletions = 0;
          const weekEndDate = weekIterator.clone().endOf("week");
          let dayIterator = weekIterator.clone();
          while (dayIterator.isSameOrBefore(weekEndDate, "day")) {
            const dateString = dayIterator.format(dateFormat);
            if (dayIterator.isSameOrAfter(yearStartDate, "day") && dayIterator.isSameOrBefore(yearEndDate, "day")) {
              const statusForDay = (_a = completionData[dateString]) == null ? void 0 : _a[habit.name];
              if (statusForDay === true) {
                weeklyCompletions++;
              }
            }
            dayIterator.add(1, "day");
          }
          const percentage = completionGoal > 0 ? Math.min(weeklyCompletions / completionGoal * 100, 100) : 0;
          weeklyBooleanPercentages[weekIterator.format(dateFormat)] = percentage;
          weekIterator.add(1, "week");
        }
      }
      allDatesInPeriod.forEach((date) => {
        var _a2, _b2;
        const rawStatus = (_b2 = (_a2 = completionData[date]) == null ? void 0 : _a2[habit.name]) != null ? _b2 : null;
        if (rawStatus !== void 0 && rawStatus !== null) {
          if (habit.type === "boolean") {
            const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
            if (habit.frequency === "day" && completionGoal > 1) {
              if (typeof rawStatus === "number") {
                completedCountPeriod += rawStatus;
                if (rawStatus > 0)
                  recordedDaysCountPeriod += 1;
              } else {
                if (rawStatus !== null && rawStatus !== false) {
                  console.warn(`[Habit Tracker] Unexpected non-number data for daily boolean habit "${habit.name}" (goal > 1) on ${date}. Treating as 0 completions for stats.`);
                }
              }
            } else {
              if (rawStatus === true) {
                completedCountPeriod += 1;
                recordedDaysCountPeriod += 1;
              } else {
                if (typeof rawStatus !== "boolean") {
                  console.warn(`[Habit Tracker] Unexpected non-boolean data for boolean habit "${habit.name}" on ${date}. Treating as 0 completions for stats.`);
                }
              }
            }
          } else if (habit.type === "number") {
            if (Array.isArray(rawStatus)) {
              const dailySum = rawStatus.reduce((sum, current) => sum + current, 0);
              totalValuePeriod += dailySum;
              if (dailySum > 0)
                recordedDaysCountPeriod += 1;
            } else if (typeof rawStatus === "number") {
              console.warn(`[Habit Tracker] Encountered single number data for "${habit.name}" on ${date} during stats aggregation.`);
              totalValuePeriod += rawStatus;
              if (rawStatus > 0)
                recordedDaysCountPeriod += 1;
            } else {
              console.warn(`[Habit Tracker] Unexpected non-array/non-number data for number habit "${habit.name}" on ${date}. Treating as 0 for stats.`);
            }
          } else if (habit.type === "text" && typeof rawStatus === "string" && rawStatus.length > 0) {
            if (textValueCounts[rawStatus]) {
              textValueCounts[rawStatus]++;
            } else {
              textValueCounts[rawStatus] = 1;
            }
            recordedDaysCountPeriod += 1;
          } else if (habit.type === "text" && rawStatus !== null && typeof rawStatus !== "string") {
            console.warn(`[Habit Tracker] Unexpected non-string data for text habit "${habit.name}" on ${date}. Ignoring for stats.`);
          }
        }
      });
      const totalDaysInPeriod = allDatesInPeriod.length;
      const statsSummaryContainer = habitStatsSection.createEl("div", { cls: "habit-stats-summary" });
      if (habit.type === "boolean") {
        const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
        let completedText = "";
        let completionRateText = "";
        let goalText = "";
        if (habit.frequency === "day") {
          const completionDays = recordedDaysCountPeriod;
          const completionDaysRate = totalDaysInPeriod > 0 ? (completionDays / totalDaysInPeriod * 100).toFixed(1) : "N/A";
          let statsString = `Completion Days: <span class="stat-value">${completionDays}</span>/<span class="stat-denominator">${totalDaysInPeriod}</span>, Completion Rate (Days) : <span class="stat-value">${completionDaysRate}%</span>`;
          const totalPossibleGoal = completionGoal * totalDaysInPeriod;
          const totalCompletionRate = totalPossibleGoal > 0 ? (completedCountPeriod / totalPossibleGoal * 100).toFixed(1) : "N/A";
          statsString += `, Total Completions: <span class="stat-value">${completedCountPeriod}</span>/<span class="stat-denominator">${totalPossibleGoal}</span>, Completion Rate (Total) : <span class="stat-value">${totalCompletionRate}%</span>`;
          if (completionGoal !== void 0 && completionGoal !== null && completionGoal > 0) {
            goalText = `, Goal: <span class="stat-value">${completionGoal}/day</span>`;
            statsString += goalText;
          }
          statsSummaryContainer.createEl("p", { cls: "inline-stats-paragraph" }).innerHTML = statsString;
        } else {
          const completionDays = recordedDaysCountPeriod;
          const completionDaysRate = totalDaysInPeriod > 0 ? (completionDays / totalDaysInPeriod * 100).toFixed(1) : "N/A";
          let statsString = `Completed Days: <span class="stat-value">${completionDays}</span>/<span class="stat-denominator">${totalDaysInPeriod}</span>, Completion Rate (Days) : <span class="stat-value">${completionDaysRate}%</span>`;
          if (this.currentStatsPeriod === "year") {
            let completedWeeksCount = 0;
            const startYear = this.currentStatsDate.clone().startOf("year");
            const endYear = this.currentStatsDate.clone().endOf("year");
            let weekIterator = startYear.clone().startOf("week");
            const startYearMoment = this.currentStatsDate.clone().startOf("year");
            const endYearMoment = this.currentStatsDate.clone().endOf("year");
            const firstWeekStartOfPeriod = startYearMoment.clone().startOf("week");
            const lastWeekStartOfPeriod = endYearMoment.clone().startOf("week");
            const totalWeeksInPeriod = lastWeekStartOfPeriod.diff(firstWeekStartOfPeriod, "weeks") + 1;
            while (weekIterator.isSameOrBefore(endYear, "day")) {
              let weeklyCompletions = 0;
              const weekEndDate = weekIterator.clone().endOf("week");
              let dayIterator = weekIterator.clone();
              while (dayIterator.isSameOrBefore(weekEndDate, "day") && dayIterator.isSameOrBefore(endYear, "day")) {
                const dateString = dayIterator.format(dateFormat);
                const statusForDay = (_b = completionData[dateString]) == null ? void 0 : _b[habit.name];
                if (statusForDay === true) {
                  weeklyCompletions++;
                }
                dayIterator.add(1, "day");
              }
              if (weekIterator.isSameOrBefore(endYear, "day") && weekEndDate.isSameOrAfter(startYear, "day")) {
                if (completionGoal !== void 0 && completionGoal !== null && completionGoal > 0 && weeklyCompletions >= completionGoal) {
                  completedWeeksCount++;
                } else if ((completionGoal === void 0 || completionGoal === null || completionGoal <= 0) && weeklyCompletions > 0) {
                  completedWeeksCount++;
                }
              }
              weekIterator.add(1, "week");
            }
            statsString += `, Completed Weeks: <span class="stat-value">${completedWeeksCount}</span>/<span class="stat-denominator">${totalWeeksInPeriod}</span>`;
            if (completionGoal !== void 0 && completionGoal !== null && completionGoal > 0) {
              goalText = `, Goal: <span class="stat-value">${completionGoal}/week</span>`;
              statsString += goalText;
            }
          } else {
            if (completionGoal !== void 0 && completionGoal !== null && completionGoal > 0) {
              goalText = `, Goal: <span class="stat-value">${completionGoal}/week</span>`;
              statsString += goalText;
            }
          }
          statsSummaryContainer.createEl("p", { cls: "inline-stats-paragraph" }).innerHTML = statsString;
        }
      } else if (habit.type === "number") {
        const totalValueText = `Total Value: <span class="stat-value">${totalValuePeriod.toFixed(2)}</span><span class="stat-unit">${habit.unit || ""}</span>`;
        let averageValueText = "";
        let totalDaysText = "";
        if (recordedDaysCountPeriod > 0) {
          averageValueText = `, Average Value: <span class="stat-value">${(totalValuePeriod / recordedDaysCountPeriod).toFixed(2)}</span><span class="stat-unit">${habit.unit || ""}</span>`;
          totalDaysText = `, Days with Entry: <span class="stat-value">${recordedDaysCountPeriod}</span>/<span class="stat-denominator">${totalDaysInPeriod}</span>`;
        } else {
          averageValueText = `, Average Value: <span class="stat-value">N/A</span>`;
          totalDaysText = `, Days with Entry: <span class="stat-value">0</span>/<span class="stat-denominator">${totalDaysInPeriod}</span>`;
        }
        statsSummaryContainer.createEl("p", { cls: "inline-stats-paragraph" }).innerHTML = totalValueText + averageValueText + totalDaysText;
      } else if (habit.type === "text") {
        const totalEntries = recordedDaysCountPeriod;
        const totalEntriesText = `Days with Entry: <span class="stat-value">${totalEntries}</span>/<span class="stat-denominator">${totalDaysInPeriod}</span>`;
        statsSummaryContainer.createEl("p", { cls: "inline-stats-paragraph" }).innerHTML = totalEntriesText;
        if (totalEntries > 0) {
          const uniqueTexts = Object.keys(textValueCounts);
          uniqueTexts.sort();
          uniqueTexts.forEach((text) => {
            const count = textValueCounts[text];
            const percentage = count / totalEntries * 100;
            const textStatHtml = `${text}: <span class="stat-value">${count}</span> (<span class="stat-value">${percentage.toFixed(1)}%</span>)`;
            statsSummaryContainer.createEl("p", { cls: "inline-stats-paragraph text-stat-detail" }).innerHTML = textStatHtml;
          });
        }
      }
      const visualizationContainer = habitStatsSection.createEl("div", { cls: "habit-visualization-container" });
      const habitStatsType = habit.statsType || (habit.type === "number" ? "bar" : "heatmap");
      const isHeatmap = habitStatsType === "heatmap";
      const isChart = !isHeatmap && habit.type === "number";
      if (isHeatmap) {
        if (this.currentStatsPeriod !== "year") {
          const noVizMessage = visualizationContainer.createEl("p", { cls: "no-visualization-message" });
          noVizMessage.setText(`Heatmap visualization for ${habit.type} habits is only available in Year view.`);
        } else {
          const yearlyHeatmapContainer = visualizationContainer.createEl("div", { cls: "habit-stats-yearly-heatmap-container" });
          const startYear = this.currentStatsDate.clone().startOf("year");
          for (let i = 0; i < 12; i++) {
            const monthStartDate = startYear.clone().add(i, "months");
            const monthlyHeatmapContainer = yearlyHeatmapContainer.createEl("div", { cls: "habit-stats-monthly-heatmap" });
            monthlyHeatmapContainer.createEl("div", { text: monthStartDate.format("MMM"), cls: "monthly-heatmap-label" });
            const dayOfWeekLabelsShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
            const orderedDaysOfWeek = [];
            const startDayIndex = this.plugin.settings.weekStartsOn;
            for (let d = 0; d < 7; d++) {
              orderedDaysOfWeek.push(dayOfWeekLabelsShort[(startDayIndex + d) % 7]);
            }
            const dayOfWeekHeaderRow = monthlyHeatmapContainer.createEl("div", { cls: "monthly-heatmap-dayofweek-row" });
            orderedDaysOfWeek.forEach((dayLabel) => {
              dayOfWeekHeaderRow.createEl("div", { text: dayLabel.substring(0, 1), cls: "monthly-heatmap-dayofweek-label" });
            });
            const monthGrid = monthlyHeatmapContainer.createEl("div", { cls: "heatmap-grid-month" });
            monthGrid.style.gridTemplateColumns = `repeat(7, 1fr)`;
            const firstDayOfMonth = monthStartDate.clone().startOf("month");
            const dayOfWeekOfFirstDay = firstDayOfMonth.day();
            const emptyCellsNeeded = (dayOfWeekOfFirstDay - this.plugin.settings.weekStartsOn + 7) % 7;
            for (let j = 0; j < emptyCellsNeeded; j++) {
              monthGrid.createEl("div", { cls: "heatmap-cell empty" });
            }
            const endOfMonth = monthStartDate.clone().date(monthStartDate.daysInMonth()).startOf("day");
            let currentDayInMonth = monthStartDate.clone().startOf("day");
            while (currentDayInMonth.isSameOrBefore(endOfMonth, "day")) {
              const date = currentDayInMonth.format(dateFormat);
              const cell = monthGrid.createEl("div", { cls: "heatmap-cell" });
              if (habit.type === "text") {
                const rawStatus2 = (_c = completionData[date]) == null ? void 0 : _c[habit.name];
                if (typeof rawStatus2 === "string" && rawStatus2.length > 0) {
                  const isLikelyEmoji = rawStatus2.length > 0 && rawStatus2.length <= 4;
                  if (isLikelyEmoji) {
                    cell.createSpan({ text: rawStatus2, cls: "heatmap-text-value is-emoji" });
                    cell.addClass("is-emoji");
                  } else {
                    cell.createSpan({ text: rawStatus2, cls: "heatmap-text-value" });
                  }
                }
              }
              const rawStatus = (_e = (_d = this.plugin.settings.completionData[date]) == null ? void 0 : _d[habit.name]) != null ? _e : null;
              let statusForAppearance = rawStatus;
              if (habit.type === "number" && Array.isArray(rawStatus)) {
                statusForAppearance = rawStatus.reduce((sum, current) => sum + current, 0);
              }
              if (moment().isSame(date, "day")) {
                cell.addClass("is-today");
              }
              let weeklyPercentageForCell;
              if (habit.type === "boolean" && habit.frequency === "week") {
                const weekStartDateForCell = currentDayInMonth.clone().startOf("week");
                const weekStartDateString = weekStartDateForCell.format(dateFormat);
                weeklyPercentageForCell = weeklyBooleanPercentages[weekStartDateString];
              }
              this.updateCellAppearance(cell, habit, statusForAppearance, weeklyPercentageForCell);
              let tooltipText = `${habit.name} - ${date}`;
              if (rawStatus !== null && rawStatus !== void 0) {
                if (habit.type === "boolean") {
                  if (habit.frequency === "day") {
                    let dailyStatusDisplay;
                    if (typeof rawStatus === "boolean") {
                      dailyStatusDisplay = rawStatus === true ? "Completed" : "Not Completed";
                    } else if (typeof rawStatus === "number" && habit.completionGoal !== void 0 && habit.completionGoal > 0) {
                      dailyStatusDisplay = rawStatus >= habit.completionGoal ? "Completed" : "Not Completed";
                    } else {
                      dailyStatusDisplay = "Not Completed";
                    }
                    tooltipText += `: ${dailyStatusDisplay}`;
                    if (habit.completionGoal !== void 0 && habit.completionGoal > 1 && typeof rawStatus === "number") {
                      tooltipText += ` (${rawStatus}/${habit.completionGoal})`;
                    }
                  } else {
                    tooltipText += `: ${rawStatus === true ? "Completed for today" : "Not completed for today"}`;
                    const weekStartDateForCell = currentDayInMonth.clone().startOf("week");
                    const weekStartDateString = weekStartDateForCell.format(dateFormat);
                    const weeklyPercentage = weeklyBooleanPercentages[weekStartDateString] !== void 0 ? weeklyBooleanPercentages[weekStartDateString] : 0;
                    const completionGoal = habit.completionGoal !== void 0 && habit.completionGoal !== null && habit.completionGoal > 0 ? habit.completionGoal : 1;
                    let weeklyCompletionsForTooltip = 0;
                    const weekEndDateForCell = weekStartDateForCell.clone().endOf("week");
                    let dayIteratorForTooltip = weekStartDateForCell.clone();
                    while (dayIteratorForTooltip.isSameOrBefore(weekEndDateForCell, "day")) {
                      const dayStr = dayIteratorForTooltip.format(dateFormat);
                      const statusForDay = (_f = completionData[dayStr]) == null ? void 0 : _f[habit.name];
                      if (statusForDay === true) {
                        weeklyCompletionsForTooltip++;
                      }
                      dayIteratorForTooltip.add(1, "day");
                    }
                    tooltipText += ` (Week Progress: ${weeklyCompletionsForTooltip}/${completionGoal}, ${weeklyPercentage.toFixed(1)}%)`;
                  }
                } else if (habit.type === "number") {
                  const dailySum = Array.isArray(rawStatus) ? rawStatus.reduce((sum, current) => sum + current, 0) : typeof rawStatus === "number" ? rawStatus : 0;
                  tooltipText += `: ${dailySum.toFixed(2)}${habit.unit || ""}`;
                  if (habit.goal !== void 0 && habit.goal !== null && habit.goal > 0) {
                    tooltipText += ` (Goal: ${habit.goal}${habit.unit || ""})`;
                  }
                } else if (habit.type === "text") {
                  tooltipText += `: "${rawStatus}"`;
                }
              } else {
                tooltipText += `: No entry`;
              }
              cell.setAttribute("aria-label", tooltipText);
              cell.addEventListener("click", async () => {
                var _a2;
                const clickedHabitName = cell.getAttribute("data-habit-name");
                const clickedDate = cell.getAttribute("data-date");
                const clickedHabitType = cell.getAttribute("data-habit-type");
                const clickedHabit = this.plugin.settings.habits.find((h) => h.name === clickedHabitName);
                if (!clickedHabitName || !clickedDate || !clickedHabitType || !clickedHabit) {
                  console.error("Clicked cell missing data attributes or habit not found!");
                  return;
                }
                if (!this.plugin.settings.completionData[clickedDate]) {
                  this.plugin.settings.completionData[clickedDate] = {};
                }
                if (clickedHabitType === "boolean") {
                  const completionGoal = clickedHabit.completionGoal !== void 0 && clickedHabit.completionGoal !== null && clickedHabit.completionGoal > 0 ? clickedHabit.completionGoal : 1;
                  if (clickedHabit.frequency === "day" && completionGoal > 1) {
                    let currentCount = (_a2 = this.plugin.settings.completionData[clickedDate][clickedHabitName]) != null ? _a2 : 0;
                    let newCount = currentCount + 1;
                    if (newCount > completionGoal)
                      newCount = 0;
                    this.plugin.settings.completionData[clickedDate][clickedHabitName] = newCount > 0 ? newCount : null;
                    await this.plugin.saveSettings();
                    new import_obsidian.Notice(`${clickedHabitName} on ${clickedDate}: Count: ${newCount > 0 ? newCount : "0"}/${completionGoal}.`, 2e3);
                  } else {
                    const currentStatus = this.plugin.settings.completionData[clickedDate][clickedHabitName];
                    const newStatus = currentStatus === true ? null : true;
                    this.plugin.settings.completionData[clickedDate][clickedHabitName] = newStatus;
                    await this.plugin.saveSettings();
                    new import_obsidian.Notice(`${clickedHabitName} on ${clickedDate} ${newStatus === true ? "marked as Completed." : "entry cleared."}`, 2e3);
                  }
                  if (this.statsContentContainer) {
                    this.renderStatsContent(this.statsContentContainer);
                  }
                } else if (clickedHabitType === "number") {
                  new NumberInputModal(
                    this.app,
                    this.plugin,
                    clickedDate,
                    clickedHabitName,
                    this.plugin.settings.completionData[clickedDate][clickedHabitName],
                    () => {
                      if (this.statsContentContainer) {
                        this.renderStatsContent(this.statsContentContainer);
                      }
                    }
                  ).open();
                } else if (clickedHabitType === "text") {
                  new TextInputModal(
                    this.app,
                    this.plugin,
                    clickedDate,
                    clickedHabitName,
                    this.plugin.settings.completionData[clickedDate][clickedHabitName],
                    () => {
                      if (this.statsContentContainer) {
                        this.renderStatsContent(this.statsContentContainer);
                      }
                    }
                  ).open();
                }
              });
              currentDayInMonth.add(1, "day");
            }
            const cellsAlreadyAdded = monthGrid.children.length;
            const remainingCells = (7 - cellsAlreadyAdded % 7) % 7;
            for (let k = 0; k < remainingCells; k++) {
              monthGrid.createEl("div", { cls: "heatmap-cell empty" });
            }
          }
        }
      } else if (isChart) {
        if (habit.type !== "number") {
          console.warn(`[Habit Tracker] Chart rendering attempt for non-number habit "${habit.name}" (Type: ${habit.type}, StatsType: ${habitStatsType}). This should not happen.`);
          const noVizMessage = visualizationContainer.createEl("p", { cls: "no-visualization-message" });
          noVizMessage.setText(`Charts are only available for Number habits.`);
          return;
        }
        const chartContainer = visualizationContainer.createEl("div", { cls: "habit-chart-container" });
        const canvas = chartContainer.createEl("canvas");
        let chartLabels = [];
        let chartDataPeriodTotal = [];
        let chartDataCumulativeAverage = [];
        const dateFormat2 = "YYYY-MM-DD";
        if (this.currentStatsPeriod === "month") {
          const datesInCurrentMonth = allDatesInPeriod.filter((date) => moment(date, dateFormat2).isSame(this.currentStatsDate, "month"));
          let cumulativeTotal = 0;
          let cumulativeCount = 0;
          datesInCurrentMonth.forEach((date) => {
            var _a2, _b2;
            const rawStatus = (_b2 = (_a2 = completionData[date]) == null ? void 0 : _a2[habit.name]) != null ? _b2 : null;
            let dailyValue = 0;
            if (Array.isArray(rawStatus)) {
              dailyValue = rawStatus.reduce((sum, current) => sum + current, 0);
            } else if (typeof rawStatus === "number") {
              console.warn(`[Habit Tracker] Encountered single number data for "${habit.name}" on ${date} during stats aggregation.`);
              dailyValue = rawStatus;
            }
            chartDataPeriodTotal.push(dailyValue);
            cumulativeTotal += dailyValue;
            if (dailyValue > 0)
              cumulativeCount += 1;
            chartDataCumulativeAverage.push(cumulativeCount > 0 ? cumulativeTotal / cumulativeCount : 0);
          });
          chartLabels = datesInCurrentMonth.map((date) => moment(date, dateFormat2).format("MM-DD"));
        } else {
          const yearStartDate = this.currentStatsDate.clone().startOf("year");
          const yearEndDate = this.currentStatsDate.clone().endOf("year");
          let weekIterator = yearStartDate.clone().startOf("week");
          let cumulativeWeeklyTotalSum = 0;
          let cumulativeWeeksWithEntriesCount = 0;
          const firstWeekOfYearMoment = yearStartDate.clone().startOf("year");
          while (weekIterator.isSameOrBefore(yearEndDate, "day")) {
            let weeklyTotal = 0;
            let weeklyEntryCount = 0;
            const weekEndDate = weekIterator.clone().endOf("week");
            let dayIterator = weekIterator.clone();
            while (dayIterator.isSameOrBefore(weekEndDate, "day") && dayIterator.isSameOrBefore(yearEndDate, "day")) {
              const dateString = dayIterator.format(dateFormat2);
              const rawStatus = (_h = (_g = completionData[dateString]) == null ? void 0 : _g[habit.name]) != null ? _h : null;
              if (habit.type === "number") {
                if (Array.isArray(rawStatus)) {
                  const dailySum = rawStatus.reduce((sum, current) => sum + current, 0);
                  weeklyTotal += dailySum;
                  if (dailySum > 0)
                    weeklyEntryCount += 1;
                } else if (typeof rawStatus === "number") {
                  console.warn(`[Habit Tracker] Encountered single number data for "${habit.name}" on ${dateString} during stats aggregation.`);
                  weeklyTotal += rawStatus;
                  if (rawStatus > 0)
                    weeklyEntryCount += 1;
                }
              }
              dayIterator.add(1, "day");
            }
            if (weekIterator.isSameOrBefore(yearEndDate, "day") && weekEndDate.isSameOrAfter(yearStartDate, "day")) {
              const daysSinceYearStart = weekIterator.diff(yearStartDate.clone().startOf("day"), "days");
              const sequentialWeekIndex = Math.floor(daysSinceYearStart / 7);
              chartLabels.push(`W${sequentialWeekIndex + 1}`);
              chartDataPeriodTotal.push(weeklyTotal);
              cumulativeWeeklyTotalSum += weeklyTotal;
              if (weeklyEntryCount > 0) {
                cumulativeWeeksWithEntriesCount += 1;
              }
              chartDataCumulativeAverage.push(cumulativeWeeksWithEntriesCount > 0 ? cumulativeWeeklyTotalSum / cumulativeWeeksWithEntriesCount : 0);
            }
            weekIterator.add(1, "week");
          }
        }
        if (canvas) {
          const ctx = canvas.getContext("2d");
          if (ctx) {
            let chartConfig;
            const baseDataset = {
              borderColor: "rgba(100, 120, 255, 1)",
              borderWidth: 1,
              fill: false
            };
            const chartStatsType = habitStatsType;
            if (chartStatsType === "combo") {
              chartConfig = {
                type: "bar",
                // The primary type for combo is bar
                data: {
                  labels: chartLabels,
                  datasets: [
                    {
                      ...baseDataset,
                      type: "bar",
                      label: "Value" + (habit.unit ? ` (${habit.unit})` : ""),
                      data: chartDataPeriodTotal,
                      backgroundColor: "rgba(100, 120, 255, 0.6)",
                      order: 2
                    },
                    {
                      ...baseDataset,
                      type: "line",
                      label: "Average",
                      data: chartDataCumulativeAverage,
                      borderColor: "rgba(255, 159, 64, 1)",
                      backgroundColor: "rgba(255, 159, 64, 0.2)",
                      tension: 0.1,
                      fill: false,
                      pointRadius: 3,
                      // Add point radius
                      order: 1
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    y: {
                      beginAtZero: true
                    }
                  },
                  plugins: {
                    legend: {
                      display: true
                    },
                    tooltip: {
                      // Add tooltip for hover
                      callbacks: {
                        label: function(context) {
                          let label = context.dataset.label || "";
                          if (label) {
                            label += ": ";
                          }
                          if (context.parsed.y !== null) {
                            label += context.parsed.y.toFixed(2) + (context.dataset.label === "Value" && habit.unit ? habit.unit : "");
                          }
                          return label;
                        }
                      }
                    }
                  },
                  layout: {
                    // Add layout padding if needed
                    padding: {
                      top: 10,
                      bottom: 10
                    }
                  }
                }
              };
            } else {
              const chartType = chartStatsType === "line" ? "line" : "bar";
              const dataToUseForSingle = chartDataPeriodTotal;
              chartConfig = {
                type: chartType,
                data: {
                  labels: chartLabels,
                  datasets: [{
                    ...baseDataset,
                    label: habit.name + (habit.unit ? ` (${habit.unit})` : ""),
                    data: dataToUseForSingle,
                    backgroundColor: chartType === "bar" ? "rgba(100, 120, 255, 0.6)" : "rgba(100, 120, 255, 0.2)",
                    tension: chartType === "line" ? 0.1 : void 0,
                    fill: chartType === "line" ? true : false,
                    pointRadius: chartType === "line" ? 3 : void 0
                    // Add point radius for line
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    y: {
                      beginAtZero: true
                    }
                  },
                  plugins: {
                    legend: {
                      display: false
                    },
                    tooltip: {
                      // Add tooltip for hover
                      callbacks: {
                        label: function(context) {
                          let label = context.dataset.label || "";
                          if (label) {
                            label += ": ";
                          }
                          if (context.parsed.y !== null) {
                            label += context.parsed.y.toFixed(2) + (habit.unit || "");
                          }
                          return label;
                        }
                      }
                    }
                  },
                  layout: {
                    // Add layout padding if needed
                    padding: {
                      top: 10,
                      bottom: 10
                    }
                  }
                }
              };
            }
            const chart = new Chart(ctx, chartConfig);
            this.chartInstances.set(habit.name, chart);
          } else {
            console.error(`[Habit Tracker] Failed to get 2D context for canvas for habit: "${habit.name}"`);
            visualizationContainer.createEl("p", { text: `Could not render chart for habit "${habit.name}". Canvas context unavailable.` });
          }
        } else {
          console.error(`[Habit Tracker] Canvas element not found for habit: "${habit.name}"`);
          visualizationContainer.createEl("p", { text: `Could not render chart for habit "${habit.name}". Canvas element not found.` });
        }
      } else {
        const noVizMessage = visualizationContainer.createEl("p", { cls: "no-visualization-message" });
        const habitStatsType2 = habit.statsType || (habit.type === "number" ? "bar" : "heatmap");
        if (this.currentStatsPeriod === "month") {
          if (habit.type === "number" && habitStatsType2 === "heatmap") {
            noVizMessage.setText(`Heatmap visualization is only available in Year view for Number habits.`);
          } else if (habit.type !== "number") {
            noVizMessage.setText(`Only chart visualizations for Number habits are available in Month view.`);
          }
        } else if (this.currentStatsPeriod === "year" && habit.type === "number" && habitStatsType2 !== "heatmap") {
          noVizMessage.setText(`Chart visualization is configured but failed to render.`);
        } else {
          noVizMessage.setText(`No visualization configured for this habit in the current view.`);
        }
      }
      if (habitsToDisplay.indexOf(habit) < habitsToDisplay.length - 1) {
        habitStatsSection.createEl("hr");
      }
    });
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.chartInstances.forEach((chart) => chart.destroy());
    this.chartInstances.clear();
    this.monthlyOverviewGridContainer = null;
    this.monthlyOverviewDateDisplayEl = null;
    this.statsContentContainer = null;
    this.statsDateDisplayEl = null;
  }
};
var TextInputModal = class extends import_obsidian.Modal {
  constructor(app, plugin, date, habitName, initialValue, onSaveCallback) {
    super(app);
    this.plugin = plugin;
    this.date = date;
    this.habitName = habitName;
    this.initialValue = initialValue;
    this.onSaveCallback = onSaveCallback;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    this.titleEl.setText(`${this.habitName} on ${this.date}`);
    new import_obsidian.Setting(contentEl).setName("Text Entry").setDesc("Enter text here...").addTextArea((textArea) => {
      this.textInput = textArea;
      textArea.setPlaceholder("Enter text...").setValue(this.initialValue || "").onChange((value) => {
      });
      textArea.inputEl.addClass("habit-text-input");
    });
    const buttonContainer = modalEl.createEl("div", { cls: "modal-button-container" });
    const saveButton = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    const clearButton = buttonContainer.createEl("button", { text: "Clear" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    saveButton.addEventListener("click", async () => {
      var _a;
      const newValue = this.textInput.getValue();
      if (!this.plugin.settings.completionData[this.date]) {
        this.plugin.settings.completionData[this.date] = {};
      }
      this.plugin.settings.completionData[this.date][this.habitName] = newValue || null;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Text for "${this.habitName}" on ${this.date} saved.`, 2e3);
      this.close();
      (_a = this.onSaveCallback) == null ? void 0 : _a.call(this);
    });
    clearButton.addEventListener("click", async () => {
      var _a;
      if (!this.plugin.settings.completionData[this.date]) {
        this.plugin.settings.completionData[this.date] = {};
      }
      this.plugin.settings.completionData[this.date][this.habitName] = null;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Entry for "${this.habitName}" on ${this.date} cleared.`, 2e3);
      this.close();
      (_a = this.onSaveCallback) == null ? void 0 : _a.call(this);
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NumberInputModal = class extends import_obsidian.Modal {
  constructor(app, plugin, date, habitName, initialValue, onSaveCallback) {
    super(app);
    this.plugin = plugin;
    this.date = date;
    this.habitName = habitName;
    this.initialValue = Array.isArray(initialValue) ? initialValue : initialValue === null ? null : [initialValue];
    this.onSaveCallback = onSaveCallback;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `${this.habitName} on ${this.date}` });
    const currentEntriesContainer = contentEl.createDiv({ cls: "current-number-entries" });
    this.renderEntries(currentEntriesContainer);
    new import_obsidian.Setting(contentEl).setName("Add").setDesc("Enter a number value to add to today's total.").addText((text) => {
      this.numberInput = text;
      text.setPlaceholder("Enter number...").setValue("").inputEl.type = "number";
    }).addButton((button) => button.setButtonText("Add").setCta().onClick(async () => {
      var _a;
      const inputValue = this.numberInput.getValue();
      const newValue = parseFloat(inputValue);
      if (inputValue.trim() === "") {
        new import_obsidian.Notice("Input cannot be empty.", 2e3);
        return;
      }
      if (isNaN(newValue)) {
        new import_obsidian.Notice("Invalid number input.", 2e3);
        return;
      }
      if (!this.plugin.settings.completionData[this.date]) {
        this.plugin.settings.completionData[this.date] = {};
      }
      let currentData = this.plugin.settings.completionData[this.date][this.habitName];
      if (!Array.isArray(currentData)) {
        currentData = [];
      }
      currentData.push(newValue);
      this.plugin.settings.completionData[this.date][this.habitName] = currentData;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Added ${newValue} to "${this.habitName}" on ${this.date}.`, 2e3);
      this.numberInput.setValue("");
      this.renderEntries(currentEntriesContainer);
      (_a = this.onSaveCallback) == null ? void 0 : _a.call(this);
    }));
    const buttonContainer = modalEl.createEl("div", { cls: "modal-button-container" });
    const clearButton = buttonContainer.createEl("button", { text: "Clear All" });
    const closeButton = buttonContainer.createEl("button", { text: "Close" });
    clearButton.addEventListener("click", async () => {
      var _a;
      if (!this.plugin.settings.completionData[this.date]) {
        this.plugin.settings.completionData[this.date] = {};
      }
      this.plugin.settings.completionData[this.date][this.habitName] = null;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`All entries for "${this.habitName}" on ${this.date} cleared.`, 2e3);
      this.close();
      (_a = this.onSaveCallback) == null ? void 0 : _a.call(this);
    });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  // Helper to render the list of entries and the total
  renderEntries(containerEl) {
    var _a;
    containerEl.empty();
    const currentData = (_a = this.plugin.settings.completionData[this.date]) == null ? void 0 : _a[this.habitName];
    const habit = this.plugin.settings.habits.find((h) => h.name === this.habitName);
    const unit = (habit == null ? void 0 : habit.unit) || "";
    if (Array.isArray(currentData) && currentData.length > 0) {
      containerEl.createEl("p", { text: "Current Entries:", cls: "modal-entries-list-label" });
      const entriesList = containerEl.createEl("ul", { cls: "modal-entries-list" });
      let total = 0;
      currentData.forEach((entry, index2) => {
        if (typeof entry === "number") {
          entriesList.createEl("li", { text: `${entry.toFixed(2)}${unit}` });
          total += entry;
        } else {
          console.warn(`[Habit Tracker] Unexpected non-number entry in array for "${this.habitName}" on ${this.date}:`, entry);
        }
      });
      containerEl.createEl("p", { text: `Total for today: ${total.toFixed(2)}${unit}`, cls: "modal-total-display" });
    } else {
      containerEl.createEl("p", { text: "No entries for today.", cls: "modal-no-entries" });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var HabitEditModal = class extends import_obsidian.Modal {
  constructor(app, plugin, habitIndex, settingsTab) {
    var _a, _b, _c, _d;
    super(app);
    // Number options
    this.unitSettingEl = null;
    this.goalSettingEl = null;
    this.statsTypeSettingEl = null;
    // Removed optional
    // Boolean options
    this.frequencySettingEl = null;
    // Removed optional
    this.completionGoalSettingEl = null;
    this.plugin = plugin;
    this.habit = JSON.parse(JSON.stringify(this.plugin.settings.habits[habitIndex]));
    this.habitIndex = habitIndex;
    if (this.habit.type === "number") {
      if (!this.habit.statsType || this.habit.statsType === "heatmap") {
        this.habit.statsType = "bar";
      }
      this.habit.unit = (_a = this.habit.unit) != null ? _a : "";
      this.habit.goal = (_b = this.habit.goal) != null ? _b : void 0;
    } else if (this.habit.type === "boolean") {
      this.habit.frequency = (_c = this.habit.frequency) != null ? _c : "day";
      this.habit.completionGoal = (_d = this.habit.completionGoal) != null ? _d : void 0;
      this.habit.statsType = "heatmap";
    }
    if (this.habit.type === "text") {
      this.habit.statsType = "heatmap";
    }
    if (this.habit.type !== "number") {
      delete this.habit.unit;
      delete this.habit.goal;
    }
    if (this.habit.type !== "boolean") {
      delete this.habit.frequency;
      delete this.habit.completionGoal;
    }
    this.settingsTab = settingsTab;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    this.titleEl.setText(`Edit Habit: "${this.habit.name}"`);
    new import_obsidian.Setting(contentEl).setName("Habit Name").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter habit name").setValue(this.habit.name).onChange((value) => {
        this.habit.name = value;
      });
    });
    const typeSetting = new import_obsidian.Setting(contentEl).setName("Habit Type").addDropdown((dropdown) => {
      this.typeDropdown = dropdown;
      dropdown.addOption("boolean", "Boolean").addOption("text", "Text").addOption("number", "Number").setValue(this.habit.type).onChange(async (value) => {
        var _a, _b, _c, _d;
        const newType = value;
        const oldType = this.habit.type;
        this.habit.type = newType;
        this.toggleNumberOptions(newType);
        this.toggleBooleanOptions(newType);
        this.toggleStatsTypeOption(newType);
        if (newType !== oldType) {
          console.log(`[Habit Tracker] Habit type changed from ${oldType} to ${newType} for "${this.habit.name}". Data will be cleared on Save.`);
          new import_obsidian.Notice(`Warning: Changing habit type will clear existing data for "${this.habit.name}". Click Save to confirm.`, 5e3);
        }
        if (newType !== "number") {
          delete this.habit.unit;
          delete this.habit.goal;
        } else {
          this.habit.unit = (_a = this.habit.unit) != null ? _a : "";
          this.habit.goal = (_b = this.habit.goal) != null ? _b : void 0;
        }
        if (newType !== "boolean") {
          delete this.habit.frequency;
          delete this.habit.completionGoal;
        } else {
          this.habit.frequency = (_c = this.habit.frequency) != null ? _c : "day";
          this.habit.completionGoal = (_d = this.habit.completionGoal) != null ? _d : void 0;
        }
        if (newType === "boolean" || newType === "text") {
          this.habit.statsType = "heatmap";
        } else if (newType === "number") {
          if (!this.habit.statsType || this.habit.statsType === "heatmap") {
            this.habit.statsType = "bar";
          }
        }
      });
    });
    const unitSetting = new import_obsidian.Setting(contentEl).setName("Unit").setDesc('Optional unit for number habit (e.e., "kg", "minutes")').addText((text) => {
      this.unitInput = text;
      text.setPlaceholder("Enter unit (optional)").setValue(this.habit.unit || "").onChange((value) => {
        this.habit.unit = value;
      });
    });
    this.unitSettingEl = unitSetting.settingEl;
    this.unitSettingEl.addClass("edit-number-option");
    const goalSetting = new import_obsidian.Setting(contentEl).setName("Goal (Number)").setDesc("Optional target value for number habit statistics").addText((text) => {
      this.goalInput = text;
      text.setPlaceholder("Enter goal number (optional)").setValue(this.habit.goal !== void 0 && this.habit.goal !== null ? String(this.habit.goal) : "").inputEl.type = "number";
      text.onChange((value) => {
        const goalValue = parseFloat(value);
        this.habit.goal = !isNaN(goalValue) ? goalValue : void 0;
      });
    });
    this.goalSettingEl = goalSetting.settingEl;
    this.goalSettingEl.addClass("edit-number-option");
    const statsTypeSetting = new import_obsidian.Setting(contentEl).setName("Statistics Visualization").setDesc("Choose how to visualize this habit in statistics");
    statsTypeSetting.addDropdown((dropdown) => {
      this.statsTypeDropdown = dropdown;
      dropdown.addOption("bar", "Bar Chart");
      dropdown.addOption("line", "Line Chart");
      dropdown.addOption("combo", "Combo (Bar & Line)");
      dropdown.addOption("heatmap", "Heatmap");
      if (this.habit.type === "number" && this.habit.statsType !== "heatmap" && this.habit.statsType) {
        dropdown.setValue(this.habit.statsType);
      } else {
        const defaultValue = this.habit.type === "number" ? "bar" : "heatmap";
        const valueToSet = this.habit.statsType || defaultValue;
        dropdown.setValue(valueToSet);
        if (this.habit.type === "number" && (this.habit.statsType === "heatmap" || !this.habit.statsType)) {
          this.habit.statsType = "bar";
        } else if (this.habit.type !== "number" && this.habit.statsType !== "heatmap") {
          this.habit.statsType = "heatmap";
        } else if (!this.habit.statsType) {
          this.habit.statsType = defaultValue;
        }
      }
      dropdown.onChange((value) => {
        this.habit.statsType = value;
      });
    });
    this.statsTypeSettingEl = statsTypeSetting.settingEl;
    this.statsTypeSettingEl.addClass("edit-stats-type-option");
    if (this.habit.type !== "number") {
      this.statsTypeSettingEl.style.display = "none";
    }
    const frequencySetting = new import_obsidian.Setting(contentEl).setName("Frequency").setDesc("How often do you track this habit?").addDropdown((dropdown) => {
      this.frequencyDropdown = dropdown;
      dropdown.addOption("day", "Daily");
      dropdown.addOption("week", "Weekly");
      dropdown.setValue(this.habit.frequency || "day");
      dropdown.onChange((value) => {
        const newFreq = value;
        this.habit.frequency = newFreq;
      });
    });
    this.frequencySettingEl = frequencySetting.settingEl;
    this.frequencySettingEl.addClass("edit-boolean-option");
    const completionGoalSetting = new import_obsidian.Setting(contentEl).setName("Completion Goal").setDesc("Target number of completions per day or per week.").addText((text) => {
      this.completionGoalInput = text;
      text.setPlaceholder("Enter goal number").setValue(this.habit.completionGoal !== void 0 && this.habit.completionGoal !== null ? String(this.habit.completionGoal) : "").inputEl.type = "number";
      text.onChange((value) => {
        const goalValue = parseInt(value, 10);
        this.habit.completionGoal = !isNaN(goalValue) && goalValue > 0 ? goalValue : void 0;
      });
    });
    this.completionGoalSettingEl = completionGoalSetting.settingEl;
    this.completionGoalSettingEl.addClass("edit-boolean-option");
    this.toggleNumberOptions(this.habit.type);
    this.toggleBooleanOptions(this.habit.type);
    const buttonContainer = modalEl.createEl("div", { cls: "modal-button-container" });
    const saveButton = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    saveButton.addEventListener("click", async () => {
      var _a, _b;
      const newName = this.nameInput.getValue().trim();
      const newType = this.habit.type;
      const originalHabitInSettings = this.plugin.settings.habits[this.habitIndex];
      const oldHabitName = originalHabitInSettings.name;
      const oldHabitType = originalHabitInSettings.type;
      if (!newName) {
        new import_obsidian.Notice("Habit name cannot be empty.", 2e3);
        return;
      }
      const duplicateExists = this.plugin.settings.habits.some(
        (h, i) => i !== this.habitIndex && h.name === newName
      );
      if (duplicateExists) {
        new import_obsidian.Notice(`Habit "${newName}" already exists.`, 2e3);
        return;
      }
      if (newType !== oldHabitType) {
        console.log(`[Habit Tracker] Saving: Habit type changed from ${oldHabitType} to ${newType} for "${oldHabitName}". Data will be cleared on Save.`);
        for (const date in this.plugin.settings.completionData) {
          if (((_a = this.plugin.settings.completionData[date]) == null ? void 0 : _a[oldHabitName]) !== void 0) {
            delete this.plugin.settings.completionData[date][oldHabitName];
          }
        }
        new import_obsidian.Notice(`Data for "${oldHabitName}" cleared due to habit type change on Save.`, 3e3);
      } else if (newName !== oldHabitName) {
        console.log(`[Habit Tracker] Saving: Habit renamed from "${oldHabitName}" to "${newName}". Migrating data.`);
        for (const date in this.plugin.settings.completionData) {
          if (((_b = this.plugin.settings.completionData[date]) == null ? void 0 : _b[oldHabitName]) !== void 0) {
            const oldData = this.plugin.settings.completionData[date][oldHabitName];
            this.plugin.settings.completionData[date][newName] = oldData;
            delete this.plugin.settings.completionData[date][oldHabitName];
          }
        }
        new import_obsidian.Notice(`Habit "${oldHabitName}" renamed to "${newName}". Data migrated.`, 3e3);
      } else {
        new import_obsidian.Notice(`Habit "${newName}" updated.`, 2e3);
      }
      this.plugin.settings.habits[this.habitIndex] = { ...this.habit };
      if (this.plugin.settings.habits[this.habitIndex].type !== "number") {
        delete this.plugin.settings.habits[this.habitIndex].unit;
        delete this.plugin.settings.habits[this.habitIndex].goal;
      }
      if (this.plugin.settings.habits[this.habitIndex].type !== "boolean") {
        delete this.plugin.settings.habits[this.habitIndex].frequency;
        delete this.plugin.settings.habits[this.habitIndex].completionGoal;
      }
      if (this.plugin.settings.habits[this.habitIndex].type === "boolean" || this.plugin.settings.habits[this.habitIndex].type === "text") {
        this.plugin.settings.habits[this.habitIndex].statsType = "heatmap";
      }
      await this.plugin.saveSettings();
      this.close();
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  // Modified: toggleNumberOptions now only handles Unit and Goal for number type
  toggleNumberOptions(type) {
    if (this.unitSettingEl)
      this.unitSettingEl.style.display = type === "number" ? "flex" : "none";
    if (this.goalSettingEl)
      this.goalSettingEl.style.display = type === "number" ? "flex" : "none";
  }
  // Modified: Method to toggle Boolean options (Frequency and Completion Goal)
  toggleBooleanOptions(type) {
    const isBoolean = type === "boolean";
    if (this.frequencySettingEl)
      this.frequencySettingEl.style.display = isBoolean ? "flex" : "none";
    if (this.completionGoalSettingEl)
      this.completionGoalSettingEl.style.display = isBoolean ? "flex" : "none";
  }
  // Modified toggleStatsTypeOption logic for edit modal
  // This function only handles the visibility of the stats type setting element.
  // The population and value setting of the dropdown happen when the setting is created in onOpen.
  toggleStatsTypeOption(type) {
    if (this.statsTypeSettingEl) {
      if (type === "number") {
        this.statsTypeSettingEl.style.display = "flex";
      } else {
        this.statsTypeSettingEl.style.display = "none";
      }
    }
  }
  onClose() {
    const { containerEl } = this;
    containerEl.empty();
    this.settingsTab.display();
    this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  // For boolean goal (use string for input)
  constructor(app, plugin) {
    super(app, plugin);
    // Removed optional
    this.newHabitStatsTypeSettingEl = null;
    // Removed optional // This goal is for boolean habits
    this.newHabitCompletionGoalSettingEl = null;
    // Initialize to null // Store element for visibility toggle
    // State variables for new habit inputs
    this.currentNewHabitName = "";
    this.currentNewHabitType = "boolean";
    this.currentNewHabitUnit = "";
    this.currentNewHabitGoal = "";
    // For number goal (use string for input)
    this.currentNewHabitStatsType = "heatmap";
    // Default for non-number, will be set for number
    this.currentNewHabitFrequency = "day";
    // Default for boolean
    this.currentNewHabitCompletionGoal = "";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Start of Week").setDesc("Choose the day your week starts on.").addDropdown((dropdown) => {
      dropdown.addOption("0", "Sunday");
      dropdown.addOption("1", "Monday");
      dropdown.setValue(String(this.plugin.settings.weekStartsOn));
      dropdown.onChange(async (value) => {
        this.plugin.settings.weekStartsOn = parseInt(value, 10);
        await this.plugin.saveSettings();
        this.display();
        this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
      });
    });
    containerEl.createEl("h2", { text: "Habits Configuration" });
    this.plugin.settings.habits.forEach((habit, index2) => {
      const habitSetting = new import_obsidian.Setting(containerEl).setName(`${habit.name} (${habit.type})`);
      let desc = "";
      if (habit.type === "number") {
        if (habit.unit)
          desc += `Unit: ${habit.unit}`;
        if (habit.goal !== void 0 && habit.goal !== null && !isNaN(habit.goal))
          desc += `${desc ? ", " : ""} Goal: ${habit.goal}${habit.unit || ""}`;
        desc += `${desc ? ", " : ""} Stats: ${habit.statsType || "heatmap"}`;
      } else if (habit.type === "text") {
        desc += `Stats: Heatmap`;
      } else if (habit.type === "boolean") {
        desc += `Frequency: ${habit.frequency || "Daily"}`;
        if (habit.completionGoal !== void 0 && habit.completionGoal !== null && !isNaN(habit.completionGoal)) {
          desc += `, Goal: ${habit.completionGoal}${habit.frequency === "week" ? "/week" : "/day"}`;
        }
        desc += `, Stats: Heatmap`;
      }
      if (desc)
        habitSetting.setDesc(desc);
      habitSetting.addButton((button) => button.setIcon("up-chevron-glyph").setTooltip("Move habit up").setDisabled(index2 === 0).onClick(async () => {
        const currentHabit = this.plugin.settings.habits[index2];
        this.plugin.settings.habits[index2] = this.plugin.settings.habits[index2 - 1];
        this.plugin.settings.habits[index2 - 1] = currentHabit;
        await this.plugin.saveSettings();
        this.display();
        this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
      }));
      habitSetting.addButton((button) => button.setIcon("down-chevron-glyph").setTooltip("Move habit down").setDisabled(index2 === this.plugin.settings.habits.length - 1).onClick(async () => {
        const currentHabit = this.plugin.settings.habits[index2];
        this.plugin.settings.habits[index2] = this.plugin.settings.habits[index2 + 1];
        this.plugin.settings.habits[index2 + 1] = currentHabit;
        await this.plugin.saveSettings();
        this.display();
        this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
      }));
      habitSetting.addButton((button) => button.setIcon("edit").setTooltip("Edit this habit").onClick(() => {
        const editModal = new HabitEditModal(this.app, this.plugin, index2, this);
        editModal.open();
      }));
      habitSetting.addButton((button) => button.setIcon("trash").setTooltip("Remove this habit").onClick(async () => {
        const removedHabitName = this.plugin.settings.habits[index2].name;
        new ConfirmationModal(this.app, `Are you sure you want to delete habit "${removedHabitName}" and all its data?`, async (confirmed) => {
          var _a;
          if (confirmed) {
            this.plugin.settings.habits.splice(index2, 1);
            for (const date in this.plugin.settings.completionData) {
              if (((_a = this.plugin.settings.completionData[date]) == null ? void 0 : _a[removedHabitName]) !== void 0) {
                delete this.plugin.settings.completionData[date][removedHabitName];
              }
            }
            await this.plugin.saveSettings();
            new import_obsidian.Notice(`Habit "${removedHabitName}" removed.`, 3e3);
            this.display();
            this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
          }
        }).open();
      }));
    });
    containerEl.createEl("h3", { text: "Add New Habit" });
    const newHabitInputsContainer = containerEl.createEl("div", { cls: "new-habit-inputs-container" });
    const newHabitSetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Habit Details").addText((text) => {
      this.newHabitNameInput = text;
      text.setPlaceholder("Enter habit name").setValue(this.currentNewHabitName).onChange((value) => {
        this.currentNewHabitName = value;
      });
    }).addDropdown((dropdown) => {
      this.newHabitTypeDropdown = dropdown;
      dropdown.addOption("boolean", "Boolean").addOption("text", "Text").addOption("number", "Number").setValue(this.currentNewHabitType).onChange((value) => {
        const newType = value;
        this.currentNewHabitType = newType;
        const container = newHabitInputsContainer;
        if (this.currentNewHabitType === "number") {
          container.addClass("show-number-options");
        } else {
          container.removeClass("show-number-options");
          this.currentNewHabitUnit = "";
          this.currentNewHabitGoal = "";
          if (this.newHabitUnitInput)
            this.newHabitUnitInput.setValue("");
          if (this.newHabitGoalInput)
            this.newHabitGoalInput.setValue("");
        }
        if (this.currentNewHabitType === "boolean") {
          container.addClass("show-boolean-options");
        } else {
          container.removeClass("show-boolean-options");
          this.currentNewHabitFrequency = "day";
          this.currentNewHabitCompletionGoal = "";
          if (this.newHabitFrequencyDropdown)
            this.newHabitFrequencyDropdown.setValue("day");
          if (this.newHabitCompletionGoalInput)
            this.newHabitCompletionGoalInput.setValue("");
        }
        if (this.currentNewHabitType === "text") {
          container.removeClass("show-number-options");
          container.removeClass("show-boolean-options");
        }
        this.toggleNewHabitStatsTypeOptionVisibility(container);
      });
    });
    const unitSetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Unit").setDesc('Optional unit for number habit (e.e., "kg", "minutes")').addText((text) => {
      this.newHabitUnitInput = text;
      text.setPlaceholder("Enter unit (optional)").setValue(this.currentNewHabitUnit).onChange((value) => {
        this.currentNewHabitUnit = value;
      });
    });
    unitSetting.settingEl.addClass("number-option-setting");
    const goalSetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Goal (Number)").setDesc("Optional target value for number habit statistics").addText((text) => {
      this.newHabitGoalInput = text;
      text.setPlaceholder("Enter goal number (optional)").setValue(this.currentNewHabitGoal).inputEl.type = "number";
      text.onChange((value) => {
        this.currentNewHabitGoal = value;
      });
    });
    goalSetting.settingEl.addClass("number-option-setting");
    const newHabitStatsTypeSetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Statistics Visualization").setDesc("Choose how to visualize this habit in statistics");
    newHabitStatsTypeSetting.addDropdown((dropdown) => {
      this.newHabitStatsTypeDropdown = dropdown;
      dropdown.addOption("heatmap", "Heatmap");
      dropdown.addOption("bar", "Bar Chart");
      dropdown.addOption("line", "Line Chart");
      dropdown.addOption("combo", "Combo (Bar & Line)");
      const defaultValue = this.currentNewHabitType === "number" ? "bar" : "heatmap";
      const valueToSet = this.currentNewHabitType === "number" && this.currentNewHabitStatsType !== "heatmap" ? this.currentNewHabitStatsType : defaultValue;
      dropdown.setValue(valueToSet);
      this.currentNewHabitStatsType = valueToSet;
      dropdown.onChange((value) => {
        this.currentNewHabitStatsType = value;
      });
    });
    this.newHabitStatsTypeSettingEl = newHabitStatsTypeSetting.settingEl;
    newHabitStatsTypeSetting.settingEl.addClass("stats-type-option-setting");
    if (this.currentNewHabitType !== "number") {
      this.newHabitStatsTypeSettingEl.style.display = "none";
    }
    const newHabitFrequencySetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Frequency").setDesc("How often do you track this habit?").addDropdown((dropdown) => {
      this.newHabitFrequencyDropdown = dropdown;
      dropdown.addOption("day", "Daily");
      dropdown.addOption("week", "Weekly");
      dropdown.setValue(this.currentNewHabitFrequency || "day");
      dropdown.onChange((value) => {
        const newFreq = value;
        this.currentNewHabitFrequency = newFreq;
      });
    });
    newHabitFrequencySetting.settingEl.addClass("boolean-option-setting");
    const newHabitCompletionGoalSetting = new import_obsidian.Setting(newHabitInputsContainer).setName("Completion Goal").setDesc("Target number of completions per day or per week.").addText((text) => {
      this.newHabitCompletionGoalInput = text;
      text.setPlaceholder("Enter goal number").setValue(this.currentNewHabitCompletionGoal).inputEl.type = "number";
      text.onChange((value) => {
        const goalValue = parseInt(value, 10);
        this.currentNewHabitCompletionGoal = value;
      });
    });
    this.newHabitCompletionGoalSettingEl = newHabitCompletionGoalSetting.settingEl;
    newHabitCompletionGoalSetting.settingEl.addClass("boolean-option-setting");
    const initialContainer = newHabitInputsContainer;
    if (this.currentNewHabitType === "number") {
      initialContainer.addClass("show-number-options");
    } else {
      initialContainer.removeClass("show-number-options");
    }
    if (this.currentNewHabitType === "boolean") {
      initialContainer.addClass("show-boolean-options");
    } else {
      initialContainer.removeClass("show-boolean-options");
    }
    if (this.currentNewHabitType === "text") {
      initialContainer.removeClass("show-number-options");
      initialContainer.removeClass("show-boolean-options");
    }
    this.toggleNewHabitStatsTypeOptionVisibility(initialContainer);
    new import_obsidian.Setting(containerEl).addButton((button) => button.setIcon("plus").setTooltip("Add habit").setCta().onClick(async () => {
      console.log("[Habit Tracker] Add habit button clicked.");
      const newHabitName = this.newHabitNameInput.getValue().trim();
      const newHabitType = this.newHabitTypeDropdown.getValue();
      console.log("[Habit Tracker] New habit details before processing:", { name: newHabitName, type: newHabitType, unit: this.currentNewHabitUnit, goal: this.currentNewHabitGoal, statsType: this.currentNewHabitStatsType, frequency: this.currentNewHabitFrequency, completionGoal: this.currentNewHabitCompletionGoal });
      if (!newHabitName) {
        new import_obsidian.Notice("Habit name cannot be empty.", 2e3);
        console.log("[Habit Tracker] Habit name is empty, showing notice.");
        return;
      }
      if (this.plugin.settings.habits.some((h) => h.name === newHabitName)) {
        new import_obsidian.Notice(`Habit "${newHabitName}" already exists.`, 2e3);
        console.log(`[Habit Tracker] Duplicate habit name "${newHabitName}", showing notice.`);
        return;
      }
      const newHabit = { name: newHabitName, type: newHabitType };
      if (newHabitType === "number") {
        newHabit.unit = this.currentNewHabitUnit || void 0;
        const goalValue = parseFloat(this.currentNewHabitGoal);
        newHabit.goal = !isNaN(goalValue) && this.currentNewHabitGoal !== "" ? goalValue : void 0;
        newHabit.statsType = this.currentNewHabitStatsType !== "heatmap" && this.currentNewHabitStatsType !== void 0 ? this.currentNewHabitStatsType : "bar";
      } else if (newHabitType === "boolean") {
        newHabit.frequency = this.currentNewHabitFrequency || "day";
        const completionGoalValue = parseInt(this.currentNewHabitCompletionGoal, 10);
        newHabit.completionGoal = !isNaN(completionGoalValue) && completionGoalValue > 0 && this.currentNewHabitCompletionGoal !== "" ? completionGoalValue : void 0;
        newHabit.statsType = "heatmap";
      } else if (newHabitType === "text") {
        newHabit.statsType = "heatmap";
      }
      console.log("[Habit Tracker] Adding new habit to settings:", newHabit);
      this.plugin.settings.habits.push(newHabit);
      console.log("[Habit Tracker] Habits after adding:", this.plugin.settings.habits);
      console.log("[Habit Tracker] Saving settings...");
      await this.plugin.saveSettings();
      console.log("[Habit Tracker] Settings saved.");
      new import_obsidian.Notice(`Habit "${newHabitName}" added.`, 3e3);
      console.log(`[Habit Tracker] Showing success notice for "${newHabitName}".`);
      this.newHabitNameInput.setValue("");
      this.currentNewHabitName = "";
      this.newHabitTypeDropdown.setValue("boolean");
      this.currentNewHabitType = "boolean";
      this.currentNewHabitUnit = "";
      if (this.newHabitUnitInput)
        this.newHabitUnitInput.setValue("");
      this.currentNewHabitGoal = "";
      if (this.newHabitGoalInput)
        this.newHabitGoalInput.setValue("");
      this.currentNewHabitFrequency = "day";
      if (this.newHabitFrequencyDropdown)
        this.newHabitFrequencyDropdown.setValue("day");
      this.currentNewHabitCompletionGoal = "";
      if (this.newHabitCompletionGoalInput)
        this.newHabitCompletionGoalInput.setValue("");
      this.currentNewHabitStatsType = "heatmap";
      if (this.newHabitStatsTypeDropdown) {
        this.newHabitStatsTypeDropdown.setValue("heatmap");
      }
      newHabitInputsContainer.removeClass("show-number-options");
      newHabitInputsContainer.addClass("show-boolean-options");
      this.toggleNewHabitStatsTypeOptionVisibility(newHabitInputsContainer);
      this.display();
      console.log("[Habit Tracker] Settings tab re-rendered.");
      this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
      console.log("[Habit Tracker] Main view activated.");
    }));
  }
  // Helper function to toggle the visibility of the new habit stats type dropdown
  // and update the currentNewHabitStatsType state based on the type
  toggleNewHabitStatsTypeOptionVisibility(containerEl) {
    const statsTypeSettingEl = containerEl.querySelector(".stats-type-option-setting");
    if (statsTypeSettingEl && this.newHabitStatsTypeDropdown) {
      if (this.currentNewHabitType === "number") {
        statsTypeSettingEl.style.display = "flex";
        if (this.currentNewHabitStatsType === "heatmap" || !this.currentNewHabitStatsType) {
          this.currentNewHabitStatsType = "bar";
          this.newHabitStatsTypeDropdown.setValue("bar");
        } else {
          this.newHabitStatsTypeDropdown.setValue(this.currentNewHabitStatsType);
        }
      } else {
        statsTypeSettingEl.style.display = "none";
        this.currentNewHabitStatsType = "heatmap";
        this.newHabitStatsTypeDropdown.setValue("heatmap");
      }
    } else if (statsTypeSettingEl) {
      statsTypeSettingEl.style.display = this.currentNewHabitType === "number" ? "flex" : "none";
    }
  }
  onClose() {
    const { containerEl } = this;
    containerEl.empty();
    this.plugin.activateView(HABIT_TRACKER_VIEW_TYPE);
  }
  // Helper function to swap elements in an array - Not used in provided code for reordering, but can be useful
  // swapArrayElements(arr: any[], index1: number, index2: number) {
  //  if (index1 < 0 || index1 >= arr.length || index2 < 0 || index2 >= arr.length) {
  //      return false; // Invalid indices
  //  }
  //  const temp = arr[index1];
  //  arr[index1] = arr[index2];
  //  arr[index2] = temp;
  //  return true;
  // }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, message, callback2) {
    super(app);
    this.message = message;
    this.callback = callback2;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = modalEl.createEl("div", { cls: "modal-button-container" });
    const confirmButton = buttonContainer.createEl("button", { text: "Yes", cls: "mod-warning" });
    const cancelButton = buttonContainer.createEl("button", { text: "No" });
    confirmButton.addEventListener("click", () => {
      this.callback(true);
      this.close();
    });
    cancelButton.addEventListener("click", () => {
      this.callback(false);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.dataset.js:
  (*!
   * Chart.js v4.4.9
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.9
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5leHRyYXMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRsLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnRpY2tzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNhbnZhcy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbmZpZy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5ydGwudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kYXRhc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbi5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5iYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuZG91Z2hudXQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmxpbmUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucGllLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hZGFwdGVycy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2ljLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50eXBlZFJlZ2lzdHJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnBsdWdpbnMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29uZmlnLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmFyYy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmJhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmNvbG9ycy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnNlZ21lbnQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmhlbHBlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LnN0YWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL3NpbXBsZUFyYy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5kcmF3aW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udGl0bGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5zdWJ0aXRsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUuY2F0ZWdvcnkuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubG9nYXJpdGhtaWMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUucmFkaWFsTGluZWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZXNlcmllcy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIERyb3Bkb3duQ29tcG9uZW50LCBUZXh0QXJlYUNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG4vLyBBc3N1bWluZyBNb21lbnQuanMgaXMgYXZhaWxhYmxlIGdsb2JhbGx5IGluIHRoZSBPYnNpZGlhbiBlbnZpcm9ubWVudFxuZGVjbGFyZSBjb25zdCBtb21lbnQ6IGFueTtcblxuLy8gSW1wb3J0IENoYXJ0LmpzXG5pbXBvcnQgeyBDaGFydCwgcmVnaXN0ZXJhYmxlcyB9IGZyb20gJ2NoYXJ0LmpzJztcbi8vIFJlZ2lzdGVyIENoYXJ0LmpzIGNvbXBvbmVudHMgKGJhcnMsIGxpbmVzLCBheGVzLCBldGMuKVxuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbi8vIERlZmluZSB0aGUgdmlldyB0eXBlIGNvbnN0YW50IGF0IHRoZSB0b3BcbmNvbnN0IEhBQklUX1RSQUNLRVJfVklFV19UWVBFID0gJ2hhYml0LXRyYWNrZXItdmlldyc7XG5cbi8vIERlZmluZSBpbnRlcmZhY2UgZm9yIGEgc2luZ2xlIGhhYml0XG5pbnRlcmZhY2UgSGFiaXQge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiAnYm9vbGVhbicgfCAndGV4dCcgfCAnbnVtYmVyJzsgLy8gRGVmaW5lIGhhYml0IHR5cGVzXG4gICAgLy8gUHJvcGVydGllcyBmb3IgJ251bWJlcicgdHlwZVxuICAgIHVuaXQ/OiBzdHJpbmc7IC8vIE9wdGlvbmFsIHVuaXQgZm9yIG51bWJlciB0eXBlc1xuICAgIGdvYWw/OiBudW1iZXI7IC8vIE9wdGlvbmFsIGdvYWwgZm9yIG51bWJlciB0eXBlcyAoZm9yIHRvdGFsL2F2ZXJhZ2UgY2FsY3VsYXRpb24gYW5kIHZpc3VhbGl6YXRpb24pXG4gICAgc3RhdHNUeXBlPzogJ2hlYXRtYXAnIHwgJ2JhcicgfCAnbGluZScgfCAnY29tYm8nOyAvLyAnaGVhdG1hcCcgZm9yIGJvb2xlYW4vdGV4dC9udW1iZXIsICdiYXInLydsaW5lJy8nY29tYm8nIGZvciBudW1iZXJcbiAgICAvLyBQcm9wZXJ0aWVzIGZvciAnYm9vbGVhbicgdHlwZVxuICAgIGZyZXF1ZW5jeT86ICdkYXknIHwgJ3dlZWsnOyAvLyBPcHRpb25hbCBmcmVxdWVuY3kgZm9yIGJvb2xlYW4gaGFiaXRzIChkZWZhdWx0OiBkYXkpXG4gICAgY29tcGxldGlvbkdvYWw/OiBudW1iZXI7IC8vIE9wdGlvbmFsIGdvYWwgZm9yIGJvb2xlYW4gaGFiaXRzIChwZXIgZGF5IG9yIHBlciB3ZWVrLCBiYXNlZCBvbiBmcmVxdWVuY3kpXG59XG5cbi8vIERlZmluZSBpbnRlcmZhY2UgZm9yIHNldHRpbmdzXG5pbnRlcmZhY2UgVHJhY2tlclBsdWdpblNldHRpbmdzIHtcbiAgICBteVNldHRpbmc6IHN0cmluZzsgLy8gS2VlcCBzYW1wbGUgc2V0dGluZyBvciByZW1vdmUgaWYgbm90IG5lZWRlZFxuICAgIGhhYml0czogSGFiaXRbXTsgLy8gXHU0RTYwXHU2MEVGXHU1MjE3XHU4ODY4XHU3M0IwXHU1NzI4XHU2NjJGIEhhYml0IG9iamVjdHNcbiAgICBjb21wbGV0aW9uRGF0YToge1xuICAgICAgICBbZGF0ZTogc3RyaW5nXTogeyAvLyBcdTY1RTVcdTY3MUZcdTVCNTdcdTdCMjZcdTRFMzJcdTRGNUNcdTRFM0FcdTk1MkUgKFlZWVktTU0tREQpXG4gICAgICAgICAgICBbaGFiaXROYW1lOiBzdHJpbmddOiBib29sZWFuIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBudW1iZXIgfCBudWxsOyAvLyBcdTRFNjBcdTYwRUZcdTU0MERcdTc5RjBcdTRGNUNcdTRFM0FcdTk1MkVcdUZGMENcdTcyQjZcdTYwMDFcdTRGNUNcdTRFM0FcdTUwM0NcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHdlZWtTdGFydHNPbjogbnVtYmVyOyAvLyAwIGZvciBTdW5kYXksIDEgZm9yIE1vbmRheVxufVxuXG4vLyBEZWZpbmUgdGhlIGRlZmF1bHQgc2V0dGluZ3NcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFRyYWNrZXJQbHVnaW5TZXR0aW5ncyA9IHtcbiAgICBteVNldHRpbmc6ICdkZWZhdWx0JyxcbiAgICBoYWJpdHM6IFtdLCAvLyBJbml0aWFsaXplIHdpdGggYW4gZW1wdHkgYXJyYXkgb2YgaGFiaXRzXG4gICAgY29tcGxldGlvbkRhdGE6IHt9LCAvLyBJbml0aWFsaXplIHdpdGggYW4gZW1wdHkgb2JqZWN0IGZvciBjb21wbGV0aW9uIGRhdGFcbiAgICB3ZWVrU3RhcnRzT246IDAsIC8vIERlZmF1bHQgdG8gU3VuZGF5XG59XG5cblxuLy8gLS0tIE1haW4gUGx1Z2luIENsYXNzIC0tLVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2tlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IFRyYWNrZXJQbHVnaW5TZXR0aW5ncztcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgICAgICAvLyBBZGQgYSBjb21tYW5kIHRvIG9wZW4gdGhlIG1lcmdlZCB2aWV3XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ29wZW4taGFiaXQtdHJhY2tlci12aWV3JyxcbiAgICAgICAgICAgIG5hbWU6ICdPcGVuIEhhYml0IFRyYWNrZXIgVmlldycsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVWaWV3KEhBQklUX1RSQUNLRVJfVklFV19UWVBFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG1lcmdlZCB2aWV3XG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgICAgICAgSEFCSVRfVFJBQ0tFUl9WSUVXX1RZUEUsXG4gICAgICAgICAgICAobGVhZikgPT4gbmV3IEhhYml0VHJhY2tlclZpZXcobGVhZiwgdGhpcykgLy8gUGFzcyB0aGUgcGx1Z2luIGluc3RhbmNlIHRvIHRoZSB2aWV3XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWRkIGEgcmliYm9uIGljb24gdG8gb3BlbiB0aGUgdmlld1xuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oJ2NoZWNrLWNpcmNsZScsICdPcGVuIEhhYml0IFRyYWNrZXInLCAoKSA9PiB7IC8vIFVzZSB0aGUgc2FtZSBpY29uIGFzIHRoZSB2aWV3XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlVmlldyhIQUJJVF9UUkFDS0VSX1ZJRVdfVFlQRSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBsdWdpbiBob29rcyB1cCBhbnkgZ2xvYmFsIERPTSBldmVudHMgKGxpa2UgJ2NsaWNrJyBvbiB0aGUgYm9keSksXG4gICAgICAgIC8vIHJlbWVtYmVyIHRvIGNsZWFuIHRoZW0gdXAgd2hlbiB0aGUgcGx1Z2luIGlzIGRpc2FibGVkLlxuICAgICAgICB0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjbGljaycsIGV2dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdoZW4gcmVnaXN0ZXJpbmcgaW50ZXJ2YWxzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB0aGVtIHVwLlxuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwod2luZG93LnNldEludGVydmFsKCgpID0+IGNvbnNvbGUubG9nKCdpbnRlcnZhbCcpLCA1ICogNjAgKiAxMDAwKSk7XG4gICAgfVxuXG4gICAgb3VubG9hZCgpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgYW55IHJlc291cmNlcyB3aGVuIHRoZSBwbHVnaW4gaXMgdW5sb2FkZWRcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShIQUJJVF9UUkFDS0VSX1ZJRVdfVFlQRSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICAgICAgLy8gLS0tIERhdGEgTWlncmF0aW9uIExvZ2ljIChpZiBuZWVkZWQpIC0tLVxuICAgICAgICAvLyBBZGQgYW55IG5lY2Vzc2FyeSBkYXRhIG1pZ3JhdGlvbiBsb2dpYyBoZXJlIGlmIHlvdXIgc2V0dGluZ3Mgc3RydWN0dXJlIGNoYW5nZXNcbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIG1pZ3JhdGluZyBvbGQgYm9vbGVhbiBjb21wbGV0aW9uIGRhdGEgKHRydWUvZmFsc2UpIHRvICh0cnVlL251bGwpXG4gICAgICAgIC8vIG9yIG1pZ3JhdGluZyBudW1iZXIgZGF0YSBmcm9tIHNpbmdsZSBudW1iZXIgdG8gYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgaGFwcGVuICphZnRlciogbG9hZGluZyBkYXRhIGJ1dCAqYmVmb3JlKiB1c2luZyBpdC5cbiAgICAgICAgdGhpcy5taWdyYXRlU2V0dGluZ3MoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTsgLy8gU2F2ZSBzZXR0aW5ncyBhZnRlciBtaWdyYXRpb25cbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyIG1ldGhvZCBmb3IgZGF0YSBtaWdyYXRpb25cbiAgICBtaWdyYXRlU2V0dGluZ3MoKSB7XG4gICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIENoZWNraW5nIGZvciBkYXRhIG1pZ3JhdGlvbi4uLlwiKTtcbiAgICAgICAgICAgbGV0IG1pZ3JhdGlvbk5lZWRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgIC8vIEV4YW1wbGUgTWlncmF0aW9uOiBDb252ZXJ0IG9sZCBib29sZWFuIGZhbHNlIHRvIG51bGxcbiAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBkYXRlc1xuICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGUgaW4gdGhpcy5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgY29uc3QgZGFpbHlEYXRhID0gdGhpcy5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtkYXRlXTtcbiAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgaGFiaXRzIGZvciB0aGUgZGF0ZVxuICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYWJpdE5hbWUgaW4gZGFpbHlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U3RhdHVzID0gZGFpbHlEYXRhW2hhYml0TmFtZV07XG4gICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgaGFiaXQgZGVmaW5pdGlvbiB0byBjaGVjayBpdHMgdHlwZVxuICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhYml0RGVmID0gdGhpcy5zZXR0aW5ncy5oYWJpdHMuZmluZChoID0+IGgubmFtZSA9PT0gaGFiaXROYW1lKTtcblxuICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdERlZiAmJiBoYWJpdERlZi50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBib29sZWFuIGhhYml0IGFuZCB0aGUgc3RhdHVzIGlzIGV4cGxpY2l0bHkgZmFsc2UsIGNoYW5nZSBpdCB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3U3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gTWlncmF0aW5nIGJvb2xlYW4gJ2ZhbHNlJyB0byAnbnVsbCcgZm9yIFwiJHtoYWJpdE5hbWV9XCIgb24gJHtkYXRlfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYWlseURhdGFbaGFiaXROYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlncmF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gaGFuZGxlIHBvdGVudGlhbCBvbGQgbnVtYmVyIGRhdGEgc3RvcmVkIGZvciBib29sZWFucyAoc2hvdWxkbid0IGhhcHBlbiB3aXRoIG5ldyBjb2RlLCBidXQgZm9yIHNhZmV0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3U3RhdHVzID09PSAnbnVtYmVyJyAmJiBoYWJpdERlZi5mcmVxdWVuY3kgPT09ICdkYXknICYmIChoYWJpdERlZi5jb21wbGV0aW9uR29hbCA9PT0gdW5kZWZpbmVkIHx8IGhhYml0RGVmLmNvbXBsZXRpb25Hb2FsIDw9IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbnVtYmVyIGRhdGEgZm9yIGJvb2xlYW4gaGFiaXQgXCIke2hhYml0TmFtZX1cIiBvbiAke2RhdGV9LiBTZXR0aW5nIHRvIG51bGwuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhaWx5RGF0YVtoYWJpdE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlncmF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0RGVmICYmIGhhYml0RGVmLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlIE1pZ3JhdGlvbjogQ29udmVydCBvbGQgc2luZ2xlIG51bWJlciBkYXRhIHRvIGFycmF5IG9mIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIGEgbnVtYmVyIGFuZCBub3QgYWxyZWFkeSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByYXdTdGF0dXMgPT09ICdudW1iZXInICYmICFBcnJheS5pc0FycmF5KHJhd1N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIE1pZ3JhdGluZyBudW1iZXIgZGF0YSBmcm9tIHNpbmdsZSB2YWx1ZSB0byBhcnJheSBmb3IgXCIke2hhYml0TmFtZX1cIiBvbiAke2RhdGV9LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhaWx5RGF0YVtoYWJpdE5hbWVdID0gW3Jhd1N0YXR1c107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlncmF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmF3U3RhdHVzID09PSBudWxsIHx8IHJhd1N0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG51bGwvdW5kZWZpbmVkIGZvciBudW1iZXIgdHlwZSBiZWNvbWVzIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYWlseURhdGFbaGFiaXROYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHJhd1N0YXR1cykgJiYgdHlwZW9mIHJhd1N0YXR1cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHVuZXhwZWN0ZWQgdHlwZXMgZm9yIG51bWJlciBoYWJpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSGFiaXQgVHJhY2tlcl0gVW5leHBlY3RlZCBub24tYXJyYXkvbm9uLW51bWJlciBkYXRhIGZvciBudW1iZXIgaGFiaXQgXCIke2hhYml0TmFtZX1cIiBvbiAke2RhdGV9LiBTZXR0aW5nIHRvIG51bGwuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhaWx5RGF0YVtoYWJpdE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlncmF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0RGVmICYmIGhhYml0RGVmLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRleHQgZGF0YSBpcyBzdHJpbmcgb3IgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1N0YXR1cyAhPT0gbnVsbCAmJiB0eXBlb2YgcmF3U3RhdHVzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbm9uLXN0cmluZyBkYXRhIGZvciB0ZXh0IGhhYml0IFwiJHtoYWJpdE5hbWV9XCIgb24gJHtkYXRlfS4gU2V0dGluZyB0byBudWxsLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhaWx5RGF0YVtoYWJpdE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdyYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXdTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhaWx5RGF0YVtoYWJpdE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFoYWJpdERlZiAmJiByYXdTdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFiaXQgZGVmaW5pdGlvbiBpcyBub3QgZm91bmQgYnV0IGRhdGEgZXhpc3RzLCBpdCBtaWdodCBiZSBzdGFsZSBkYXRhIGZyb20gYSBkZWxldGVkIGhhYml0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBjbGVhbiB0aGlzIHVwLCBidXQgYmUgY2F1dGlvdXMuIEZvciBub3csIGp1c3QgbG9nIGEgd2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIERhdGEgZm91bmQgZm9yIHVua25vd24gaGFiaXQgXCIke2hhYml0TmFtZX1cIiBvbiAke2RhdGV9LmApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBDbGVhbiB1cCBlbXB0eSBkYXRlIGVudHJpZXMgaWYgYWxsIGhhYml0cyBmb3IgdGhhdCBkYXRlIGFyZSBkZWxldGVkL21pZ3JhdGVkIHRvIG51bGxcbiAgICAgICAgICAgICAgIGNvbnN0IGhhc0VudHJpZXMgPSBPYmplY3QudmFsdWVzKGRhaWx5RGF0YSkuc29tZSh2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgIGlmICghaGFzRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIENsZWFyaW5nIGVtcHR5IGRhdGUgZW50cnkgZm9yICR7ZGF0ZX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVdO1xuICAgICAgICAgICAgICAgICAgICBtaWdyYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gRXhhbXBsZSBNaWdyYXRpb246IEVuc3VyZSBhbGwgaGFiaXRzIGhhdmUgYSBzdGF0c1R5cGUgcHJvcGVydHkgd2l0aCBhIGRlZmF1bHRcbiAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5oYWJpdHMuZm9yRWFjaChoYWJpdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhhYml0LnN0YXRzVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQWRkaW5nIGRlZmF1bHQgc3RhdHNUeXBlIGZvciBoYWJpdCBcIiR7aGFiaXQubmFtZX1cIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFiaXQuc3RhdHNUeXBlID0gKGhhYml0LnR5cGUgPT09ICdudW1iZXInID8gJ2JhcicgOiAnaGVhdG1hcCcpO1xuICAgICAgICAgICAgICAgICAgICBtaWdyYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgaGVhdG1hcCBpcyBub3Qgc2V0IGZvciBudW1iZXIgdHlwZXMgdGhhdCBzaG91bGQgaGF2ZSBjaGFydHNcbiAgICAgICAgICAgICAgICBpZiAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicgJiYgaGFiaXQuc3RhdHNUeXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQ2hhbmdpbmcgc3RhdHNUeXBlIGZyb20gJ2hlYXRtYXAnIHRvICdiYXInIGZvciBudW1iZXIgaGFiaXQgXCIke2hhYml0Lm5hbWV9XCIuYCk7XG4gICAgICAgICAgICAgICAgICAgICBoYWJpdC5zdGF0c1R5cGUgPSAnYmFyJztcbiAgICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBzdGF0c1R5cGUgaXMgaGVhdG1hcCBmb3IgYm9vbGVhbiBhbmQgdGV4dCB0eXBlc1xuICAgICAgICAgICAgICAgIGlmICgoaGFiaXQudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IGhhYml0LnR5cGUgPT09ICd0ZXh0JykgJiYgaGFiaXQuc3RhdHNUeXBlICE9PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQ2hhbmdpbmcgc3RhdHNUeXBlIHRvICdoZWF0bWFwJyBmb3IgJHtoYWJpdC50eXBlfSBoYWJpdCBcIiR7aGFiaXQubmFtZX1cIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgIGhhYml0LnN0YXRzVHlwZSA9ICdoZWF0bWFwJztcbiAgICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgIGlmIChtaWdyYXRpb25OZWVkZWQpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIERhdGEgbWlncmF0aW9uIGNvbXBsZXRlZC4gU2F2aW5nIHNldHRpbmdzLlwiKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIE5vIGRhdGEgbWlncmF0aW9uIG5lZWRlZC5cIik7XG4gICAgICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldyh2aWV3VHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblxuICAgICAgICBsZXQgbGVhZjogV29ya3NwYWNlTGVhZiB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB3b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKHZpZXdUeXBlKTtcblxuICAgICAgICBpZiAobGVhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEEgbGVhZiBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgbGVhZiA9IGxlYXZlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsZWFmXG4gICAgICAgICAgICBsZWFmID0gd29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSk7IC8vIE9yIGdldEFjdGl2ZUxlYWYoKSwgZ2V0TGVmdExlYWYoKSwgZXRjLlxuICAgICAgICAgICAgaWYgKGxlYWYpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7IHR5cGU6IHZpZXdUeXBlLCBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBcIlJldmVhbFwiIHRoZSBsZWFmIGluIHRoZSBVSVxuICAgICAgICBpZiAobGVhZikge1xuICAgICAgICAgICAgIHdvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHRyaWdnZXIgYSByZS1yZW5kZXIgb2YgdGhlIHZpZXcgY29udGVudCBpZiBpdCdzIHRoZSBoYWJpdCB0cmFja2VyIHZpZXdcbiAgICAgICAgICAgICBpZiAodmlld1R5cGUgPT09IEhBQklUX1RSQUNLRVJfVklFV19UWVBFICYmIGxlYWYudmlldyBpbnN0YW5jZW9mIEhhYml0VHJhY2tlclZpZXcpIHtcbiAgICAgICAgICAgICAgICAgbGVhZi52aWV3LnJlbmRlclZpZXcoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLy8gLS0tIE1lcmdlZCBIYWJpdCBUcmFja2VyIFZpZXcgQ2xhc3MgLS0tXG5leHBvcnQgY2xhc3MgSGFiaXRUcmFja2VyVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgICBwbHVnaW46IFRyYWNrZXJQbHVnaW47IC8vIFVzZSB0aGUgYWN0dWFsIHBsdWdpbiB0eXBlIG5vd1xuXG4gICAgLy8gU3RhdGUgZm9yIENoZWNrLWluIFNlY3Rpb25cbiAgICBjdXJyZW50V2Vla1N0YXJ0OiBtb21lbnQuTW9tZW50O1xuXG4gICAgLy8gU3RhdGUgZm9yIE1vbnRobHkgT3ZlcnZpZXcgU2VjdGlvbiAoSW5kZXBlbmRlbnQgZnJvbSBTdGF0cylcbiAgICBjdXJyZW50TW9udGhPdmVydmlld0RhdGU6IG1vbWVudC5Nb21lbnQ7IC8vIE5ldyBzdGF0ZSB2YXJpYWJsZSBmb3IgTW9udGhseSBPdmVydmlld1xuICAgIHByaXZhdGUgbW9udGhseU92ZXJ2aWV3R3JpZENvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBtb250aGx5IG92ZXJ2aWV3IGdyaWQgY29udGFpbmVyXG4gICAgcHJpdmF0ZSBtb250aGx5T3ZlcnZpZXdEYXRlRGlzcGxheUVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsOyAvLyBSZWZlcmVuY2UgdG8gdGhlIGRhdGUgZGlzcGxheSBlbGVtZW50XG5cbiAgICAvLyBTdGF0ZSBmb3IgU3RhdGlzdGljcyBTZWN0aW9uXG4gICAgY3VycmVudFN0YXRzUGVyaW9kOiAnbW9udGgnIHwgJ3llYXInID0gJ21vbnRoJztcbiAgICBjdXJyZW50U3RhdHNEYXRlOiBtb21lbnQuTW9tZW50OyAvLyBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudGx5IHZpZXdlZCBtb250aCBvciB5ZWFyIGZvciBTdGF0c1xuICAgIHByaXZhdGUgc3RhdHNDb250ZW50Q29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsOyAvLyBSZWZlcmVuY2UgdG8gdGhlIHN0YXRzIGNvbnRlbnQgY29udGFpbmVyXG4gICAgcHJpdmF0ZSBzdGF0c0RhdGVEaXNwbGF5RWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7IC8vIFJlZmVyZW5jZSB0byB0aGUgZGF0ZSBkaXNwbGF5IGVsZW1lbnQgaW4gc3RhdHNcblxuICAgIHByaXZhdGUgY2hhcnRJbnN0YW5jZXM6IE1hcDxzdHJpbmcsIENoYXJ0PiA9IG5ldyBNYXAoKTsgLy8gVG8gc3RvcmUgQ2hhcnQuanMgaW5zdGFuY2VzIGZvciBlYWNoIGhhYml0ICh1c2luZyBDaGFydCB0eXBlKVxuXG4gICAgLy8gRGVmaW5lIHRoZSBpY29uIGZvciB0aGlzIHZpZXcgdHlwZVxuICAgIGljb24gPSAnY2hlY2stY2lyY2xlJzsgLy8gU2V0IHRoZSBpY29uIHByb3BlcnR5IGZvciB0aGUgbWVyZ2VkIHZpZXdcblxuXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBUcmFja2VyUGx1Z2luKSB7IC8vIFVzZSB0aGUgYWN0dWFsIHBsdWdpbiB0eXBlXG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdGF0ZSBmb3IgYm90aCBzZWN0aW9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWVrU3RhcnQgPSBtb21lbnQoKS5zdGFydE9mKCd3ZWVrJyk7IC8vIFVzZSBtb21lbnQncyBzdGFydE9mKCd3ZWVrJykgd2hpY2ggcmVzcGVjdHMgbG9jYWxlIChwbHVnaW4gc2V0dGluZ3MpXG4gICAgICAgIHRoaXMuY3VycmVudE1vbnRoT3ZlcnZpZXdEYXRlID0gbW9tZW50KCkuc3RhcnRPZignbW9udGgnKTsgLy8gSW5pdGlhbGl6ZSBNb250aGx5IE92ZXJ2aWV3IGRhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHNEYXRlID0gbW9tZW50KCkuc3RhcnRPZignbW9udGgnKTsgLy8gSW5pdGlhbGl6ZSBTdGF0aXN0aWNzIGRhdGUgKGNhbiBiZSBpbmRlcGVuZGVudCBvciBsaW5rZWQsIGJ1dCBrZWVwaW5nIHNlcGFyYXRlIGZvciBub3cpXG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEhBQklUX1RSQUNLRVJfVklFV19UWVBFO1xuICAgIH1cblxuICAgIGdldERpc3BsYXlUZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnSGFiaXQgVHJhY2tlcic7IC8vIERpc3BsYXkgdGV4dCBmb3IgdGhlIG1lcmdlZCB2aWV3IHRhYlxuICAgIH1cblxuICAgIC8vIG9uT3BlbiBpcyBjYWxsZWQgd2hlbiB0aGUgdmlldyBpcyBvcGVuZWRcbiAgICBhc3luYyBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzOyAvLyBjb250ZW50RWwgaXMgdGhlIG1haW4gY29udGFpbmVyIGZvciB0aGUgdmlld1xuXG4gICAgICAgIC8vIEFkZCBhIGNsYXNzIHRvIHRoZSB2aWV3IGNvbnRhaW5lciBmb3Igc3BlY2lmaWMgc3R5bGluZ1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmFkZENsYXNzKCdoYWJpdC10cmFja2VyLXZpZXcnKTtcblxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgcHJldmlvdXMgY29udGVudFxuXG4gICAgICAgIC8vIFJlbmRlciBhbGwgc2VjdGlvbnNcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiBtZXRob2QgdG8gcmVuZGVyIHRoZSBlbnRpcmUgdmlldyBzdHJ1Y3R1cmVcbiAgICByZW5kZXJWaWV3KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblxuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50IGJlZm9yZSByZW5kZXJpbmdcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIGNvbnRlbnQgb24gZnVsbCByZS1yZW5kZXJcblxuICAgICAgICAvLyAtLS0gUmVuZGVyIFdlZWtseSBDaGVjay1pbiBTZWN0aW9uIC0tLVxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSGFiaXQgQ2hlY2staW4nIH0pOyAvLyBDaGFuZ2VkIHRpdGxlXG4gICAgICAgIHRoaXMuYWRkQ2hlY2tpbk5hdmlnYXRpb25BbmREYXRlRGlzcGxheShjb250ZW50RWwpOyAvLyBBZGQgY2hlY2staW4gY29udHJvbHNcbiAgICAgICAgdGhpcy5yZW5kZXJDaGVja2luR3JpZChjb250ZW50RWwpOyAvLyBSZW5kZXIgY2hlY2staW4gZ3JpZFxuXG5cbiAgICAgICAgLy8gQWRkIGEgc2VwYXJhdG9yXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaHInKTtcblxuXG4gICAgICAgIC8vIC0tLSBSZW5kZXIgTW9udGhseSBPdmVydmlldyBTZWN0aW9uIC0tLVxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnTW9udGhseSBPdmVydmlldycgfSk7IC8vIE5ldyBzZWN0aW9uIHRpdGxlXG4gICAgICAgIHRoaXMuYWRkTW9udGhseU92ZXJ2aWV3TmF2aWdhdGlvbihjb250ZW50RWwpOyAvLyBBZGQgbW9udGggbmF2aWdhdGlvbiBidXR0b25zIGZvciBvdmVydmlld1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBzcGVjaWZpY2FsbHkgZm9yIHRoZSBtb250aGx5IG92ZXJ2aWV3IGdyaWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAvLyBUaGlzIGNvbnRhaW5lciB3aWxsIGJlIGNsZWFyZWQgYW5kIHJlLXJlbmRlcmVkIGJ5IHJlbmRlck1vbnRobHlPdmVydmlld0dyaWRcbiAgICAgICAgdGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LW1vbnRobHktb3ZlcnZpZXctZ3JpZC1jb250YWluZXInIH0pO1xuICAgICAgICB0aGlzLnJlbmRlck1vbnRobHlPdmVydmlld0dyaWQodGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyKTsgLy8gUmVuZGVyIG1vbnRobHkgb3ZlcnZpZXcgZ3JpZCBpbnNpZGUgaXRzIGNvbnRhaW5lclxuXG5cbiAgICAgICAgLy8gQWRkIGEgc2VwYXJhdG9yXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaHInKTtcblxuXG4gICAgICAgIC8vIC0tLSBSZW5kZXIgU3RhdGlzdGljcyBTZWN0aW9uIC0tLVxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSGFiaXQgU3RhdGlzdGljcycgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBzcGVjaWZpY2FsbHkgZm9yIHN0YXRzIGNvbnRyb2xzIGFuZCBjb250ZW50XG4gICAgICAgIC8vIFRoaXMgY29udGFpbmVyIHdpbGwgaG9sZCBib3RoIGNvbnRyb2xzIGFuZCB0aGUgc3RhdHMgY29udGVudCBhcmVhXG4gICAgICAgIGxldCBzdGF0c1NlY3Rpb25Db250YWluZXIgPSBjb250ZW50RWwucXVlcnlTZWxlY3RvcignLmhhYml0LXN0YXRzLXNlY3Rpb24tY29udGFpbmVyJyk7XG4gICAgICAgIGlmICghc3RhdHNTZWN0aW9uQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzdGF0c1NlY3Rpb25Db250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnaGFiaXQtc3RhdHMtc2VjdGlvbi1jb250YWluZXInIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGNvbnRyb2xzIGFuZCB0aGUgc3RhdHMgY29udGVudCBhcmVhIGlmIHRoZXkgYXJlbid0IGFscmVhZHkgdGhlcmVcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDb250cm9scyA9IHN0YXRzU2VjdGlvbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaGFiaXQtc3RhdHMtY29udHJvbHMnKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0NvbnRyb2xzKSB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coXCJbSGFiaXQgVHJhY2tlcl0gQWRkaW5nIHN0YXRzIGNvbnRyb2xzIGFuZCBjb250ZW50IGNvbnRhaW5lci4uLlwiKTtcbiAgICAgICAgICAgICAvLyBhZGRTdGF0c0NvbnRyb2xzIG5vdyBhbHNvIGNyZWF0ZXMgYW5kIGFzc2lnbnMgdGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXJcbiAgICAgICAgICAgICB0aGlzLmFkZFN0YXRzQ29udHJvbHMoc3RhdHNTZWN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltIYWJpdCBUcmFja2VyXSBTdGF0cyBjb250cm9scyBhbmQgY29udGVudCBjb250YWluZXIgZXhpc3QsIHVwZGF0aW5nIHZpZXcuXCIpO1xuICAgICAgICAgICAgIC8vIElmIGNvbnRyb2xzIGFuZCBjb250ZW50IGNvbnRhaW5lciBleGlzdCwganVzdCB1cGRhdGUgdGhlaXIgZGlzcGxheSBhbmQgcmUtcmVuZGVyIHN0YXRzIGNvbnRlbnRcbiAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzVmlldygpOyAvLyBUaGlzIG1ldGhvZCB1cGRhdGVzIGNvbnRyb2xzIGRpc3BsYXkgYW5kIGNhbGxzIHJlbmRlclN0YXRzQ29udGVudFxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyAtLS0gQ2hlY2staW4gU2VjdGlvbiBSZW5kZXJpbmcgYW5kIENvbnRyb2wgTG9naWMgLS0tXG5cbiAgICBhZGRDaGVja2luTmF2aWdhdGlvbkFuZERhdGVEaXNwbGF5KGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgbmF2IGNvbnRhaW5lciBpZiByZS1yZW5kZXJpbmdcbiAgICAgICAgY29udGFpbmVyRWwuZmluZEFsbCgnLmhhYml0LWdyaWQtbmF2JykuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciBuYXZpZ2F0aW9uIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IG5hdkNvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LWdyaWQtbmF2JyB9KTtcblxuICAgICAgICAvLyBQcmV2aW91cyB3ZWVrIGJ1dHRvblxuICAgICAgICBjb25zdCBwcmV2QnV0dG9uID0gbmF2Q29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICc8PCBQcmV2JywgY2xzOiAnaGFiaXQtZ3JpZC1uYXYtYnV0dG9uJyB9KTtcbiAgICAgICAgcHJldkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHsgLy8gQWRkZWQgZXZ0IHBhcmFtZXRlclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBidXR0b24gYmVoYXZpb3IgKHN0b3BzIHBvdGVudGlhbCBzY3JvbGxpbmcpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRXZWVrU3RhcnQuc3VidHJhY3QoNywgJ2RheXMnKTsgLy8gTW92ZSB0byB0aGUgcHJldmlvdXMgd2Vla1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7IC8vIFJlLXJlbmRlciB0aGUgZW50aXJlIHZpZXcgKENoZWNrLWluIGdyaWQgZGVwZW5kcyBvbiB0aGlzKVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEYXRlIHJhbmdlIGRpc3BsYXkgLSB3aWxsIGJlIHVwZGF0ZWQgaW4gcmVuZGVyQ2hlY2tpbkdyaWRcbiAgICAgICAgY29uc3QgZGF0ZVJhbmdlRWwgPSBuYXZDb250YWluZXIuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2hhYml0LWdyaWQtZGF0ZS1yYW5nZScgfSk7XG5cbiAgICAgICAgLy8gTmV4dCB3ZWVrIGJ1dHRvblxuICAgICAgICBjb25zdCBuZXh0QnV0dG9uID0gbmF2Q29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdOZXh0ID4+JywgY2xzOiAnaGFiaXQtZ3JpZC1uYXYtYnV0dG9uJyB9KTtcbiAgICAgICAgbmV4dEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHsgLy8gQWRkZWQgZXZ0IHBhcmFtZXRlclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBidXR0b24gYmVoYXZpb3IgKHN0b3BzIHBvdGVudGlhbCBzY3JvbGxpbmcpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRXZWVrU3RhcnQuYWRkKDcsICdkYXlzJyk7IC8vIE1vdmUgdG8gdGhlIG5leHQgd2Vla1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7IC8vIFJlLXJlbmRlciB0aGUgZW50aXJlIHZpZXcgKENoZWNrLWluIGdyaWQgZGVwZW5kcyBvbiB0aGlzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYSBtZXRob2QgdG8gcmVuZGVyL3JlLXJlbmRlciB0aGUgd2Vla2x5IGNoZWNrLWluIGdyaWRcbiAgICByZW5kZXJDaGVja2luR3JpZChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyaWQgaWYgaXQgZXhpc3RzXG4gICAgICAgIGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5oYWJpdC1ncmlkLWNvbnRhaW5lcicpPy5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCBoYWJpdHMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHM7IC8vIGhhYml0cyBpcyBub3cgYXJyYXkgb2YgSGFiaXQgb2JqZWN0c1xuICAgICAgICBjb25zdCBjb21wbGV0aW9uRGF0YSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhOyAvLyBHZXQgYWxsIGNvbXBsZXRpb24gZGF0YVxuXG4gICAgICAgIGlmIChoYWJpdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01zZyA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5uby1oYWJpdHMtbWVzc2FnZScpO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ01zZykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnTm8gaGFiaXRzIGRlZmluZWQgeWV0LiBHbyB0byBwbHVnaW4gc2V0dGluZ3MgdG8gYWRkIGhhYml0cy4nLCBjbHM6ICduby1oYWJpdHMtbWVzc2FnZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJFbC5maW5kQWxsKCcubm8taGFiaXRzLW1lc3NhZ2UnKS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyaWRDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLWNvbnRhaW5lcicgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRPZldlZWsgPSB0aGlzLmN1cnJlbnRXZWVrU3RhcnQuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgd2Vla0RhdGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gXCJZWVlZLU1NLUREXCI7IC8vIERlZmluZSBkYXRlIGZvcm1hdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERheSA9IHN0YXJ0T2ZXZWVrLmNsb25lKCkuYWRkKGksICdkYXlzJyk7XG4gICAgICAgICAgICB3ZWVrRGF0ZXMucHVzaChjdXJyZW50RGF5LmZvcm1hdChkYXRlRm9ybWF0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZGF0ZSByYW5nZSBkaXNwbGF5IHdpdGhpbiByZW5kZXJWaWV3IGxvZ2ljXG4gICAgICAgIGNvbnN0IGRhdGVSYW5nZUVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmhhYml0LWdyaWQtbmF2IC5oYWJpdC1ncmlkLWRhdGUtcmFuZ2UnKTsgLy8gVXNlIG1vcmUgc3BlY2lmaWMgc2VsZWN0b3JcbiAgICAgICAgaWYgKGRhdGVSYW5nZUVsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG1vbWVudCh3ZWVrRGF0ZXNbMF0pO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbW9tZW50KHdlZWtEYXRlc1s2XSk7XG4gICAgICAgICAgICAvLyBNb2RpZmllZDogQ2hhbmdlIGRhdGUgZm9ybWF0IHRvIFwiWVlZWSBNTS5ERC1NTS5ERFwiXG4gICAgICAgICAgICBkYXRlUmFuZ2VFbC5zZXRUZXh0KGAke3N0YXJ0LmZvcm1hdCgnWVlZWSBNTS5ERCcpfS0ke2VuZC5mb3JtYXQoJ01NLkREJyl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoZWFkZXJSb3cgPSBncmlkQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LWdyaWQtaGVhZGVyLXJvdycgfSk7XG4gICAgICAgIGhlYWRlclJvdy5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLWhlYWRlci1jb3JuZXInIH0pO1xuXG4gICAgICAgIGNvbnN0IGRheU9mV2Vla0xhYmVsc1Nob3J0ID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZERheXNPZldlZWsgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnREYXlJbmRleCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLndlZWtTdGFydHNPbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG9yZGVyZWREYXlzT2ZXZWVrLnB1c2goZGF5T2ZXZWVrTGFiZWxzU2hvcnRbKHN0YXJ0RGF5SW5kZXggKyBpKSAlIDddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yZGVyZWREYXlzT2ZXZWVrLmZvckVhY2goKGRheUxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXlIZWFkZXJFbCA9IGhlYWRlclJvdy5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLWRheS1oZWFkZXInIH0pO1xuICAgICAgICAgICAgZGF5SGVhZGVyRWwuY3JlYXRlU3Bhbih7IHRleHQ6IGRheUxhYmVsLCBjbHM6ICdoYWJpdC1ncmlkLWRheS1uYW1lJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVGb3JUaGlzRGF5TGFiZWwgPSB3ZWVrRGF0ZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChkYXRlRm9yVGhpc0RheUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgZGF5SGVhZGVyRWwuY3JlYXRlU3Bhbih7IHRleHQ6IG1vbWVudChkYXRlRm9yVGhpc0RheUxhYmVsKS5mb3JtYXQoXCJERFwiKSwgY2xzOiAnaGFiaXQtZ3JpZC1kYXktZGF0ZScgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUhlYWRlckVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiAnJywgY2xzOiAnaGFiaXQtZ3JpZC1kYXktZGF0ZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhYml0cy5mb3JFYWNoKGhhYml0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhYml0Um93ID0gZ3JpZENvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLXJvdycgfSk7XG4gICAgICAgICAgICBoYWJpdFJvdy5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBoYWJpdC5uYW1lLCBjbHM6ICdoYWJpdC1ncmlkLWhhYml0LW5hbWUnIH0pO1xuXG4gICAgICAgICAgICB3ZWVrRGF0ZXMuZm9yRWFjaChkYXRlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2luQ2VsbCA9IGhhYml0Um93LmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogJ2hhYml0LWdyaWQtY2hlY2tpbi1jZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtaGFiaXQtbmFtZSc6IGhhYml0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1kYXRlJzogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWhhYml0LXR5cGUnOiBoYWJpdC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHN0YXR1cyBjaXJjbGUgYW5kIHZhbHVlIGVsZW1lbnRzICppbnNpZGUqIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ2lyY2xlID0gY2hlY2tpbkNlbGwuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnc3RhdHVzLWNpcmNsZScgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzVmFsdWVEaXNwbGF5ID0gY2hlY2tpbkNlbGwuY3JlYXRlU3Bhbih7IGNsczogJ3N0YXR1cy12YWx1ZS1kaXNwbGF5JyB9KTsgLy8gVGhpcyB3aWxsIGJlIGhpZGRlbiBmb3IgYm9vbGVhbi9udW1iZXIgaW5pdGlhbGx5XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgaW5pdGlhbCBzdGF0dXMgYW5kIGRldGVybWluZSB3aGF0IHRvIHBhc3MgdG8gdXBkYXRlQ2VsbEFwcGVhcmFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCByYXdTdGF0dXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtkYXRlXT8uW2hhYml0Lm5hbWVdID8/IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1c0ZvckFwcGVhcmFuY2U6IGJvb2xlYW4gfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsID0gcmF3U3RhdHVzOyAvLyBEZWZhdWx0IHRvIHJhd1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhYml0LnR5cGUgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkocmF3U3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbnVtYmVyIGhhYml0cywgcGFzcyB0aGUgc3VtIG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNGb3JBcHBlYXJhbmNlID0gcmF3U3RhdHVzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0LnR5cGUgPT09ICdib29sZWFuJyAmJiBoYWJpdC5mcmVxdWVuY3kgPT09ICdkYXknICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBkYWlseSBib29sZWFuIGhhYml0cyB3aXRoIGdvYWwgPiAxLCBwYXNzIHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNGb3JBcHBlYXJhbmNlID0gdHlwZW9mIHJhd1N0YXR1cyA9PT0gJ251bWJlcicgPyByYXdTdGF0dXMgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3Igd2Vla2x5IGJvb2xlYW4gYW5kIHRleHQsIHBhc3MgcmF3U3RhdHVzXG5cblxuICAgICAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogQ2FsY3VsYXRlIGFuZCBwYXNzIHdlZWtseSBwZXJjZW50YWdlIGZvciBXZWVrbHkgQm9vbGVhbiBoYWJpdHMgaW4gQ2hlY2staW4gdmlldyAtLS1cbiAgICAgICAgICAgICAgICBsZXQgd2Vla2x5UGVyY2VudGFnZUZvckNlbGw6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaGFiaXQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGhhYml0LmZyZXF1ZW5jeSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtTdGFydERhdGUgPSBtb21lbnQoZGF0ZSwgZGF0ZUZvcm1hdCkuc3RhcnRPZignd2VlaycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWVrRW5kRGF0ZSA9IHdlZWtTdGFydERhdGUuY2xvbmUoKS5lbmRPZignd2VlaycpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla2x5Q29tcGxldGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IG51bGwgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gaGFiaXQuY29tcGxldGlvbkdvYWwgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXlJdGVyYXRvciA9IHdlZWtTdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRheUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHdlZWtFbmREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlTdHJpbmcgPSBkYXlJdGVyYXRvci5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRheSBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgKmRpc3BsYXllZCogd2VlayByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBpc0JldHdlZW4gd2l0aCBleGNsdXNpdmUgc3RhcnQgYW5kIGluY2x1c2l2ZSBlbmQgdG8gbWF0Y2ggdGhlIHdlZWtEYXRlcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb21lbnQoZGF5U3RyaW5nLCBkYXRlRm9ybWF0KS5pc0JldHdlZW4oc3RhcnRPZldlZWsuY2xvbmUoKS5zdWJ0cmFjdCgxLCAnZGF5JyksIHN0YXJ0T2ZXZWVrLmNsb25lKCkuYWRkKDcsICdkYXlzJyksICdkYXknLCAnKF0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNGb3JEYXkgPSBjb21wbGV0aW9uRGF0YVtkYXlTdHJpbmddPy5baGFiaXQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNGb3JEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlZWtseUNvbXBsZXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgZGF5SXRlcmF0b3IuYWRkKDEsICdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3ZWVrbHlQZXJjZW50YWdlRm9yQ2VsbCA9IGNvbXBsZXRpb25Hb2FsID4gMCA/IE1hdGgubWluKCh3ZWVrbHlDb21wbGV0aW9ucyAvIGNvbXBsZXRpb25Hb2FsKSAqIDEwMCwgMTAwKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQ2hlY2staW4gQ2VsbDogXCIke2hhYml0Lm5hbWV9XCIgb24gJHtkYXRlfSwgV2Vla2x5ICU6ICR7d2Vla2x5UGVyY2VudGFnZUZvckNlbGwudG9GaXhlZCgxKX1gKTsgLy8gTG9nIHdlZWtseSBwZXJjZW50YWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC0tLSBFTkQgTU9ESUZJRUQgLS0tXG5cblxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIGNhbGN1bGF0ZWQgd2Vla2x5IHBlcmNlbnRhZ2UgKGlmIGFwcGxpY2FibGUpIHRvIHVwZGF0ZUNlbGxBcHBlYXJhbmNlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDZWxsQXBwZWFyYW5jZShjaGVja2luQ2VsbCwgaGFiaXQsIHN0YXR1c0ZvckFwcGVhcmFuY2UsIHdlZWtseVBlcmNlbnRhZ2VGb3JDZWxsKTsgLy8gUGFzcyB3ZWVrbHlQZXJjZW50YWdlXG5cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjbGljayBldmVudCBsaXN0ZW5lciAtIENsaWNraW5nIG9wZW5zIG1vZGFsIG9yIHRvZ2dsZXMgYm9vbGVhblxuICAgICAgICAgICAgICAgIGNoZWNraW5DZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2VkSGFiaXROYW1lID0gY2hlY2tpbkNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhYml0LW5hbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZERhdGUgPSBjaGVja2luQ2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2VkSGFiaXRUeXBlID0gY2hlY2tpbkNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhYml0LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZEhhYml0ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzLmZpbmQoaCA9PiBoLm5hbWUgPT09IGNsaWNrZWRIYWJpdE5hbWUpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGlja2VkSGFiaXROYW1lIHx8ICFjbGlja2VkRGF0ZSB8fCAhY2xpY2tlZEhhYml0VHlwZSB8fCAhY2xpY2tlZEhhYml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2xpY2tlZCBjZWxsIG1pc3NpbmcgZGF0YSBhdHRyaWJ1dGVzIG9yIGhhYml0IG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2NsaWNrZWREYXRlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgYmFzZWQgb24gaGFiaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpY2tlZEhhYml0VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBjbGlja2VkSGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gY2xpY2tlZEhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTsgLy8gRGVmYXVsdCBnb2FsIHRvIDFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrZWRIYWJpdC5mcmVxdWVuY3kgPT09ICdkYXknICYmIGNvbXBsZXRpb25Hb2FsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhaWx5IGJvb2xlYW4gd2l0aCBnb2FsID4gMTogSW5jcmVtZW50IGNvdW50LCByZXNldCBpZiBnb2FsIHJlYWNoZWQvZXhjZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvdW50ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIG51bWJlciB8IG51bGwgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q291bnQgPSBjdXJyZW50Q291bnQgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV3IGNvdW50IGV4Y2VlZHMgZ29hbCwgcmVzZXQgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA+IGNvbXBsZXRpb25Hb2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV1bY2xpY2tlZEhhYml0TmFtZV0gPSBuZXdDb3VudCA+IDAgPyBuZXdDb3VudCA6IG51bGw7IC8vIFN0b3JlIG51bGwgaWYgY291bnQgaXMgMFxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90aWNlTWVzc2FnZSA9IGAke2NsaWNrZWRIYWJpdE5hbWV9IG9uICR7Y2xpY2tlZERhdGV9OiBgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpY2VNZXNzYWdlICs9ICdDb3VudCByZXNldC4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGljZU1lc3NhZ2UgKz0gYENvdW50OiAke25ld0NvdW50fS8ke2NvbXBsZXRpb25Hb2FsfS5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKG5vdGljZU1lc3NhZ2UsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhaWx5IGJvb2xlYW4gd2l0aCBnb2FsIDw9IDEsIG9yIFdlZWtseSBib29sZWFuOiBUb2dnbGUgdHJ1ZS9udWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogRm9yIHdlZWtseSwgY2xpY2tpbmcgbWFya3MgdGhlIGRheSBhcyBcImNvbXBsZXRlZFwiICh0cnVlKSB0b3dhcmRzIHRoZSB3ZWVrbHkgZ29hbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdTdGF0dXM6IGJvb2xlYW4gfCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdHVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXR1cyA9IG51bGw7IC8vIENsaWNraW5nIG9uIGNvbXBsZXRlZCBjbGVhcnMgdGhlIGVudHJ5IGZvciB0aGlzIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGN1cnJlbnRTdGF0dXMgaXMgZmFsc2UsIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXR1cyA9IHRydWU7IC8vIENsaWNraW5nIG9uIGluY29tcGxldGUgb3Igbm8gZW50cnkgbWFya3MgYXMgY29tcGxldGVkIGZvciB0aGlzIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV1bY2xpY2tlZEhhYml0TmFtZV0gPSBuZXdTdGF0dXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90aWNlTWVzc2FnZSA9IGAke2NsaWNrZWRIYWJpdE5hbWV9IG9uICR7Y2xpY2tlZERhdGV9IGA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cyA9PT0gdHJ1ZSkgbm90aWNlTWVzc2FnZSArPSAnbWFya2VkIGFzIENvbXBsZXRlZC4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugbm90aWNlTWVzc2FnZSArPSAnZW50cnkgY2xlYXJlZC4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2Uobm90aWNlTWVzc2FnZSwgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7IC8vIFJlLXJlbmRlciB0aGUgZW50aXJlIHZpZXcgKENoZWNrLWluIGdyaWQgZGVwZW5kcyBvbiB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWNrZWRIYWJpdFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIE51bWJlciBJbnB1dCBNb2RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE51bWJlcklucHV0TW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLCBjbGlja2VkRGF0ZSwgY2xpY2tlZEhhYml0TmFtZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIG51bWJlcltdIHwgbnVsbCwgLy8gUGFzcyByYXcgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7IC8vIENhbGxiYWNrIGFmdGVyIHNhdmUvY2xlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7IC8vIFJlLXJlbmRlciB0aGUgZW50aXJlIHZpZXcgKENoZWNrLWluIGdyaWQgZGVwZW5kcyBvbiB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICkub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWNrZWRIYWJpdFR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiBUZXh0IElucHV0IE1vZGFsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dElucHV0TW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLCBjbGlja2VkRGF0ZSwgY2xpY2tlZEhhYml0TmFtZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIHN0cmluZyB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IHsgLy8gQ2FsbGJhY2sgYWZ0ZXIgc2F2ZS9jbGVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTsgLy8gUmUtcmVuZGVyIHRoZSBlbnRpcmUgdmlldyAoQ2hlY2staW4gZ3JpZCBkZXBlbmRzIG9uIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kIHRvIGFkZCBtb250aGx5IG92ZXJ2aWV3IG5hdmlnYXRpb24gY29udHJvbHNcbiAgICBhZGRNb250aGx5T3ZlcnZpZXdOYXZpZ2F0aW9uKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgbmF2IGNvbnRhaW5lciBpZiByZS1yZW5kZXJpbmdcbiAgICAgICAgY29udGFpbmVyRWwuZmluZEFsbCgnLm1vbnRobHktb3ZlcnZpZXctaGVhZGVyLW5hdicpLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgbmF2aWdhdGlvbiBlbGVtZW50cywgcmV1c2luZyBzdHlsZXMgZnJvbSBoYWJpdC1ncmlkLW5hdlxuICAgICAgICBjb25zdCBuYXZDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLW5hdiBtb250aGx5LW92ZXJ2aWV3LWhlYWRlci1uYXYnIH0pO1xuXG4gICAgICAgIC8vIFByZXZpb3VzIG1vbnRoIGJ1dHRvblxuICAgICAgICBjb25zdCBwcmV2QnV0dG9uID0gbmF2Q29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICc8PCBQcmV2JywgY2xzOiAnaGFiaXQtZ3JpZC1uYXYtYnV0dG9uJyB9KTsgLy8gU2ltcGxpZmllZCB0ZXh0XG4gICAgICAgIHByZXZCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7IC8vIEFkZGVkIGV2dCBwYXJhbWV0ZXJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgYnV0dG9uIGJlaGF2aW9yIChzdG9wcyBwb3RlbnRpYWwgc2Nyb2xsaW5nKVxuICAgICAgICAgICAgLy8gTmF2aWdhdGUgdGhlIE1vbnRobHkgT3ZlcnZpZXcgZGF0ZSBieSBtb250aFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TW9udGhPdmVydmlld0RhdGUuc3VidHJhY3QoMSwgJ21vbnRoJyk7XG4gICAgICAgICAgICAvLyAtLS0gTU9ESUZJRUQ6IE9ubHkgcmUtcmVuZGVyIHRoZSBtb250aGx5IG92ZXJ2aWV3IGdyaWQgYW5kIHVwZGF0ZSBkYXRlIGRpc3BsYXkgLS0tXG4gICAgICAgICAgICBpZiAodGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNb250aGx5T3ZlcnZpZXdHcmlkKHRoaXMubW9udGhseU92ZXJ2aWV3R3JpZENvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tb250aGx5T3ZlcnZpZXdEYXRlRGlzcGxheUVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNb250aGx5T3ZlcnZpZXdEYXRlRGlzcGxheSh0aGlzLm1vbnRobHlPdmVydmlld0RhdGVEaXNwbGF5RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tIEVORCBNT0RJRklFRCAtLS1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGF0ZSBkaXNwbGF5IHNwYW4gLSBQbGFjZWQgYmV0d2VlbiBidXR0b25zXG4gICAgICAgIHRoaXMubW9udGhseU92ZXJ2aWV3RGF0ZURpc3BsYXlFbCA9IG5hdkNvbnRhaW5lci5jcmVhdGVFbCgnc3BhbicsIHsgY2xzOiAnaGFiaXQtZ3JpZC1kYXRlLXJhbmdlIG1vbnRobHktb3ZlcnZpZXctZGF0ZS1kaXNwbGF5JyB9KTsgLy8gUmV1c2UgZGF0ZS1yYW5nZSBzdHlsZSwgYWRkIHNwZWNpZmljIGNsYXNzXG4gICAgICAgIHRoaXMudXBkYXRlTW9udGhseU92ZXJ2aWV3RGF0ZURpc3BsYXkodGhpcy5tb250aGx5T3ZlcnZpZXdEYXRlRGlzcGxheUVsKTsgLy8gVXBkYXRlIHRleHQgaW5pdGlhbGx5XG5cbiAgICAgICAgLy8gTmV4dCBtb250aCBidXR0b25cbiAgICAgICAgY29uc3QgbmV4dEJ1dHRvbiA9IG5hdkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnTmV4dCA+PicsIGNsczogJ2hhYml0LWdyaWQtbmF2LWJ1dHRvbicgfSk7IC8vIFNpbXBsaWZpZWQgdGV4dFxuICAgICAgICBuZXh0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4geyAvLyBBZGRlZCBldnQgcGFyYW1ldGVyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IGJ1dHRvbiBiZWhhdmlvciAoc3RvcHMgcG90ZW50aWFsIHNjcm9sbGluZylcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRoZSBNb250aGx5IE92ZXJ2aWV3IGRhdGUgYnkgbW9udGhcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1vbnRoT3ZlcnZpZXdEYXRlLmFkZCgxLCAnbW9udGgnKTtcbiAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogT25seSByZS1yZW5kZXIgdGhlIG1vbnRobHkgb3ZlcnZpZXcgZ3JpZCBhbmQgdXBkYXRlIGRhdGUgZGlzcGxheSAtLS1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vbnRobHlPdmVydmlld0dyaWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1vbnRobHlPdmVydmlld0dyaWQodGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vbnRobHlPdmVydmlld0RhdGVEaXNwbGF5RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1vbnRobHlPdmVydmlld0RhdGVEaXNwbGF5KHRoaXMubW9udGhseU92ZXJ2aWV3RGF0ZURpc3BsYXlFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gRU5EIE1PRElGSUVEIC0tLVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgc2VwYXJhdGUgaDIgZm9yIHRoZSBoZWFkZXIgaXMgcmVtb3ZlZCwgaXRzIHRleHQgaXMgbm93IGluIHRoZSBkYXRlRGlzcGxheUVsIHNwYW5cbiAgICB9XG5cblxuICAgIC8vIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIHRoZSBtb250aGx5IG92ZXJ2aWV3IGRhdGUgZGlzcGxheVxuICAgIHVwZGF0ZU1vbnRobHlPdmVydmlld0RhdGVEaXNwbGF5KGRhdGVEaXNwbGF5RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGRhdGVEaXNwbGF5RWwuc2V0VGV4dCh0aGlzLmN1cnJlbnRNb250aE92ZXJ2aWV3RGF0ZS5mb3JtYXQoJ1lZWVkgTU1NTScpKTtcbiAgICB9XG5cblxuICAgIC8vIC0tLSBSZW5kZXIgTW9udGhseSBPdmVydmlldyBHcmlkIFNlY3Rpb24gLS0tXG4gICAgLy8gTW9kaWZpZWQgdG8gdXNlIGN1cnJlbnRNb250aE92ZXJ2aWV3RGF0ZSBhbmQgcmV2ZXJ0IHRvIDFmciBjb2x1bW5zIGZvciBmbGV4aWJsZSBzaXppbmdcbiAgICAvLyBUaGlzIG1ldGhvZCBub3cgdGFrZXMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHdoZXJlIGl0IHNob3VsZCByZW5kZXJcbiAgICByZW5kZXJNb250aGx5T3ZlcnZpZXdHcmlkKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBncmlkIGNvbnRlbnQgd2l0aGluIHRoZSBwcm92aWRlZCBjb250YWluZXJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBjb25zdCBoYWJpdHMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHM7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25EYXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGE7XG5cbiAgICAgICAgaWYgKGhhYml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIG1lc3NhZ2UgaWYgbm8gaGFiaXRzIGFyZSBjb25maWd1cmVkLCBzaW1pbGFyIHRvIGNoZWNrLWluXG4gICAgICAgICAgICBjb25zdCBub0hhYml0c01lc3NhZ2UgPSBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgY2xzOiAnbm8taGFiaXRzLW1lc3NhZ2UnLCB0ZXh0OiAnTm8gaGFiaXRzIGRlZmluZWQgdG8gZGlzcGxheSBtb250aGx5IG92ZXJ2aWV3LicgfSk7XG4gICAgICAgICAgICBub0hhYml0c01lc3NhZ2Uuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBub0hhYml0c01lc3NhZ2Uuc3R5bGUuY29sb3IgPSAndmFyKC0tdGV4dC1tdXRlZCknO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG1lc3NhZ2UgaWYgaGFiaXRzIGV4aXN0IChpbiBjYXNlIGl0IHdhcyBwcmV2aW91c2x5IGFkZGVkKVxuICAgICAgICAgICAgIGNvbnRhaW5lckVsLmZpbmRBbGwoJy5uby1oYWJpdHMtbWVzc2FnZScpLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnRNb250aE92ZXJ2aWV3RGF0ZSB0byBkZXRlcm1pbmUgdGhlIG1vbnRoIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gdGhpcy5jdXJyZW50TW9udGhPdmVydmlld0RhdGUuY2xvbmUoKS5zdGFydE9mKCdtb250aCcpO1xuICAgICAgICBjb25zdCBkYXlzSW5Nb250aCA9IGN1cnJlbnRNb250aC5kYXlzSW5Nb250aCgpO1xuICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gXCJZWVlZLU1NLUREXCI7XG5cbiAgICAgICAgLy8gVGhlIE1vbnRoIGFuZCBZZWFyIEhlYWRlciBpcyBub3cgcGFydCBvZiB0aGUgbmF2aWdhdGlvbiBhZGRlZCBieSBhZGRNb250aGx5T3ZlcnZpZXdOYXZpZ2F0aW9uXG5cblxuICAgICAgICAvLyBSZXVzZSBoYWJpdC1ncmlkLWNvbnRhaW5lciBmb3Igb3ZlcmFsbCBzdHlsaW5nLCBhZGQgYSBzcGVjaWZpYyBjbGFzc1xuICAgICAgICAvLyBOb3RlOiBUaGUgY29udGFpbmVyIGVsZW1lbnQgaXRzZWxmIGlzIG5vdyBwYXNzZWQgaW4sIHNvIHdlIGRvbid0IGNyZWF0ZSBhIG5ldyBvbmUgaGVyZS5cbiAgICAgICAgLy8gV2UganVzdCBhZGQgdGhlIHNwZWNpZmljIGNsYXNzIHRvIHRoZSBwYXNzZWQgY29udGFpbmVyLlxuICAgICAgICBjb250YWluZXJFbC5hZGRDbGFzcygnaGFiaXQtbW9udGhseS1vdmVydmlldy1ncmlkJyk7XG5cblxuICAgICAgICAvLyAtLS0gSGVhZGVyIFJvdyAoSGFiaXQgTmFtZSBDb2x1bW4gSGVhZGVyICsgRGF5IE51bWJlcnMpIC0tLVxuICAgICAgICBjb25zdCBoZWFkZXJSb3cgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1ncmlkLWhlYWRlci1yb3cgbW9udGhseS1vdmVydmlldy1oZWFkZXItcm93JyB9KTtcblxuICAgICAgICAvLyBDb3JuZXIgY2VsbCBmb3IgdGhlIGhhYml0IG5hbWUgY29sdW1uIGFsaWdubWVudCAodXNlIGhhYml0LWdyaWQtaGVhZGVyLWNvcm5lcilcbiAgICAgICAgaGVhZGVyUm93LmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LWdyaWQtaGVhZGVyLWNvcm5lcicgfSk7XG5cbiAgICAgICAgLy8gRGF5IE51bWJlcnMgSGVhZGVyXG4gICAgICAgIGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgIC8vIFVzZSBtb250aGx5LW92ZXJ2aWV3LWRheS1oZWFkZXIgY2xhc3MgZm9yIHN0eWxpbmcgYWxpZ25tZW50IHdpdGggY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGRheUhlYWRlckNlbGwgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb250aGx5LW92ZXJ2aWV3LWRheS1oZWFkZXInIH0pOyAvLyBDcmVhdGUgZGlyZWN0bHkgaW4gY29udGFpbmVyRWxcbiAgICAgICAgICAgIGNvbnN0IGRhdGVNb21lbnQgPSBjdXJyZW50TW9udGguY2xvbmUoKS5kYXRlKGRheSk7IC8vIEdldCB0aGUgYWN0dWFsIG1vbWVudCBmb3IgdGhlIGRheVxuICAgICAgICAgICAgaWYgKG1vbWVudCgpLmlzU2FtZShkYXRlTW9tZW50LCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICBkYXlIZWFkZXJDZWxsLmFkZENsYXNzKCdpcy10b2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF5SGVhZGVyQ2VsbC5jcmVhdGVTcGFuKHsgdGV4dDogU3RyaW5nKGRheSksIGNsczogJ2RhaWx5LWRhdGUtbGFiZWwnIH0pOyAvLyBQdXQgbnVtYmVyIGluc2lkZSBzcGFuIHdpdGggbGFiZWwgY2xhc3NcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBEYXRhIFJvd3MgKEhhYml0IE5hbWUgKyBEYWlseSBDZWxscykgLS0tXG4gICAgICAgIGhhYml0cy5mb3JFYWNoKGhhYml0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhYml0Um93ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnaGFiaXQtZ3JpZC1yb3cgbW9udGhseS1vdmVydmlldy1oYWJpdC1yb3cnIH0pOyAvLyBDcmVhdGUgZGlyZWN0bHkgaW4gY29udGFpbmVyRWxcblxuICAgICAgICAgICAgaGFiaXRSb3cuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogaGFiaXQubmFtZSwgY2xzOiAnaGFiaXQtZ3JpZC1oYWJpdC1uYW1lJyB9KTsgLy8gUmV1c2UgaGFiaXQtZ3JpZC1oYWJpdC1uYW1lXG5cbiAgICAgICAgICAgIC8vIERhaWx5IENlbGxzIGZvciB0aGUgbW9udGhcbiAgICAgICAgICAgIGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlTW9tZW50ID0gY3VycmVudE1vbnRoLmNsb25lKCkuZGF0ZShkYXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkYXRlTW9tZW50LmZvcm1hdChkYXRlRm9ybWF0KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDZWxsID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicsIHsgLy8gQ3JlYXRlIGRpcmVjdGx5IGluIGNvbnRhaW5lckVsXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ2hhYml0LWdyaWQtY2hlY2tpbi1jZWxsIG1vbnRobHktb3ZlcnZpZXctZGF0YS1jZWxsJywgLy8gUmV1c2UgY2hlY2tpbi1jZWxsIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWhhYml0LW5hbWUnOiBoYWJpdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGRhdGVTdHJpbmcsIC8vIEFkZCBkYXRlIGF0dHJpYnV0ZSBmb3IgdXBkYXRlQ2VsbEFwcGVhcmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWhhYml0LXR5cGUnOiBoYWJpdC50eXBlLCAvLyBBZGQgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdGF0dXMgY2lyY2xlIGFuZCB2YWx1ZSBlbGVtZW50cyAqaW5zaWRlKiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NpcmNsZSA9IGRhdGFDZWxsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ3N0YXR1cy1jaXJjbGUnIH0pO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIHNwYW4gZm9yIGRpc3BsYXlpbmcgdGV4dCBuZXh0IHRvIHRoZSBjaXJjbGUgKHJldXNlIGNsYXNzKSAtIHdpbGwgYmUgaGlkZGVuIGZvciBtb3N0IHR5cGVzIG5vd1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c1ZhbHVlRGlzcGxheSA9IGRhdGFDZWxsLmNyZWF0ZVNwYW4oeyBjbHM6ICdzdGF0dXMtdmFsdWUtZGlzcGxheScgfSk7XG5cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1N0YXR1cyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVTdHJpbmddPy5baGFiaXQubmFtZV0gPz8gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdHVzRm9yQXBwZWFyYW5jZTogYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSByYXdTdGF0dXM7IC8vIERlZmF1bHQgdG8gcmF3XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShyYXdTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBudW1iZXIgaGFiaXRzLCBwYXNzIHRoZSBzdW0gb2YgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0ZvckFwcGVhcmFuY2UgPSByYXdTdGF0dXMucmVkdWNlKChzdW0sIGN1cnJlbnQpID0+IHN1bSArIGN1cnJlbnQsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGhhYml0LmZyZXF1ZW5jeSA9PT0gJ2RheScgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IHVuZGVmaW5lZCAmJiBoYWJpdC5jb21wbGV0aW9uR29hbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGRhaWx5IGJvb2xlYW4gaGFiaXRzIHdpdGggZ29hbCA+IDEsIHBhc3MgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0ZvckFwcGVhcmFuY2UgPSB0eXBlb2YgcmF3U3RhdHVzID09PSAnbnVtYmVyJyA/IHJhd1N0YXR1cyA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciB3ZWVrbHkgYm9vbGVhbiBhbmQgdGV4dCwgcGFzcyByYXdTdGF0dXNcblxuICAgICAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogQ2FsY3VsYXRlIGFuZCBwYXNzIHdlZWtseSBwZXJjZW50YWdlIGZvciBXZWVrbHkgQm9vbGVhbiBoYWJpdHMgaW4gTW9udGhseSBPdmVydmlldyAtLS1cbiAgICAgICAgICAgICAgICBsZXQgd2Vla2x5UGVyY2VudGFnZUZvckNlbGw6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaGFiaXQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGhhYml0LmZyZXF1ZW5jeSA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtTdGFydERhdGUgPSBkYXRlTW9tZW50LmNsb25lKCkuc3RhcnRPZignd2VlaycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWVrRW5kRGF0ZSA9IHdlZWtTdGFydERhdGUuY2xvbmUoKS5lbmRPZignd2VlaycpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla2x5Q29tcGxldGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IG51bGwgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gaGFiaXQuY29tcGxldGlvbkdvYWwgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXlJdGVyYXRvciA9IHdlZWtTdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRheUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHdlZWtFbmREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlTdHJpbmcgPSBkYXlJdGVyYXRvci5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRheSBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgKmRpc3BsYXllZCogbW9udGggcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaXNCZXR3ZWVuIHdpdGggZXhjbHVzaXZlIHN0YXJ0IGFuZCBpbmNsdXNpdmUgZW5kIHRvIG1hdGNoIHRoZSBtb250aCByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb21lbnQoZGF5U3RyaW5nLCBkYXRlRm9ybWF0KS5pc0JldHdlZW4oY3VycmVudE1vbnRoLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheScpLCBjdXJyZW50TW9udGguY2xvbmUoKS5lbmRPZignbW9udGgnKS5hZGQoMSwgJ2RheScpLCAnZGF5JywgJyhdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzRm9yRGF5ID0gY29tcGxldGlvbkRhdGFbZGF5U3RyaW5nXT8uW2hhYml0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzRm9yRGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlDb21wbGV0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIGRheUl0ZXJhdG9yLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2Vla2x5UGVyY2VudGFnZUZvckNlbGwgPSBjb21wbGV0aW9uR29hbCA+IDAgPyBNYXRoLm1pbigod2Vla2x5Q29tcGxldGlvbnMgLyBjb21wbGV0aW9uR29hbCkgKiAxMDAsIDEwMCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIE1vbnRobHkgT3ZlcnZpZXcgQ2VsbDogXCIke2hhYml0Lm5hbWV9XCIgb24gJHtkYXRlU3RyaW5nfSwgV2Vla2x5ICU6ICR7d2Vla2x5UGVyY2VudGFnZUZvckNlbGwudG9GaXhlZCgxKX1gKTsgLy8gTG9nIHdlZWtseSBwZXJjZW50YWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC0tLSBFTkQgTU9ESUZJRUQgLS0tXG5cblxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIGNhbGN1bGF0ZWQgd2Vla2x5IHBlcmNlbnRhZ2UgKGlmIGFwcGxpY2FibGUpIHRvIHVwZGF0ZUNlbGxBcHBlYXJhbmNlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDZWxsQXBwZWFyYW5jZShkYXRhQ2VsbCwgaGFiaXQsIHN0YXR1c0ZvckFwcGVhcmFuY2UsIHdlZWtseVBlcmNlbnRhZ2VGb3JDZWxsKTsgLy8gUGFzcyB3ZWVrbHlQZXJjZW50YWdlXG5cblxuICAgICAgICAgICAgICAgIGlmIChtb21lbnQoKS5pc1NhbWUoZGF0ZVN0cmluZywgJ2RheScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDZWxsLmFkZENsYXNzKCdpcy10b2RheScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjbGljayBldmVudCBsaXN0ZW5lciAtIENsaWNraW5nIG9wZW5zIG1vZGFsIG9yIHRvZ2dsZXMgYm9vbGVhbiAoU2FtZSBsb2dpYyBhcyBjaGVjay1pbiBncmlkKVxuICAgICAgICAgICAgICAgIGRhdGFDZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2VkSGFiaXROYW1lID0gZGF0YUNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhYml0LW5hbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZERhdGUgPSBkYXRhQ2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2VkSGFiaXRUeXBlID0gZGF0YUNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhYml0LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZEhhYml0ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzLmZpbmQoaCA9PiBoLm5hbWUgPT09IGNsaWNrZWRIYWJpdE5hbWUpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGlja2VkSGFiaXROYW1lIHx8ICFjbGlja2VkRGF0ZSB8fCAhY2xpY2tlZEhhYml0VHlwZSB8fCAhY2xpY2tlZEhhYml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2xpY2tlZCBjZWxsIG1pc3NpbmcgZGF0YSBhdHRyaWJ1dGVzIG9yIGhhYml0IG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2NsaWNrZWREYXRlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgYmFzZWQgb24gaGFiaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpY2tlZEhhYml0VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBjbGlja2VkSGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gY2xpY2tlZEhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTsgLy8gRGVmYXVsdCBnb2FsIHRvIDFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrZWRIYWJpdC5mcmVxdWVuY3kgPT09ICdkYXknICYmIGNvbXBsZXRpb25Hb2FsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhaWx5IGJvb2xlYW4gd2l0aCBnb2FsID4gMTogSW5jcmVtZW50IGNvdW50LCByZXNldCBpZiBnb2FsIHJlYWNoZWQvZXhjZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvdW50ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIG51bWJlciB8IG51bGwgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q291bnQgPSBjdXJyZW50Q291bnQgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV3IGNvdW50IGV4Y2VlZHMgZ29hbCwgcmVzZXQgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA+IGNvbXBsZXRpb25Hb2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV1bY2xpY2tlZEhhYml0TmFtZV0gPSBuZXdDb3VudCA+IDAgPyBuZXdDb3VudCA6IG51bGw7IC8vIFN0b3JlIG51bGwgaWYgY291bnQgaXMgMFxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90aWNlTWVzc2FnZSA9IGAke2NsaWNrZWRIYWJpdE5hbWV9IG9uICR7Y2xpY2tlZERhdGV9OiBgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpY2VNZXNzYWdlICs9ICdDb3VudCByZXNldC4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGljZU1lc3NhZ2UgKz0gYENvdW50OiAke25ld0NvdW50fS8ke2NvbXBsZXRpb25Hb2FsfS5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKG5vdGljZU1lc3NhZ2UsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYWlseSBib29sZWFuIHdpdGggZ29hbCA8PSAxLCBvciBXZWVrbHkgYm9vbGVhbjogVG9nZ2xlIHRydWUvbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEZvciB3ZWVrbHksIGNsaWNraW5nIG1hcmtzIHRoZSBkYXkgYXMgXCJjb21wbGV0ZWRcIiAodHJ1ZSkgdG93YXJkcyB0aGUgd2Vla2x5IGdvYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2NsaWNrZWREYXRlXVtjbGlja2VkSGFiaXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhdHVzOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXR1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0dXMgPSBudWxsOyAvLyBDbGlja2luZyBvbiBjb21wbGV0ZWQgY2xlYXJzIHRoZSBlbnRyeSBmb3IgdGhpcyBkYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBjdXJyZW50U3RhdHVzIGlzIGZhbHNlLCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0dXMgPSB0cnVlOyAvLyBDbGlja2luZyBvbiBpbmNvbXBsZXRlIG9yIG5vIGVudHJ5IG1hcmtzIGFzIGNvbXBsZXRlZCBmb3IgdGhpcyBkYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdID0gbmV3U3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdGljZU1lc3NhZ2UgPSBgJHtjbGlja2VkSGFiaXROYW1lfSBvbiAke2NsaWNrZWREYXRlfSBgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0dXMgPT09IHRydWUpIG5vdGljZU1lc3NhZ2UgKz0gJ21hcmtlZCBhcyBDb21wbGV0ZWQuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIG5vdGljZU1lc3NhZ2UgKz0gJ2VudHJ5IGNsZWFyZWQuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKG5vdGljZU1lc3NhZ2UsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gTU9ESUZJRUQ6IE9ubHkgcmUtcmVuZGVyIHRoZSBtb250aGx5IG92ZXJ2aWV3IGdyaWQgLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9udGhseU92ZXJ2aWV3R3JpZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1vbnRobHlPdmVydmlld0dyaWQodGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIEVORCBNT0RJRklFRCAtLS1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWNrZWRIYWJpdFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIE51bWJlciBJbnB1dCBNb2RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE51bWJlcklucHV0TW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLCBjbGlja2VkRGF0ZSwgY2xpY2tlZEhhYml0TmFtZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIG51bWJlcltdIHwgbnVsbCwgLy8gUGFzcyByYXcgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7IC8vIENhbGxiYWNrIGFmdGVyIHNhdmUvY2xlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIE1PRElGSUVEOiBPbmx5IHJlLXJlbmRlciB0aGUgbW9udGhseSBvdmVydmlldyBncmlkIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9udGhseU92ZXJ2aWV3R3JpZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTW9udGhseU92ZXJ2aWV3R3JpZCh0aGlzLm1vbnRobHlPdmVydmlld0dyaWRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIEVORCBNT0RJRklFRCAtLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGlja2VkSGFiaXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gVGV4dCBJbnB1dCBNb2RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRJbnB1dE1vZGFsKHRoaXMuYXBwLCB0aGlzLnBsdWdpbiwgY2xpY2tlZERhdGUsIGNsaWNrZWRIYWJpdE5hbWUsIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2NsaWNrZWREYXRlXVtjbGlja2VkTmFtZV0gYXMgc3RyaW5nIHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4geyAvLyBDYWxsYmFjayBhZnRlciBzYXZlL2NsZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogT25seSByZS1yZW5kZXIgdGhlIG1vbnRobHkgb3ZlcnZpZXcgZ3JpZCAtLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vbnRobHlPdmVydmlld0dyaWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1vbnRobHlPdmVydmlld0dyaWQodGhpcy5tb250aGx5T3ZlcnZpZXdHcmlkQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBFTkQgTU9ESUZJRUQgLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW9kaWZpZWQ6IFJldmVydCB0byAxZnIgY29sdW1ucyBmb3IgZmxleGlibGUgc2l6aW5nLCBzZXQgZ2FwIGluIEpTXG4gICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uV2lkdGggPSAnYXV0byc7IC8vIExldCB0aGUgZmlyc3QgY29sdW1uIHNpemUgaXRzZWxmIGJhc2VkIG9uIGNvbnRlbnQgKGhhYml0IG5hbWVzKVxuICAgICAgICBjb25zdCBjb2x1bW5HYXAgPSAnNHB4JzsgLy8gTW9kaWZpZWQ6IEluY3JlYXNlZCBnYXAgZm9yIG1vbnRobHkgb3ZlcnZpZXcgY2lyY2xlc1xuXG4gICAgICAgIGNvbnRhaW5lckVsLnN0eWxlLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBgJHtmaXJzdENvbHVtbldpZHRofSByZXBlYXQoJHtkYXlzSW5Nb250aH0sIDFmcilgO1xuICAgICAgICBjb250YWluZXJFbC5zdHlsZS5nYXAgPSBjb2x1bW5HYXA7IC8vIFNldCB0aGUgZ2FwIG9uIHRoZSBncmlkIGNvbnRhaW5lclxuXG5cbiAgICB9XG5cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIHZpc3VhbCBzdGF0ZSBvZiBhIGNlbGwncyBjb250ZW50IChzaGFyZWQgbG9naWMpXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBub3cgaGFuZGxlcyBjb2xvciBiYXNlZCBvbiBjb21wbGV0aW9uIGNvdW50IHZzIGdvYWwgZm9yIGJvb2xlYW4gaGFiaXRzXG4gICAgLy8gVGhlICdzdGF0dXMnIHBhcmFtZXRlciBub3cgcmVwcmVzZW50czpcbiAgICAvLyAtIERhaWx5IEJvb2xlYW4gKGdvYWwgPD0gMSk6IGJvb2xlYW4gKHRydWUvbnVsbClcbiAgICAvLyAtIERhaWx5IEJvb2xlYW4gKGdvYWwgPiAxKTogbnVtYmVyIChjb3VudClcbiAgICAvLyAtIFdlZWtseSBCb29sZWFuOiBib29sZWFuICh0cnVlL251bGwpIC0gTmVlZHMgdG8gY2FsY3VsYXRlIHdlZWtseSBwcm9ncmVzcyBpbnRlcm5hbGx5IHVzaW5nIHJhdyBkYXRhIChPUiByZWNlaXZlcyBwZXJjZW50YWdlIGZvciBoZWF0bWFwKVxuICAgIC8vIC0gTnVtYmVyOiBudW1iZXIgKHN1bSBvZiBkYWlseSBlbnRyaWVzKVxuICAgIC8vIC0gVGV4dDogc3RyaW5nICh0ZXh0IGVudHJ5KVxuICAgIC8vIEFkZGVkIG9wdGlvbmFsIHdlZWtseVBlcmNlbnRhZ2UgcGFyYW1ldGVyIGZvciBoZWF0bWFwIGNlbGxzIChub3cgYWxzbyB1c2VkIGZvciBub24taGVhdG1hcCB3ZWVrbHkgYm9vbGVhbilcbiAgICB1cGRhdGVDZWxsQXBwZWFyYW5jZShjZWxsRWw6IEhUTUxFbGVtZW50LCBoYWJpdDogSGFiaXQsIHN0YXR1czogYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlciB8IG51bGwsIHdlZWtseVBlcmNlbnRhZ2U/OiBudW1iZXIpIHsgLy8gUmVuYW1lZCBwYXJhbWV0ZXIgZm9yIGNsYXJpdHlcbiAgICAgICAgY29uc3QgaXNIZWF0bWFwQ2VsbCA9IGNlbGxFbC5oYXNDbGFzcygnaGVhdG1hcC1jZWxsJyk7IC8vIENoZWNrIGlmIHRoaXMgaXMgYSBoZWF0bWFwIGNlbGxcbiAgICAgICAgLy8gR2V0IHRoZSBzdGF0dXMgY2lyY2xlIGFuZCB2YWx1ZSBlbGVtZW50cyAqaW5zaWRlKiB0aGUgY2VsbCBmb3Igbm9uLWhlYXRtYXAgdmlld3NcbiAgICAgICAgY29uc3Qgc3RhdHVzQ2lyY2xlRWwgPSBpc0hlYXRtYXBDZWxsID8gbnVsbCA6IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuc3RhdHVzLWNpcmNsZScpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBjb25zdCBzdGF0dXNWYWx1ZURpc3BsYXlFbCA9IGlzSGVhdG1hcENlbGwgPyBudWxsIDogY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5zdGF0dXMtdmFsdWUtZGlzcGxheScpIGFzIEhUTUxFbGVtZW50OyAvLyBSZW5hbWVkIHRvIGF2b2lkIGNvbmZsaWN0XG5cblxuICAgICAgICBpZiAoIWlzSGVhdG1hcENlbGwgJiYgKCFzdGF0dXNDaXJjbGVFbCB8fCAhc3RhdHVzVmFsdWVEaXNwbGF5RWwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBzdGF0dXMgY2lyY2xlIG9yIHZhbHVlIGRpc3BsYXkgZWxlbWVudCBpbiBub24taGVhdG1hcCBjZWxsIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgZWxlbWVudCB0byBhcHBseSBjbGFzc2VzIHRvIChjZWxsIGl0c2VsZiBmb3IgaGVhdG1hcCwgY2lyY2xlIGluc2lkZSBmb3Igb3RoZXJzKVxuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IGlzSGVhdG1hcENlbGwgPyBjZWxsRWwgOiBzdGF0dXNDaXJjbGVFbDtcblxuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBzdGF0ZSBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGVzIGZyb20gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgICAgJ2lzLWJvb2xlYW4nLCAnaXMtbW9vZCcsICdpcy10ZXh0JyxcbiAgICAgICAgICAgICAgICAnaGFzLXZhbHVlJywgJ2hhcy1lbW9qaScsXG4gICAgICAgICAgICAgICAgJ2dvYWwtbWV0JywgJ2dvYWwtcHJvZ3Jlc3MtemVybycsICdnb2FsLXByb2dyZXNzLW1lZGl1bScsICdnb2FsLXByb2dyZXNzLWhpZ2gnLCAnaGFzLXZhbHVlLW5vLWdvYWwnLFxuICAgICAgICAgICAgICAgICdpcy1pbmNvbXBsZXRlJywgJ2lzLWNvbXBsZXRlZCcsIC8vIEV4aXN0aW5nIGJvb2xlYW4gc3RhdGVzXG4gICAgICAgICAgICAgICAgLy8gQm9vbGVhbiBwcm9ncmVzcyBzdGF0ZXNcbiAgICAgICAgICAgICAgICAncHJvZ3Jlc3MtbG93JywgJ3Byb2dyZXNzLW1lZGl1bScsICdwcm9ncmVzcy1oaWdoJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIENsZWFyIGlubGluZSBzdHlsZXMgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgIHRhcmdldEVsLnN0eWxlLmJvcmRlciA9ICcnO1xuICAgICAgICAgICAgdGFyZ2V0RWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICAgICAgICB0YXJnZXRFbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJzsgLy8gRW5zdXJlIGJhY2tncm91bmQgaW1hZ2UgaXMgY2xlYXJlZFxuICAgICAgICAgICAgdGFyZ2V0RWwuc3R5bGUub3BhY2l0eSA9ICcnOyAvLyBSZXNldCBvcGFjaXR5IGZvciBib29sZWFuIHByb2dyZXNzXG4gICAgICAgICAgICAvLyB0YXJnZXRFbC5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vIFJlc2V0IGRpc3BsYXkgZm9yIHRoZSBlbGVtZW50IGl0c2VsZiAobmVlZGVkIGZvciBub24taGVhdG1hcCBjaXJjbGVzKSAtIGhhbmRsZWQgYnkgQ1NTIGRlZmF1bHQgbm93XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENsZWFyIGNvbnRlbnQgaW5zaWRlIHRoZSBjaXJjbGUgZm9yIG5vbi1oZWF0bWFwIHZpZXdzXG4gICAgICAgIGlmIChzdGF0dXNDaXJjbGVFbCkge1xuICAgICAgICAgICAgc3RhdHVzQ2lyY2xlRWwuZW1wdHkoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQ2xlYXIgY29udGVudCBhbmQgaGlkZSB2YWx1ZSBzcGFuIGZvciBub24taGVhdG1hcCB2aWV3c1xuICAgICAgICBpZiAoc3RhdHVzVmFsdWVEaXNwbGF5RWwpIHsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgc3RhdHVzVmFsdWVEaXNwbGF5RWwuZW1wdHkoKTtcbiAgICAgICAgICAgIHN0YXR1c1ZhbHVlRGlzcGxheUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWJvb2xlYW4nKTtcblxuICAgICAgICAgICAgY29uc3QgY29tcGxldGlvbkdvYWwgPSBoYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSBudWxsICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsID4gMCA/IGhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTsgLy8gRGVmYXVsdCBnb2FsIHRvIDEgaWYgbm90IHNldCBvciA8PSAwXG5cbiAgICAgICAgICAgIGlmIChoYWJpdC5mcmVxdWVuY3kgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGRhaWx5IGJvb2xlYW4sIHN0YXR1cyBpcyB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb25zIChpZiBnb2FsID4gMSkgb3IgYm9vbGVhbiAoaWYgZ29hbCA8PSAxKVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29tcGxldGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uR29hbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbXBsZXRpb25zID0gdHlwZW9mIHN0YXR1cyA9PT0gJ251bWJlcicgPyBzdGF0dXMgOiAwOyAvLyBHZXQgY291bnQgZnJvbSBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBjb21wbGV0aW9uIGNvdW50IG5leHQgdG8gY2lyY2xlIGZvciBkYWlseSBib29sZWFuIHdpdGggZ29hbCA+IDEgYW5kIGNvdW50ID4gMCAob25seSBpbiBub24taGVhdG1hcClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0hlYXRtYXBDZWxsICYmIHN0YXR1c1ZhbHVlRGlzcGxheUVsICYmIGN1cnJlbnRDb21wbGV0aW9ucyA+IDApIHsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVmFsdWVEaXNwbGF5RWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvLyBVc2UgY29ycmVjdCB2YXJpYWJsZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNWYWx1ZURpc3BsYXlFbC5zZXRUZXh0KFN0cmluZyhjdXJyZW50Q29tcGxldGlvbnMpKTsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gRGFpbHkgZ29hbCBpcyAxIChvciBkZWZhdWx0IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb21wbGV0aW9ucyA9IHN0YXR1cyA9PT0gdHJ1ZSA/IDEgOiAwOyAvLyBTdGF0dXMgaXMgdHJ1ZS9udWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29sb3JpbmcvY2xhc3NlcyBiYXNlZCBvbiBkYWlseSBjb21wbGV0aW9uIHZzIGdvYWwgKGZvciBkYWlseSkgb3Igc2ltcGx5IGNvbXBsZXRpb24gc3RhdHVzIChmb3IgZGFpbHkgZ29hbCA8PSAxKVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29tcGxldGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2hhcy12YWx1ZScpOyAvLyBJbmRpY2F0ZSBpdCBoYXMgYSB2YWx1ZSAoY29tcGxldGlvbiBjb3VudCA+IDAgb3IgdHJ1ZSlcblxuICAgICAgICAgICAgICAgICAgICAvLyBEYWlseSBnb2FsID4gMTogQ29sb3IgYmFzZWQgb24gZGFpbHkgY291bnQgdnMgZGFpbHkgZ29hbFxuICAgICAgICAgICAgICAgICAgICAvLyBEYWlseSBnb2FsIDw9IDE6IENvbG9yIGlzIGp1c3QgY29tcGxldGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uR29hbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBjb21wbGV0aW9uR29hbCA+IDAgPyBNYXRoLm1pbigoY3VycmVudENvbXBsZXRpb25zIC8gY29tcGxldGlvbkdvYWwpICogMTAwLCAxMDApIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50YWdlID49IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2dvYWwtbWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ3Byb2dyZXNzLWhpZ2gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudGFnZSA+IDMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygncHJvZ3Jlc3MtbWVkaXVtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiAwKSB7IC8vIHBlcmNlbnRhZ2UgPiAwIGFuZCA8PSAzM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ3Byb2dyZXNzLWxvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBEYWlseSBnb2FsIDw9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWNvbXBsZXRlZCcpOyAvLyBVc2Ugc2ltcGxlIGNvbXBsZXRlZCBzdHlsZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gY3VycmVudENvbXBsZXRpb25zIGlzIDAgKHN0YXR1cyB3YXMgbnVsbCBvciBmYWxzZSwgb3IgZGFpbHkgY291bnQgd2FzIDApXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWluY29tcGxldGUnKTsgLy8gVHJlYXQgYXMgaW5jb21wbGV0ZSB2aXN1YWxseVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBmcmVxdWVuY3kgPT09ICd3ZWVrJ1xuICAgICAgICAgICAgICAgIC8vIEZvciB3ZWVrbHkgYm9vbGVhbiwgc3RhdHVzIGlzIGJvb2xlYW4gKmZvciB0aGUgZGF5KiAodHJ1ZS9udWxsKS5cbiAgICAgICAgICAgICAgICBjb25zdCBkYWlseVN0YXR1cyA9IHN0YXR1cyA9PT0gdHJ1ZTsgLy8gQ2hlY2sgaWYgVEhJUyBzcGVjaWZpYyBkYXkgaXMgbWFya2VkIHRydWVcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcGFzc2VkIHdlZWtseVBlcmNlbnRhZ2UgZm9yIGNvbG9yaW5nLCByZWdhcmRsZXNzIG9mIGhlYXRtYXAgb3Igbm9uLWhlYXRtYXBcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gd2Vla2x5UGVyY2VudGFnZSAhPT0gdW5kZWZpbmVkID8gd2Vla2x5UGVyY2VudGFnZSA6IDA7IC8vIFVzZSB0aGUgcGFzc2VkIHdlZWtseSBwZXJjZW50YWdlXG5cblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQ2VsbDogXCIke2hhYml0Lm5hbWV9XCIgb24gJHtjZWxsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRhdGUnKX0sIGlzSGVhdG1hcDogJHtpc0hlYXRtYXBDZWxsfSwgRGFpbHk6ICR7ZGFpbHlTdGF0dXN9LCBXZWVrbHkgJTogJHtwZXJjZW50YWdlLnRvRml4ZWQoMSl9YCk7IC8vIExvZyB2YWx1ZXNcblxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29sb3IgY2xhc3NlcyBiYXNlZCBvbiBXRUVLTFkgY29tcGxldGlvbiBwZXJjZW50YWdlXG4gICAgICAgICAgICAgICAgLy8gLS0tIE1PRElGSUVEOiBPbmx5IGFwcGx5IGNvbG9yIGNsYXNzZXMgaWYgZGFpbHlTdGF0dXMgaXMgdHJ1ZSAtLS1cbiAgICAgICAgICAgICAgICBpZiAoZGFpbHlTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50YWdlID49IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRDbGFzcygnZ29hbC1tZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBBcHBseWluZyBnb2FsLW1ldCBjbGFzcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRDbGFzcygncHJvZ3Jlc3MtaGlnaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIEFwcGx5aW5nIHByb2dyZXNzLWhpZ2ggY2xhc3MuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50YWdlID4gMzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkQ2xhc3MoJ3Byb2dyZXNzLW1lZGl1bScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIEFwcGx5aW5nIHByb2dyZXNzLW1lZGl1bSBjbGFzcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRDbGFzcygncHJvZ3Jlc3MtbG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQXBwbHlpbmcgcHJvZ3Jlc3MtbG93IGNsYXNzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHBlcmNlbnRhZ2UgaXMgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBwcm9ncmVzcyBjbGFzcyBuZWVkZWQsIGRlZmF1bHQgaW5jb21wbGV0ZSBzdGF0ZSB3aWxsIGFwcGx5IGJvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIE5vIHByb2dyZXNzIGNsYXNzZXMgYXBwbGllZCAocGVyY2VudGFnZSBpcyAwKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGFpbHlTdGF0dXMgaXMgbnVsbC9mYWxzZSwgcmVtb3ZlIGFueSBwb3RlbnRpYWwgY29sb3IgY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw/LnJlbW92ZUNsYXNzKCdnb2FsLW1ldCcsICdwcm9ncmVzcy1oaWdoJywgJ3Byb2dyZXNzLW1lZGl1bScsICdwcm9ncmVzcy1sb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gRGFpbHkgc3RhdHVzIGlzIG5vdCB0cnVlLCByZW1vdmluZyBjb2xvciBjbGFzc2VzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLS0gRU5EIE1PRElGSUVEIC0tLVxuXG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBib3JkZXIgYmFzZWQgb24gREFJTFkgc3RhdHVzIG9uIHRoZSB0YXJnZXQgZWxlbWVudCAoY2VsbCBmb3IgaGVhdG1hcCwgY2lyY2xlIGZvciBvdGhlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGRhaWx5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZENsYXNzKCdoYXMtdmFsdWUnKTsgLy8gSW5kaWNhdGVzIGl0IHdhcyBjaGVja2VkIChmb3Igc29saWQgYm9yZGVyIGluIENTUylcbiAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVDbGFzcygnaXMtaW5jb21wbGV0ZScpOyAvLyBFbnN1cmUgaW5jb21wbGV0ZSBzdHlsZSBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBBcHBseWluZyBoYXMtdmFsdWUgY2xhc3MuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRDbGFzcygnaXMtaW5jb21wbGV0ZScpOyAvLyBJbmRpY2F0ZXMgaXQgd2FzIE5PVCBjaGVja2VkIChmb3IgZGFzaGVkIGJvcmRlciBpbiBDU1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2xhc3MoJ2hhcy12YWx1ZScpOyAvLyBFbnN1cmUgaGFzLXZhbHVlIHN0eWxlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIEFwcGx5aW5nIGlzLWluY29tcGxldGUgY2xhc3MuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3Igbm9uLWhlYXRtYXAsIHdlIG1pZ2h0IHN0aWxsIHdhbnQgdG8gc2hvdyBzb21ldGhpbmcgaW4gdGhlIGNpcmNsZSBpZiBkYWlseVN0YXR1cyBpcyB0cnVlXG4gICAgICAgICAgICAgICAgIGlmICghaXNIZWF0bWFwQ2VsbCAmJiBzdGF0dXNDaXJjbGVFbCAmJiBkYWlseVN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZXhwbGljaXQgY29udGVudCBuZWVkZWQsIGNvbG9yIGlzIHRoZSBpbmRpY2F0b3IuXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIEZvciBudW1iZXIsIGluZGljYXRlIHByZXNlbmNlIG9mIHZhbHVlIGFuZCBnb2FsIGNvbXBsZXRpb24gc3RhdHVzXG4gICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHRhcmdldEVsLmFkZENsYXNzKCdpcy1tb29kJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YXR1cyBoZXJlIGlzIHRoZSAqc3VtKiBvZiB0aGUgYXJyYXkgZm9yIHRoZSBkYXkgKHBhc3NlZCBmcm9tIHJlbmRlciBmdW5jdGlvbnMpXG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdGF0dXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgaGFzLXZhbHVlIGlmIHRoZSBzdW0gaXMgPiAwLCBvciBpZiB0aGUgc3VtIGlzIDAgYnV0IHRoZXJlIGlzIGEgZ29hbCAoZ29hbC1wcm9ncmVzcy16ZXJvIGNhc2UpXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoZWxwcyBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5vIGVudHJ5IGFuZCBhbiBleHBsaWNpdCAwIGVudHJ5LlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPiAwIHx8IChzdGF0dXMgPT09IDAgJiYgaGFiaXQuZ29hbCAhPT0gdW5kZWZpbmVkICYmIGhhYml0LmdvYWwgIT09IG51bGwgJiYgaGFiaXQuZ29hbCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2hhcy12YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gLS0tIERpc3BsYXkgbnVtYmVyIHZhbHVlIG5leHQgdG8gY2lyY2xlIGZvciBjaGVjay1pbi9tb250aGx5IG92ZXJ2aWV3IChub24taGVhdG1hcCkgLS0tXG4gICAgICAgICAgICAgICAgaWYgKCFpc0hlYXRtYXBDZWxsICYmIHN0YXR1c1ZhbHVlRGlzcGxheUVsKSB7IC8vIFVzZSBjb3JyZWN0IHZhcmlhYmxlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVmFsdWVEaXNwbGF5RWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvLyBVc2UgY29ycmVjdCB2YXJpYWJsZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1ZhbHVlRGlzcGxheUVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiBzdGF0dXMudG9GaXhlZCgyKSArIChoYWJpdC51bml0IHx8ICcnKSB9KTsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChoYWJpdC5nb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuZ29hbCAhPT0gbnVsbCAmJiBoYWJpdC5nb2FsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gTWF0aC5taW4oKHN0YXR1cyAvIGhhYml0LmdvYWwpICogMTAwLCAxMDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYmFzZWQgb24gcGVyY2VudGFnZSBjb21wbGV0aW9uIGZvciBOVU1CRVIgaGFiaXRzXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPj0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2dvYWwtbWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiA1MCkgeyAvLyBFeGFtcGxlIHRocmVzaG9sZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnZ29hbC1wcm9ncmVzcy1oaWdoJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPiAwKSB7IC8vIEV4YW1wbGUgdGhyZXNob2xkc1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHRhcmdldEVsLmFkZENsYXNzKCdnb2FsLXByb2dyZXNzLW1lZGl1bScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgQ1NTIGZvciBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDAgJiYgKGhhYml0LmdvYWwgIT09IHVuZGVmaW5lZCAmJiBoYWJpdC5nb2FsICE9PSBudWxsICYmIGhhYml0LmdvYWwgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOdW1iZXIgaXMgMCBidXQgaGFzIGEgZ29hbCA+IDBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnZ29hbC1wcm9ncmVzcy16ZXJvJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJvcmRlci9iYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPiAwICYmIChoYWJpdC5nb2FsID09PSB1bmRlZmluZWQgfHwgaGFiaXQuZ29hbCA9PT0gbnVsbCB8fCBoYWJpdC5nb2FsIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE51bWJlciA+IDAgYnV0IG5vIGdvYWwgc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2hhcy12YWx1ZS1uby1nb2FsJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJvcmRlci9iYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhdHVzIGlzIDAgYW5kIG5vIGdvYWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnaXMtaW5jb21wbGV0ZScpOyAvLyBVc2UgaW5jb21wbGV0ZSBzdHlsZVxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgQ1NTIGZvciBib3JkZXIvYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzIGlzIG51bGwvdW5kZWZpbmVkIGZvciBudW1iZXIgdHlwZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWluY29tcGxldGUnKTsgLy8gVXNlIGluY29tcGxldGUgc3R5bGVcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVmFsdWVEaXNwbGF5RWwpIHN0YXR1c1ZhbHVlRGlzcGxheUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIFVzZSBjb3JyZWN0IHZhcmlhYmxlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHRhcmdldEVsLnJlbW92ZUNsYXNzKCdoYXMtZW1vamknKTsgLy8gUmVkdW5kYW50IGZvciBudW1iZXIgdHlwZSBidXQgc2FmZVxuICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJvcmRlci9iYWNrZ3JvdW5kXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9IGVsc2UgaWYgKGhhYml0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnaXMtdGV4dCcpO1xuICAgICAgICAgICAgLy8gVGhlIHRleHQgY29udGVudC9lbW9qaSBpcyBhZGRlZCBpbiByZW5kZXJTdGF0cyBmb3IgaGVhdG1hcCBjZWxscy5cbiAgICAgICAgICAgIC8vIEZvciBub24taGVhdG1hcCBjZWxscywgdGhlIHRleHQgaXMgYWRkZWQgdG8gc3RhdHVzVmFsdWVEaXNwbGF5RWwgaGVyZS5cblxuXG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdGF0dXMgPT09ICdzdHJpbmcnICYmIHN0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnaGFzLXZhbHVlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZXh0IGRpc3BsYXkgaXMgaGFuZGxlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiBoZWF0bWFwIHZzIG5vbi1oZWF0bWFwXG4gICAgICAgICAgICAgICAgaWYgKCFpc0hlYXRtYXBDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vbi1oZWF0bWFwIChDaGVjay1pbiwgTW9udGhseSBPdmVydmlldyk6IERpc3BsYXkgdGV4dC9lbW9qaSAqbmV4dCB0byogdGhlIGNpcmNsZSBvciAqaW5zaWRlKiB0aGUgY2lyY2xlIGlmIGVtb2ppXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTGlrZWx5RW1vamkgPSBzdGF0dXMubGVuZ3RoID4gMCAmJiBzdGF0dXMubGVuZ3RoIDw9IDQ7IC8vIFNpbXBsZSBoZXVyaXN0aWNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaWtlbHlFbW9qaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ2lyY2xlRWw/LmVtcHR5KCk7IC8vIENsZWFyIGRlZmF1bHQgY2lyY2xlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NpcmNsZUVsPy5jcmVhdGVTcGFuKHsgdGV4dDogc3RhdHVzLCBjbHM6ICdzdGF0dXMtZW1vamknIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NpcmNsZUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ2lyY2xlRWwuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NpcmNsZUVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVmFsdWVEaXNwbGF5RWwpIHN0YXR1c1ZhbHVlRGlzcGxheUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEhpZGUgdmFsdWUgc3BhbiBmb3IgZW1vamlzIGluc2lkZSBjaXJjbGUgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsKSB0YXJnZXRFbC5hZGRDbGFzcygnaGFzLWVtb2ppJyk7IC8vIEFkZCBoYXMtZW1vamkgY2xhc3MgKGFwcGxpZXMgdG8gY2VsbEVsL3RhcmdldEVsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGp1c3QgYW4gZW1vamksIGRpc3BsYXkgdGV4dCBuZXh0IHRvIHRoZSBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDaXJjbGVFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NpcmNsZUVsLnN0eWxlLmJvcmRlciA9ICcycHggZGFzaGVkIHZhcigtLXRleHQtYWNjZW50KSc7IC8vIEtlZXAgZGFzaGVkIGJvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NpcmNsZUVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVmFsdWVEaXNwbGF5RWwpIHsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1ZhbHVlRGlzcGxheUVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8gU2hvdyB2YWx1ZSBzcGFuIGZvciB0ZXh0IC8vIFVzZSBjb3JyZWN0IHZhcmlhYmxlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNWYWx1ZURpc3BsYXlFbC5jcmVhdGVTcGFuKHsgdGV4dDogc3RhdHVzIH0pOyAvLyBVc2UgY29ycmVjdCB2YXJpYWJsZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHRhcmdldEVsLnJlbW92ZUNsYXNzKCdoYXMtZW1vamknKTsgLy8gUmVtb3ZlIGhhcy1lbW9qaSBjbGFzc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBoZWF0bWFwLCB0ZXh0L2Vtb2ppIGlzIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSBjZWxsIGluIHJlbmRlclN0YXRzLlxuICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBvbmx5IG5lZWRzIHRvIGFwcGx5IGNsYXNzZXMgZm9yIGNvbG9yaW5nICh3aGljaCBpcyBqdXN0IHByZXNlbmNlL2Fic2VuY2UgZm9yIHRleHQpLlxuICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgYC5oZWF0bWFwLWNlbGxgIHN0eWxlIGlzIHRoZSBpbmNvbXBsZXRlIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGAuaGVhdG1hcC1jZWxsLmlzLXRleHQuaGFzLXZhbHVlYCBzdHlsZSBoYW5kbGVzIHRoZSAncHJlc2VudCcgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBhbnkgb3RoZXIgcHJvZ3Jlc3MgY2xhc3NlcyBmb3IgdGV4dCBoZWF0bWFwcy5cbiAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBoYXMtZW1vamkgY2xhc3MgZm9yIGhlYXRtYXAgY2VsbHMgaXMgYXBwbGllZCBpbiByZW5kZXJTdGF0cyBhcyB3ZWxsLlxuXG4gICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBoZWF0bWFwLCBpZiBzdGF0dXMgaXMgcHJlc2VudCwgYWRkIGhhcy12YWx1ZS4gT3RoZXJ3aXNlLCBpdCdzIGluY29tcGxldGUgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gSGVhdG1hcCBDZWxsOiBcIiR7aGFiaXQubmFtZX1cIiBvbiAke2NlbGxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF0ZScpfSwgU3RhdHVzOiBcIiR7c3RhdHVzfVwiYCk7IC8vIExvZyB0ZXh0IHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gbnVsbCAmJiBzdGF0dXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJyAmJiBzdGF0dXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRDbGFzcygnaGFzLXZhbHVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUNsYXNzKCdpcy1pbmNvbXBsZXRlJyk7IC8vIEVuc3VyZSBpbmNvbXBsZXRlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBBcHBseWluZyBoYXMtdmFsdWUgY2xhc3MuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWluY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2xhc3MoJ2hhcy12YWx1ZScpOyAvLyBFbnN1cmUgaGFzLXZhbHVlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBBcHBseWluZyBpcy1pbmNvbXBsZXRlIGNsYXNzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2lzLWluY29tcGxldGUnKTsgLy8gVXNlIGluY29tcGxldGUgc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2xhc3MoJ2hhcy12YWx1ZScpOyAvLyBFbnN1cmUgaGFzLXZhbHVlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBBcHBseWluZyBpcy1pbmNvbXBsZXRlIGNsYXNzIChzdGF0dXMgaXMgbnVsbC9lbXB0eSkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNWYWx1ZURpc3BsYXlFbCkgc3RhdHVzVmFsdWVEaXNwbGF5RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gVXNlIGNvcnJlY3QgdmFyaWFibGUgbmFtZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCkgdGFyZ2V0RWwucmVtb3ZlQ2xhc3MoJ2hhcy1lbW9qaScpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBDU1MgZm9yIGJvcmRlci9iYWNrZ3JvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBjZW50ZXJpbmcgc3R5bGVzIGRpcmVjdGx5IHRvIHRoZSBjZWxsIGZvciBub24taGVhdG1hcCB2aWV3c1xuICAgICAgICBpZiAoIWlzSGVhdG1hcENlbGwpIHtcbiAgICAgICAgICAgIGNlbGxFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgY2VsbEVsLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICAgICAgICAgIGNlbGxFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInOyAvLyBDZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICBjZWxsRWwuc3R5bGUuZ2FwID0gJzRweCc7IC8vIFJlLWFkZGVkIGdhcCBmb3IgZWxlbWVudHMgKmluc2lkZSogdGhlIGNlbGwgZm9yIGNoZWNrLWluL21vbnRobHkgb3ZlcnZpZXdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBoZWF0bWFwIGNlbGxzLCB0aGUgY2VudGVyaW5nL3NpemluZyBpcyBoYW5kbGVkIGJ5IGl0cyBvd24gQ1NTICguaGVhdG1hcC1jZWxsKVxuICAgICAgICAgICAgY2VsbEVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIEVuc3VyZSBmbGV4Ym94IGlzIHVzZWRcbiAgICAgICAgICAgIGNlbGxFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7IC8vIENlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICBjZWxsRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJzsgLy8gQ2VudGVyIGhvcml6b250YWxseVxuICAgICAgICAgICAgY2VsbEVsLnN0eWxlLmdhcCA9ICcnOyAvLyBObyBnYXAgbmVlZGVkIHdpdGhpbiBoZWF0bWFwIGNlbGxcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTWV0aG9kIHRvIGFkZCBzdGF0aXN0aWNzIG5hdmlnYXRpb24gY29udHJvbHNcbiAgICBhZGRTdGF0c0NvbnRyb2xzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBsZXQgY29udHJvbHNDb250YWluZXIgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcuaGFiaXQtc3RhdHMtY29udHJvbHMnKTtcbiAgICAgICAgaWYgKCFjb250cm9sc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udHJvbHNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1zdGF0cy1jb250cm9scycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbHNDb250YWluZXIuZW1wdHkoKTtcblxuICAgICAgICAvLyBQZXJpb2QgU3dpdGNoIChNb250aC9ZZWFyKVxuICAgICAgICBjb25zdCBwZXJpb2RTd2l0Y2ggPSBjb250cm9sc0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1zdGF0cy1wZXJpb2Qtc3dpdGNoJyB9KTtcbiAgICAgICAgY29uc3QgbW9udGhCdXR0b24gPSBwZXJpb2RTd2l0Y2guY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ01vbnRoJywgY2xzOiAnaGFiaXQtc3RhdHMtcGVyaW9kLWJ1dHRvbicgfSk7XG4gICAgICAgIGNvbnN0IHllYXJCdXR0b24gPSBwZXJpb2RTd2l0Y2guY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ1llYXInLCBjbHM6ICdoYWJpdC1zdGF0cy1wZXJpb2QtYnV0dG9uJyB9KTtcblxuICAgICAgICBtb250aEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCAhPT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRzUGVyaW9kID0gJ21vbnRoJztcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBzdGF0cyBwZXJpb2QsIHJlc2V0IHRoZSBzdGF0cyBkYXRlIHRvIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBjb3JyZXNwb25kaW5nIHBlcmlvZFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRzRGF0ZSA9IG1vbWVudCgpLnN0YXJ0T2YoJ21vbnRoJyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0c1ZpZXcoKTsgLy8gVXBkYXRlIGNvbnRyb2xzIGFuZCByZS1yZW5kZXIgc3RhdHMgY29udGVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB5ZWFyQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRzUGVyaW9kICE9PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9ICd5ZWFyJztcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBzdGF0cyBwZXJpb2QsIHJlc2V0IHRoZSBzdGF0cyBkYXRlIHRvIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBjb3JyZXNwb25kaW5nIHBlcmlvZFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRzRGF0ZSA9IG1vbWVudCgpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzVmlldygpOyAvLyBVcGRhdGUgY29udHJvbHMgYW5kIHJlLXJlbmRlciBzdGF0cyBjb250ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBTd2l0Y2hpbmcgdG8gWWVhciB2aWV3IHdpbGwgYXV0b21hdGljYWxseSBzaG93IGhlYXRtYXBzIGZvciBib29sZWFuL3RleHQgaGFiaXRzXG4gICAgICAgICAgICAvLyBhbmQgY2hhcnRzIGZvciBudW1iZXIgaGFiaXRzIGJhc2VkIG9uIHRoZSBmaWx0ZXJpbmcgaW4gcmVuZGVyU3RhdHNDb250ZW50LlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEYXRlIE5hdmlnYXRpb24gKGZvciBTdGF0cyBWaWV3KVxuICAgICAgICBjb25zdCBkYXRlTmF2ID0gY29udHJvbHNDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnaGFiaXQtc3RhdHMtZGF0ZS1uYXYnIH0pO1xuICAgICAgICBjb25zdCBwcmV2QnV0dG9uID0gZGF0ZU5hdi5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnPDwnLCBjbHM6ICdoYWJpdC1zdGF0cy1uYXYtYnV0dG9uJyB9KTtcbiAgICAgICAgdGhpcy5zdGF0c0RhdGVEaXNwbGF5RWwgPSBkYXRlTmF2LmNyZWF0ZUVsKCdzcGFuJywgeyBjbHM6ICdoYWJpdC1zdGF0cy1kYXRlLWRpc3BsYXknIH0pOyAvLyBBc3NpZ24gcmVmZXJlbmNlIGhlcmVcbiAgICAgICAgY29uc3QgbmV4dEJ1dHRvbiA9IGRhdGVOYXYuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJz4+JywgY2xzOiAnaGFiaXQtc3RhdHMtbmF2LWJ1dHRvbicgfSk7XG5cbiAgICAgICAgcHJldkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRoZSBzdGF0cyBkYXRlIGJhc2VkIG9uIHRoZSBzdGF0cyBwZXJpb2RcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRzRGF0ZS5zdWJ0cmFjdCgxLCAnbW9udGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHllYXJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuc3VidHJhY3QoMSwgJ3llYXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHNWaWV3KCk7IC8vIFVwZGF0ZSBjb250cm9scyBhbmQgcmUtcmVuZGVyIHN0YXRzIGNvbnRlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV4dEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRoZSBzdGF0cyBkYXRlIGJhc2VkIG9uIHRoZSBzdGF0cyBwZXJpb2RcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRzRGF0ZS5hZGQoMSwgJ21vbnRoJyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB5ZWFyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdHNEYXRlLmFkZCgxLCAneWVhcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0c1ZpZXcoKTsgLy8gVXBkYXRlIGNvbnRyb2xzIGFuZCByZS1yZW5kZXIgc3RhdHMgY29udGVudFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZWZyZXNoQnV0dG9uID0gY29udHJvbHNDb250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ1JlZnJlc2ggU3RhdHMnLCBjbHM6ICdoYWJpdC1zdGF0cy1yZWZyZXNoLWJ1dHRvbicgfSk7XG4gICAgICAgIHJlZnJlc2hCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzVmlldygpOyAvLyBVcGRhdGUgY29udHJvbHMgYW5kIHJlLXJlbmRlciBzdGF0cyBjb250ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY29udGFpbmVyIGZvciBzdGF0cyBjb250ZW50IGhlcmUsIHdpdGhpbiB0aGUgc3RhdHNTZWN0aW9uQ29udGFpbmVyXG4gICAgICAgIHRoaXMuc3RhdHNDb250ZW50Q29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnaGFiaXQtc3RhdHMtY29udGVudCcgfSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbCB1cGRhdGUgb2YgdGhlIGNvbnRyb2xzIGRpc3BsYXkgYW5kIHRyaWdnZXIgc3RhdHMgY29udGVudCByZW5kZXJpbmdcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0c1ZpZXcoKTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2QgdG8gdXBkYXRlIHN0YXRpc3RpY3MgY29udHJvbHMgZGlzcGxheSBhbmQgdHJpZ2dlciBzdGF0cyBjb250ZW50IHJlbmRlcmluZ1xuICAgIHVwZGF0ZVN0YXRzVmlldygpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN0YXRzU2VjdGlvbkNvbnRhaW5lciA9IGNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCcuaGFiaXQtc3RhdHMtc2VjdGlvbi1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBzdGF0c1NlY3Rpb25Db250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoJy5oYWJpdC1zdGF0cy1jb250cm9scycpO1xuICAgICAgICAvLyBHZXQgdGhlIGRhdGUgZGlzcGxheSBlbGVtZW50IHVzaW5nIHRoZSBzdG9yZWQgcmVmZXJlbmNlXG4gICAgICAgIGNvbnN0IGRhdGVEaXNwbGF5RWwgPSB0aGlzLnN0YXRzRGF0ZURpc3BsYXlFbDtcbiAgICAgICAgY29uc3QgcGVyaW9kQnV0dG9ucyA9IGNvbnRyb2xzQ29udGFpbmVyPy5xdWVyeVNlbGVjdG9yQWxsKCcuaGFiaXQtc3RhdHMtcGVyaW9kLWJ1dHRvbicpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbnRyb2xzIGFuZCBkYXRlIGRpc3BsYXkgZXhpc3QgYmVmb3JlIHRyeWluZyB0byB1cGRhdGUgdGhlbVxuICAgICAgICBpZiAoIWNvbnRyb2xzQ29udGFpbmVyIHx8ICFkYXRlRGlzcGxheUVsIHx8ICFwZXJpb2RCdXR0b25zIHx8ICF0aGlzLnN0YXRzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0hhYml0IFRyYWNrZXJdIFN0YXRzIGNvbnRyb2xzIG9yIGNvbnRlbnQgY29udGFpbmVyIG5vdCBmb3VuZCB3aGVuIHRyeWluZyB0byB1cGRhdGUuIFNraXBwaW5nIHVwZGF0ZVN0YXRzVmlldyBsb2dpYy5cIik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBjb250YWluZXIgZG9lc24ndCBleGlzdCwgd2UgY2FuJ3QgcmVuZGVyIHN0YXRzIGNvbnRlbnQsIHNvIHJldHVybi5cbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltIYWJpdCBUcmFja2VyXSBTdGF0cyBjb250ZW50IGNvbnRhaW5lciBpcyBudWxsLiBDYW5ub3QgcmVuZGVyIHN0YXRzLlwiKTtcbiAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgY29udHJvbHMvZGF0ZURpc3BsYXlFbCBhcmUgbWlzc2luZyBidXQgY29udGVudENvbnRhaW5lciBleGlzdHMsIHdlIGNhbiBzdGlsbCB0cnkgdG8gcmVuZGVyIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBUaGlzIG1pZ2h0IGhhcHBlbiBpZiByZW5kZXJWaWV3IGlzIGNhbGxlZCBiZWZvcmUgYWRkU3RhdHNDb250cm9scyBjb21wbGV0ZXMuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGp1c3QgcmVuZGVyIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0c0NvbnRlbnQodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBVcGRhdGUgUGVyaW9kIEJ1dHRvbiBIaWdobGlnaHRpbmdcbiAgICAgICAgcGVyaW9kQnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLnRleHRDb250ZW50Py50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBEYXRlIERpc3BsYXkgZm9yIFN0YXRzIFZpZXdcbiAgICAgICAgbGV0IGRhdGVEaXNwbGF5ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgZGF0ZURpc3BsYXkgPSB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuZm9ybWF0KCdZWVlZIE1NTU0nKTtcbiAgICAgICAgfSBlbHNlIHsgLy8geWVhclxuICAgICAgICAgICAgZGF0ZURpc3BsYXkgPSB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuZm9ybWF0KCdZWVlZJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZURpc3BsYXlFbC5zZXRUZXh0KGRhdGVEaXNwbGF5KTtcblxuICAgICAgICAvLyAtLS0gVHJpZ2dlciBSZS1yZW5kZXJpbmcgb2YgU3RhdHMgQ29udGVudCAtLS1cbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0c0NvbnRlbnQodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIC8vIE1ldGhvZCB0byByZW5kZXIgb3IgcmUtcmVuZGVyIE9OTFkgdGhlIHN0YXRpc3RpY3MgY29udGVudCAoY2hhcnRzLCBoZWF0bWFwcywgc3VtbWFyaWVzKVxuICAgIHJlbmRlclN0YXRzQ29udGVudChzdGF0c0NvbnRlbnRDb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGNvbnRlbnQgd2l0aGluIHRoZSBzdGF0cyBjb250ZW50IGNvbnRhaW5lclxuICAgICAgICAgICBzdGF0c0NvbnRlbnRDb250YWluZXIuZW1wdHkoKTtcblxuICAgICAgICAgICAvLyBEZXN0cm95IGV4aXN0aW5nIGNoYXJ0IGluc3RhbmNlcyBiZWZvcmUgcmVuZGVyaW5nIG5ldyBvbmVzXG4gICAgICAgICAgIHRoaXMuY2hhcnRJbnN0YW5jZXMuZm9yRWFjaChjaGFydCA9PiBjaGFydC5kZXN0cm95KCkpO1xuICAgICAgICAgICB0aGlzLmNoYXJ0SW5zdGFuY2VzLmNsZWFyKCk7XG5cblxuICAgICAgICAgICBjb25zdCBoYWJpdHMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHM7XG4gICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25EYXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGE7XG5cbiAgICAgICAgICAgaWYgKGhhYml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgIC8vIEFkZCBhIG1lc3NhZ2UgaWYgbm8gaGFiaXRzIGFyZSBjb25maWd1cmVkLCBzaW1pbGFyIHRvIGNoZWNrLWluXG4gICAgICAgICAgICAgICBjb25zdCBub0hhYml0c01lc3NhZ2UgPSBzdGF0c0NvbnRlbnRDb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7IGNsczogJ25vLWhhYml0cy1tZXNzYWdlJywgdGV4dDogJ05vIGhhYml0cyBkZWZpbmVkIHRvIGRpc3BsYXkgc3RhdGlzdGljcy4nIH0pO1xuICAgICAgICAgICAgICAgbm9IYWJpdHNNZXNzYWdlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgbm9IYWJpdHNNZXNzYWdlLnN0eWxlLmNvbG9yID0gJ3ZhcigtLXRleHQtbXV0ZWQpJztcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHN0YXRzQ29udGVudENvbnRhaW5lci5maW5kQWxsKCcubm8taGFiaXRzLW1lc3NhZ2UnKS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcbiAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgLy8gLS0tIERhdGEgQWdncmVnYXRpb24gZm9yIHRoZSBTZWxlY3RlZCBQZXJpb2QgLS0tXG4gICAgICAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0RGF0ZSA9IHRoaXMuY3VycmVudFN0YXRzUGVyaW9kID09PSAnbW9udGgnXG4gICAgICAgICAgICAgICA/IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ21vbnRoJylcbiAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50U3RhdHNEYXRlLmNsb25lKCkuc3RhcnRPZigneWVhcicpO1xuXG4gICAgICAgICAgIGNvbnN0IHBlcmlvZEVuZERhdGUgPSB0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJ1xuICAgICAgICAgICAgICAgPyB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuY2xvbmUoKS5lbmRPZignbW9udGgnKVxuICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuY2xvbmUoKS5lbmRPZigneWVhcicpO1xuXG4gICAgICAgICAgIGNvbnN0IGFsbERhdGVzSW5QZXJpb2Q6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgIGxldCBkYXRlSXRlcmF0b3IgPSBwZXJpb2RTdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICAgY29uc3QgZGF0ZUZvcm1hdCA9IFwiWVlZWS1NTS1ERFwiO1xuICAgICAgICAgICB3aGlsZSAoZGF0ZUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHBlcmlvZEVuZERhdGUsICdkYXknKSkge1xuICAgICAgICAgICAgICAgYWxsRGF0ZXNJblBlcmlvZC5wdXNoKGRhdGVJdGVyYXRvci5mb3JtYXQoZGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgZGF0ZUl0ZXJhdG9yLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBGaWx0ZXIgaGFiaXRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRzIHBlcmlvZCBhbmQgaGFiaXQgdHlwZS9zdGF0c1R5cGVcbiAgICAgICAgICAgLy8gVGhpcyBmaWx0ZXJpbmcgbG9naWMgcmVtYWlucyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICAgICAgICAgY29uc3QgaGFiaXRzVG9EaXNwbGF5ID0gaGFiaXRzLmZpbHRlcihoYWJpdCA9PiB7XG4gICAgICAgICAgICAgICAvLyBFbnN1cmUgaGFiaXQuc3RhdHNUeXBlIGlzIGRlZmF1bHRlZCBmb3IgZmlsdGVyaW5nXG4gICAgICAgICAgICAgICBjb25zdCBoYWJpdFN0YXRzVHlwZSA9IGhhYml0LnN0YXRzVHlwZSB8fCAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicgPyAnYmFyJyA6ICdoZWF0bWFwJyk7XG5cbiAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgICAgIC8vIEluIG1vbnRoIHZpZXcsIG9ubHkgc2hvdyBOdW1iZXIgaGFiaXRzIHdpdGggY2hhcnQgdHlwZXMgKGJhciwgbGluZSwgY29tYm8pXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhYml0LnR5cGUgPT09ICdudW1iZXInICYmIChoYWJpdFN0YXRzVHlwZSA9PT0gJ2JhcicgfHwgaGFiaXRTdGF0c1R5cGUgPT09ICdsaW5lJyB8fCBoYWJpdFN0YXRzVHlwZSA9PT0gJ2NvbWJvJyk7XG4gICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB5ZWFyXG4gICAgICAgICAgICAgICAgICAgLy8gSW4geWVhciB2aWV3LCBzaG93IGFsbCBoYWJpdHMgdGhhdCBoYXZlIGEgY29uZmlndXJlZCBzdGF0c1R5cGUgKHNob3VsZCBiZSBzZXQgZm9yIGFsbCB0eXBlcyBhZnRlciBtaWdyYXRpb24vZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgICAgLy8gSGVhdG1hcHMgYXJlIG9ubHkgc2hvd24gaW4geWVhciB2aWV3LCBjaGFydHMgZm9yIG51bWJlciB0eXBlcyBjYW4gYmUgc2hvd24gaW4geWVhciB2aWV3IHRvby5cbiAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2hvdyBhbGwgaGFiaXRzIGluIHllYXIgdmlldywgdmlzdWFsaXphdGlvbiBoYW5kbGVzIHR5cGVcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICBoYWJpdHNUb0Rpc3BsYXkuZm9yRWFjaChoYWJpdCA9PiB7XG4gICAgICAgICAgICAgICBjb25zdCBoYWJpdFN0YXRzU2VjdGlvbiA9IHN0YXRzQ29udGVudENvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1zdGF0cy1zZWN0aW9uJyB9KTtcbiAgICAgICAgICAgICAgIGhhYml0U3RhdHNTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogaGFiaXQubmFtZSB9KTtcblxuICAgICAgICAgICAgICAgbGV0IHRvdGFsVmFsdWVQZXJpb2QgPSAwOyAvLyBGb3IgbnVtYmVyIGhhYml0c1xuICAgICAgICAgICAgICAgbGV0IGNvbXBsZXRlZENvdW50UGVyaW9kID0gMDsgLy8gRm9yIGJvb2xlYW4gaGFiaXRzICh0b3RhbCB0cnVlIGVudHJpZXMgb3Igc3VtIG9mIGNvdW50cyBmb3IgZGFpbHkgZ29hbCA+IDEpXG4gICAgICAgICAgICAgICBsZXQgcmVjb3JkZWREYXlzQ291bnRQZXJpb2QgPSAwOyAvLyBDb3VudCBkYXlzIHdpdGggYW55IGVudHJ5ID4gMCAoZm9yIG51bWJlci90ZXh0KSBvciBhbnkgdHJ1ZS9jb3VudCA+IDAgKGZvciBib29sZWFuKVxuICAgICAgICAgICAgICAgbGV0IHRleHRWYWx1ZUNvdW50czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9OyAvLyBGb3IgdGV4dCBoYWJpdCBzdGF0c1xuXG4gICAgICAgICAgICAgICAvLyAtLS0gUHJlLWNhbGN1bGF0ZSB3ZWVrbHkgY29tcGxldGlvbiBwZXJjZW50YWdlcyBmb3Igd2Vla2x5IGJvb2xlYW4gaGVhdG1hcHMgKFllYXIgVmlldykgLS0tXG4gICAgICAgICAgICAgICBjb25zdCB3ZWVrbHlCb29sZWFuUGVyY2VudGFnZXM6IHsgW3dlZWtTdGFydERhdGU6IHN0cmluZ106IG51bWJlciB9ID0ge307XG4gICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdHNQZXJpb2QgPT09ICd5ZWFyJyAmJiBoYWJpdC50eXBlID09PSAnYm9vbGVhbicgJiYgaGFiaXQuZnJlcXVlbmN5ID09PSAnd2VlaycgJiYgKGhhYml0LnN0YXRzVHlwZSB8fCAnaGVhdG1hcCcpID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeWVhclN0YXJ0RGF0ZSA9IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeWVhckVuZERhdGUgPSB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuY2xvbmUoKS5lbmRPZigneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla0l0ZXJhdG9yID0geWVhclN0YXJ0RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvbkdvYWwgPSBoYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSBudWxsICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsID4gMCA/IGhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAod2Vla0l0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHllYXJFbmREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ZWVrbHlDb21wbGV0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWVrRW5kRGF0ZSA9IHdlZWtJdGVyYXRvci5jbG9uZSgpLmVuZE9mKCd3ZWVrJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXlJdGVyYXRvciA9IHdlZWtJdGVyYXRvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRheUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHdlZWtFbmREYXRlLCAnZGF5JykpIHsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCA3IGRheXMgb2YgdGhlIHdlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGRheUl0ZXJhdG9yLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRheSBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF5SXRlcmF0b3IuaXNTYW1lT3JBZnRlcih5ZWFyU3RhcnREYXRlLCAnZGF5JykgJiYgZGF5SXRlcmF0b3IuaXNTYW1lT3JCZWZvcmUoeWVhckVuZERhdGUsICdkYXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzRm9yRGF5ID0gY29tcGxldGlvbkRhdGFbZGF0ZVN0cmluZ10/LltoYWJpdC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNGb3JEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlDb21wbGV0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUl0ZXJhdG9yLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGZvciB0aGUgd2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGNvbXBsZXRpb25Hb2FsID4gMCA/IE1hdGgubWluKCh3ZWVrbHlDb21wbGV0aW9ucyAvIGNvbXBsZXRpb25Hb2FsKSAqIDEwMCwgMTAwKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBwZXJjZW50YWdlIGtleWVkIGJ5IHRoZSBzdGFydCBkYXRlIG9mIHRoZSB3ZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlCb29sZWFuUGVyY2VudGFnZXNbd2Vla0l0ZXJhdG9yLmZvcm1hdChkYXRlRm9ybWF0KV0gPSBwZXJjZW50YWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrSXRlcmF0b3IuYWRkKDEsICd3ZWVrJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vIC0tLSBFbmQgUHJlLWNhbGN1bGF0aW9uIC0tLVxuXG5cbiAgICAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSBkYXRhIGZvciB0aGUgcGVyaW9kIChmb3Igc3VtbWFyeSBzdGF0cylcbiAgICAgICAgICAgICAgIGFsbERhdGVzSW5QZXJpb2QuZm9yRWFjaChkYXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICBjb25zdCByYXdTdGF0dXMgPSBjb21wbGV0aW9uRGF0YVtkYXRlXT8uW2hhYml0Lm5hbWVdID8/IG51bGw7IC8vIFVzZSBudWxsaXNoIGNvYWxlc2NpbmdcblxuICAgICAgICAgICAgICAgICAgIGlmIChyYXdTdGF0dXMgIT09IHVuZGVmaW5lZCAmJiByYXdTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZXNXaXRoRGF0YUZvckhhYml0SW5QZXJpb2QucHVzaChkYXRlKTsgLy8gTm90IHVzZWQgaW4gdGhpcyBzY29wZSwgcmVtb3ZlZFxuXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBib29sZWFuLCBjb3VudCBkYXlzIHdoZXJlIHN0YXR1cyBpcyB0cnVlIG9yIHN1bSBjb3VudHMgZm9yIGRhaWx5IGdvYWwgPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IG51bGwgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gaGFiaXQuY29tcGxldGlvbkdvYWwgOiAxOyAvLyBEZWZhdWx0IGdvYWwgdG8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LmZyZXF1ZW5jeSA9PT0gJ2RheScgJiYgY29tcGxldGlvbkdvYWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGFpbHkgYm9vbGVhbiB3aXRoIGdvYWwgPiAxOiBTdW0gdXAgdGhlIGNvdW50cyBhbmQgY291bnQgZGF5cyB3aXRoIGNvdW50ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3U3RhdHVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRDb3VudFBlcmlvZCArPSByYXdTdGF0dXM7IC8vIFN1bSB1cCBjb21wbGV0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3U3RhdHVzID4gMCkgcmVjb3JkZWREYXlzQ291bnRQZXJpb2QgKz0gMTsgLy8gQ291bnQgdGhpcyBkYXkgYXMgaGF2aW5nIGFuIGVudHJ5ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB1bmV4cGVjdGVkIGJvb2xlYW4vbnVsbCBkYXRhIGZvciB0aGlzIHR5cGUvZnJlcS9nb2FsIGNvbWJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdTdGF0dXMgIT09IG51bGwgJiYgcmF3U3RhdHVzICE9PSBmYWxzZSkgeyAvLyBDaGVjayBmb3IgYWN0dWFsIHVuZXhwZWN0ZWQgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbm9uLW51bWJlciBkYXRhIGZvciBkYWlseSBib29sZWFuIGhhYml0IFwiJHtoYWJpdC5uYW1lfVwiIChnb2FsID4gMSkgb24gJHtkYXRlfS4gVHJlYXRpbmcgYXMgMCBjb21wbGV0aW9ucyBmb3Igc3RhdHMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgd2FzIGZhbHNlIG9yIG51bGwsIGl0J3MgYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSBpbml0aWFsIGNoZWNrIChyYXdTdGF0dXMgIT09IHVuZGVmaW5lZCAmJiByYXdTdGF0dXMgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gRGFpbHkgYm9vbGVhbiB3aXRoIGdvYWwgPD0gMSwgb3IgV2Vla2x5IGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBkYXlzIHdoZXJlIHN0YXR1cyBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1N0YXR1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRDb3VudFBlcmlvZCArPSAxOyAvLyBDb3VudCBjb21wbGV0ZWQgZGF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZERheXNDb3VudFBlcmlvZCArPSAxOyAvLyBDb3VudCB0aGlzIGRheSBhcyBoYXZpbmcgYW4gZW50cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHVuZXhwZWN0ZWQgbnVtYmVyL3N0cmluZyBkYXRhIGZvciB0aGlzIHR5cGUvZnJlcS9nb2FsIGNvbWJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJhd1N0YXR1cyAhPT0gJ2Jvb2xlYW4nKSB7IC8vIENoZWNrIGZvciBhY3R1YWwgdW5leHBlY3RlZCB0eXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbm9uLWJvb2xlYW4gZGF0YSBmb3IgYm9vbGVhbiBoYWJpdCBcIiR7aGFiaXQubmFtZX1cIiBvbiAke2RhdGV9LiBUcmVhdGluZyBhcyAwIGNvbXBsZXRpb25zIGZvciBzdGF0cy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHdhcyBmYWxzZSBvciBudWxsLCBpdCdzIGFscmVhZHkgaGFuZGxlZCBieSB0aGUgaW5pdGlhbCBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYWJpdC50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGF0YSBmb3IgbnVtYmVyIGhhYml0IGlzIGFsd2F5cyBhbiBhcnJheSBvciBudWxsIGFmdGVyIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3U3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhaWx5U3VtID0gcmF3U3RhdHVzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFZhbHVlUGVyaW9kICs9IGRhaWx5U3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYWlseVN1bSA+IDApIHJlY29yZGVkRGF5c0NvdW50UGVyaW9kICs9IDE7IC8vIENvdW50IGRheXMgd2l0aCBhbnkgZW50cnkgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXdTdGF0dXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIHVuZXhwZWN0ZWQgc2luZ2xlIG51bWJlciBkYXRhIChzaG91bGQgYmUgcmFyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtIYWJpdCBUcmFja2VyXSBFbmNvdW50ZXJlZCBzaW5nbGUgbnVtYmVyIGRhdGEgZm9yIFwiJHtoYWJpdC5uYW1lfVwiIG9uICR7ZGF0ZX0gZHVyaW5nIHN0YXRzIGFnZ3JlZ2F0aW9uLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVmFsdWVQZXJpb2QgKz0gcmF3U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdTdGF0dXMgPiAwKSByZWNvcmRlZERheXNDb3VudFBlcmlvZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdW5leHBlY3RlZCBub24tYXJyYXkvbm9uLW51bWJlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSGFiaXQgVHJhY2tlcl0gVW5leHBlY3RlZCBub24tYXJyYXkvbm9uLW51bWJlciBkYXRhIGZvciBudW1iZXIgaGFiaXQgXCIke2hhYml0Lm5hbWV9XCIgb24gJHtkYXRlfS4gVHJlYXRpbmcgYXMgMCBmb3Igc3RhdHMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ3RleHQnICYmIHR5cGVvZiByYXdTdGF0dXMgPT09ICdzdHJpbmcnICYmIHJhd1N0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCB0ZXh0IGVudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0VmFsdWVDb3VudHNbcmF3U3RhdHVzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZUNvdW50c1tyYXdTdGF0dXNdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZUNvdW50c1tyYXdTdGF0dXNdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkRGF5c0NvdW50UGVyaW9kICs9IDE7IC8vIENvdW50IGRheXMgd2l0aCBhIHRleHQgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYWJpdC50eXBlID09PSAndGV4dCcgJiYgcmF3U3RhdHVzICE9PSBudWxsICYmIHR5cGVvZiByYXdTdGF0dXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHVuZXhwZWN0ZWQgbm9uLXN0cmluZyBkYXRhIGZvciB0ZXh0IGhhYml0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbm9uLXN0cmluZyBkYXRhIGZvciB0ZXh0IGhhYml0IFwiJHtoYWJpdC5uYW1lfVwiIG9uICR7ZGF0ZX0uIElnbm9yaW5nIGZvciBzdGF0cy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRGF5c0luUGVyaW9kID0gYWxsRGF0ZXNJblBlcmlvZC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgIC8vIENvbnRhaW5lciBmb3IgaW5saW5lIHN0YXRzXG4gICAgICAgICAgICAgICBjb25zdCBzdGF0c1N1bW1hcnlDb250YWluZXIgPSBoYWJpdFN0YXRzU2VjdGlvbi5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC1zdGF0cy1zdW1tYXJ5JyB9KTtcblxuICAgICAgICAgICAgICAgLy8gTW9kaWZpZWQ6IEJ1aWxkIHN0YXQgc3RyaW5ncyB3aXRoIGRlc2lyZWQgc3BhY2luZyBhbmQgdXNlIGlubmVySFRNTFxuICAgICAgICAgICAgICAgaWYgKGhhYml0LnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25Hb2FsID0gaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IHVuZGVmaW5lZCAmJiBoYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBoYWJpdC5jb21wbGV0aW9uR29hbCA+IDAgPyBoYWJpdC5jb21wbGV0aW9uR29hbCA6IDE7XG4gICAgICAgICAgICAgICAgICAgLy8gRm9yIGJvb2xlYW4gaGFiaXRzLCBzaG93IGNvbXBsZXRlZCBkYXlzIHZzIHRvdGFsIGRheXNcbiAgICAgICAgICAgICAgICAgICAvLyBJZiBkYWlseSBib29sZWFuIHdpdGggZ29hbCA+IDEsIGNvbXBsZXRlZENvdW50UGVyaW9kIGlzIHRoZSBzdW0gb2YgY291bnRzXG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXBsZXRlZFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICBsZXQgY29tcGxldGlvblJhdGVUZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgbGV0IGdvYWxUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICBpZiAoaGFiaXQuZnJlcXVlbmN5ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBEYWlseSBib29sZWFuOiBBZGQgQ29tcGxldGlvbiBEYXlzIGFuZCBDb21wbGV0aW9uIFJhdGUgKERheXMpXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25EYXlzID0gcmVjb3JkZWREYXlzQ291bnRQZXJpb2Q7IC8vIERheXMgd2l0aCBhbnkgZW50cnkgPiAwIChmb3IgY291bnQpIG9yIHRydWUgKGZvciBib29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uRGF5c1JhdGUgPSB0b3RhbERheXNJblBlcmlvZCA+IDAgPyAoKGNvbXBsZXRpb25EYXlzIC8gdG90YWxEYXlzSW5QZXJpb2QpICogMTAwKS50b0ZpeGVkKDEpIDogJ04vQSc7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkOiBGb3JtYXQgc3RyaW5nIHdpdGggY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGF0c1N0cmluZyA9IGBDb21wbGV0aW9uIERheXM6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7Y29tcGxldGlvbkRheXN9PC9zcGFuPi88c3BhbiBjbGFzcz1cInN0YXQtZGVub21pbmF0b3JcIj4ke3RvdGFsRGF5c0luUGVyaW9kfTwvc3Bhbj4sIENvbXBsZXRpb24gUmF0ZSAoRGF5cykgOiA8c3BhbiBjbGFzcz1cInN0YXQtdmFsdWVcIj4ke2NvbXBsZXRpb25EYXlzUmF0ZX0lPC9zcGFuPmA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxQb3NzaWJsZUdvYWwgPSBjb21wbGV0aW9uR29hbCAqIHRvdGFsRGF5c0luUGVyaW9kO1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbENvbXBsZXRpb25SYXRlID0gdG90YWxQb3NzaWJsZUdvYWwgPiAwID8gKChjb21wbGV0ZWRDb3VudFBlcmlvZCAvIHRvdGFsUG9zc2libGVHb2FsKSAqIDEwMCkudG9GaXhlZCgxKSA6ICdOL0EnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkOiBBZGQgVG90YWwgQ29tcGxldGlvbnMgYW5kIENvbXBsZXRpb24gUmF0ZSAoVG90YWwpXG4gICAgICAgICAgICAgICAgICAgICAgIHN0YXRzU3RyaW5nICs9IGAsIFRvdGFsIENvbXBsZXRpb25zOiA8c3BhbiBjbGFzcz1cInN0YXQtdmFsdWVcIj4ke2NvbXBsZXRlZENvdW50UGVyaW9kfTwvc3Bhbj4vPHNwYW4gY2xhc3M9XCJzdGF0LWRlbm9taW5hdG9yXCI+JHt0b3RhbFBvc3NpYmxlR29hbH08L3NwYW4+LCBDb21wbGV0aW9uIFJhdGUgKFRvdGFsKSA6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7dG90YWxDb21wbGV0aW9uUmF0ZX0lPC9zcGFuPmA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbkdvYWwgIT09IHVuZGVmaW5lZCAmJiBjb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBjb21wbGV0aW9uR29hbCA+IDApIHsgLy8gU2hvdyBnb2FsIGlmIHNldCBhbmQgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBnb2FsVGV4dCA9IGAsIEdvYWw6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7Y29tcGxldGlvbkdvYWx9L2RheTwvc3Bhbj5gOyAvLyBDb3JyZWN0ZWQgY2xvc2luZyBzcGFuIHRhZyBhbmQgYWRkZWQgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzU3RyaW5nICs9IGdvYWxUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNTdW1tYXJ5Q29udGFpbmVyLmNyZWF0ZUVsKCdwJywgeyBjbHM6ICdpbmxpbmUtc3RhdHMtcGFyYWdyYXBoJyB9KS5pbm5lckhUTUwgPSBzdGF0c1N0cmluZztcblxuXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZnJlcXVlbmN5ID09PSAnd2VlaydcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Vla2x5IGJvb2xlYW46IFNob3cgY29tcGxldGVkIGRheXMgYW5kIGNvbXBsZXRlZCB3ZWVrc1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uRGF5cyA9IHJlY29yZGVkRGF5c0NvdW50UGVyaW9kOyAvLyBEYXlzIG1hcmtlZCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25EYXlzUmF0ZSA9IHRvdGFsRGF5c0luUGVyaW9kID4gMCA/ICgoY29tcGxldGlvbkRheXMgLyB0b3RhbERheXNJblBlcmlvZCkgKiAxMDApLnRvRml4ZWQoMSkgOiAnTi9BJztcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZpZWQ6IEZvcm1hdCBzdHJpbmcgd2l0aCBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRzU3RyaW5nID0gYENvbXBsZXRlZCBEYXlzOiA8c3BhbiBjbGFzcz1cInN0YXQtdmFsdWVcIj4ke2NvbXBsZXRpb25EYXlzfTwvc3Bhbj4vPHNwYW4gY2xhc3M9XCJzdGF0LWRlbm9taW5hdG9yXCI+JHt0b3RhbERheXNJblBlcmlvZH08L3NwYW4+LCBDb21wbGV0aW9uIFJhdGUgKERheXMpIDogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHtjb21wbGV0aW9uRGF5c1JhdGV9JTwvc3Bhbj5gO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIENvbXBsZXRlZCBXZWVrcyBmb3IgV2Vla2x5IEJvb2xlYW4gaGFiaXRzIChZZWFyIFZpZXcgb25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRzUGVyaW9kID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb21wbGV0ZWRXZWVrc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0WWVhciA9IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFllYXIgPSB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuY2xvbmUoKS5lbmRPZigneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdlZWtJdGVyYXRvciA9IHN0YXJ0WWVhci5jbG9uZSgpLnN0YXJ0T2YoJ3dlZWsnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHBvc3NpYmxlIHdlZWtzIGluIHRoZSB5ZWFyIG92ZXJsYXBwaW5nIHdpdGggZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRZZWFyTW9tZW50ID0gdGhpcy5jdXJyZW50U3RhdHNEYXRlLmNsb25lKCkuc3RhcnRPZigneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kWWVhck1vbWVudCA9IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLmVuZE9mKCd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgY291bnQgd2Vla3MgdGhhdCBvdmVybGFwIHdpdGggdGhlIHllYXIsIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBjb250YWluaW5nIHRoZSB5ZWFyJ3Mgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0V2Vla1N0YXJ0T2ZQZXJpb2QgPSBzdGFydFllYXJNb21lbnQuY2xvbmUoKS5zdGFydE9mKCd3ZWVrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0V2Vla1N0YXJ0T2ZQZXJpb2QgPSBlbmRZZWFyTW9tZW50LmNsb25lKCkuc3RhcnRPZignd2VlaycpOyAvLyBTdGFydCBvZiB0aGUgd2VlayBjb250YWluaW5nIHRoZSB5ZWFyJ3MgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFdlZWtzSW5QZXJpb2QgPSBsYXN0V2Vla1N0YXJ0T2ZQZXJpb2QuZGlmZihmaXJzdFdlZWtTdGFydE9mUGVyaW9kLCAnd2Vla3MnKSArIDE7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHdlZWtJdGVyYXRvci5pc1NhbWVPckJlZm9yZShlbmRZZWFyLCAnZGF5JykpIHsgLy8gSXRlcmF0ZSB3ZWVrIGJ5IHdlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla2x5Q29tcGxldGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtFbmREYXRlID0gd2Vla0l0ZXJhdG9yLmNsb25lKCkuZW5kT2YoJ3dlZWsnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSBkYXRhIGZvciB0aGUgY3VycmVudCB3ZWVrLCBlbnN1cmluZyB3ZSBzdGF5IHdpdGhpbiB0aGUgeWVhcidzIGJvdW5kc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXlJdGVyYXRvciA9IHdlZWtJdGVyYXRvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChkYXlJdGVyYXRvci5pc1NhbWVPckJlZm9yZSh3ZWVrRW5kRGF0ZSwgJ2RheScpICYmIGRheUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKGVuZFllYXIsICdkYXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gZGF5SXRlcmF0b3IuZm9ybWF0KGRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNGb3JEYXkgPSBjb21wbGV0aW9uRGF0YVtkYXRlU3RyaW5nXT8uW2hhYml0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzRm9yRGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlDb21wbGV0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUl0ZXJhdG9yLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHdlZWsgbWVldHMgdGhlIGNvbXBsZXRpb24gZ29hbCBhbmQgaXMgYXQgbGVhc3QgcGFydGlhbGx5IHdpdGhpbiB0aGUgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkIGNvbmRpdGlvbiB0byBjaGVjayBpZiB0aGUgd2VlayBvdmVybGFwcyAqYXQgYWxsKiB3aXRoIHRoZSB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlZWtJdGVyYXRvci5pc1NhbWVPckJlZm9yZShlbmRZZWFyLCAnZGF5JykgJiYgd2Vla0VuZERhdGUuaXNTYW1lT3JBZnRlcihzdGFydFllYXIsICdkYXknKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGNvbXBsZXRpb25Hb2FsICE9PSBudWxsICYmIGNvbXBsZXRpb25Hb2FsID4gMCAmJiB3ZWVrbHlDb21wbGV0aW9ucyA+PSBjb21wbGV0aW9uR29hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkV2Vla3NDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjb21wbGV0aW9uR29hbCA9PT0gdW5kZWZpbmVkIHx8IGNvbXBsZXRpb25Hb2FsID09PSBudWxsIHx8IGNvbXBsZXRpb25Hb2FsIDw9IDApICYmIHdlZWtseUNvbXBsZXRpb25zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gZ29hbCBpcyBzZXQsIGNvdW50IGFueSB3ZWVrIHdpdGggYXQgbGVhc3Qgb25lIGNvbXBsZXRpb24gZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRXZWVrc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlZWtJdGVyYXRvci5hZGQoMSwgJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZpZWQ6IEFkZCBDb21wbGV0ZWQgV2Vla3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzU3RyaW5nICs9IGAsIENvbXBsZXRlZCBXZWVrczogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHtjb21wbGV0ZWRXZWVrc0NvdW50fTwvc3Bhbj4vPHNwYW4gY2xhc3M9XCJzdGF0LWRlbm9taW5hdG9yXCI+JHt0b3RhbFdlZWtzSW5QZXJpb2R9PC9zcGFuPmA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgY29tcGxldGlvbkdvYWwgIT09IG51bGwgJiYgY29tcGxldGlvbkdvYWwgPiAwKSB7IC8vIFNob3cgZ29hbCBpZiBzZXQgYW5kID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvYWxUZXh0ID0gYCwgR29hbDogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHtjb21wbGV0aW9uR29hbH0vd2Vlazwvc3Bhbj5gOyAvLyBDb3JyZWN0ZWQgY2xvc2luZyBzcGFuIHRhZyBhbmQgYWRkZWQgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1N0cmluZyArPSBnb2FsVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IHllYXIgdmlldywganVzdCBzaG93IHRoZSBnb2FsIGlmIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbkdvYWwgIT09IHVuZGVmaW5lZCAmJiBjb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBjb21wbGV0aW9uR29hbCA+IDApIHsgLy8gU2hvdyBnb2FsIGlmIHNldCBhbmQgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb2FsVGV4dCA9IGAsIEdvYWw6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7Y29tcGxldGlvbkdvYWx9L3dlZWs8L3NwYW4+YDsgLy8gQ29ycmVjdGVkIGNsb3Npbmcgc3BhbiB0YWcgYW5kIGFkZGVkIGNvbW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0c1N0cmluZyArPSBnb2FsVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIHN0YXRzU3VtbWFyeUNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgY2xzOiAnaW5saW5lLXN0YXRzLXBhcmFncmFwaCcgfSkuaW5uZXJIVE1MID0gc3RhdHNTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFZhbHVlVGV4dCA9IGBUb3RhbCBWYWx1ZTogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHt0b3RhbFZhbHVlUGVyaW9kLnRvRml4ZWQoMil9PC9zcGFuPjxzcGFuIGNsYXNzPVwic3RhdC11bml0XCI+JHtoYWJpdC51bml0IHx8ICcnfTwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgIGxldCBhdmVyYWdlVmFsdWVUZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsRGF5c1RleHQgPSAnJztcblxuICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRlZERheXNDb3VudFBlcmlvZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZpZWQ6IENoYW5nZWQgbGFiZWwgdG8gXCJBdmVyYWdlIFZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZVZhbHVlVGV4dCA9IGAsIEF2ZXJhZ2UgVmFsdWU6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7KHRvdGFsVmFsdWVQZXJpb2QgLyByZWNvcmRlZERheXNDb3VudFBlcmlvZCkudG9GaXhlZCgyKX08L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0LXVuaXRcIj4ke2hhYml0LnVuaXQgfHwgJyd9PC9zcGFuPmA7IC8vIEF2ZXJhZ2Ugb3ZlciBkYXlzIHdpdGggZW50cnkgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkOiBDaGFuZ2VkIGxhYmVsIHRvIFwiVG90YWwgRGF5c1wiXG4gICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRGF5c1RleHQgPSBgLCBEYXlzIHdpdGggRW50cnk6IDxzcGFuIGNsYXNzPVwic3RhdC12YWx1ZVwiPiR7cmVjb3JkZWREYXlzQ291bnRQZXJpb2R9PC9zcGFuPi88c3BhbiBjbGFzcz1cInN0YXQtZGVub21pbmF0b3JcIj4ke3RvdGFsRGF5c0luUGVyaW9kfTwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VWYWx1ZVRleHQgPSBgLCBBdmVyYWdlIFZhbHVlOiA8c3BhbiBjbGFzcz1cInN0YXQtdmFsdWVcIj5OL0E8L3NwYW4+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEYXlzVGV4dCA9IGAsIERheXMgd2l0aCBFbnRyeTogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+MDwvc3Bhbj4vPHNwYW4gY2xhc3M9XCJzdGF0LWRlbm9taW5hdG9yXCI+JHt0b3RhbERheXNJblBlcmlvZH08L3NwYW4+YDtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgLy8gVXNlIGNyZWF0ZUVsIHdpdGggaW5uZXJIVE1MIGZvciB0aGUgY29tYmluZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgc3RhdHNTdW1tYXJ5Q29udGFpbmVyLmNyZWF0ZUVsKCdwJywgeyBjbHM6ICdpbmxpbmUtc3RhdHMtcGFyYWdyYXBoJyB9KS5pbm5lckhUTUwgPSB0b3RhbFZhbHVlVGV4dCArIGF2ZXJhZ2VWYWx1ZVRleHQgKyB0b3RhbERheXNUZXh0O1xuXG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkOiBBZGQgZGV0YWlsZWQgdGV4dCBoYWJpdCBzdGF0aXN0aWNzXG4gICAgICAgICAgICAgICAgICAgLy8gQ291bnQgZGF5cyB3aXRoIGFueSB0ZXh0IGVudHJ5IChyZWNvcmRlZERheXNDb3VudFBlcmlvZCBhbHJlYWR5IGRvZXMgdGhpcylcbiAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbEVudHJpZXMgPSByZWNvcmRlZERheXNDb3VudFBlcmlvZDtcbiAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbEVudHJpZXNUZXh0ID0gYERheXMgd2l0aCBFbnRyeTogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHt0b3RhbEVudHJpZXN9PC9zcGFuPi88c3BhbiBjbGFzcz1cInN0YXQtZGVub21pbmF0b3JcIj4ke3RvdGFsRGF5c0luUGVyaW9kfTwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgIHN0YXRzU3VtbWFyeUNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgY2xzOiAnaW5saW5lLXN0YXRzLXBhcmFncmFwaCcgfSkuaW5uZXJIVE1MID0gdG90YWxFbnRyaWVzVGV4dDtcblxuICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbEVudHJpZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgcHJvcG9ydGlvbnMgZm9yIGVhY2ggdW5pcXVlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlVGV4dHMgPSBPYmplY3Qua2V5cyh0ZXh0VmFsdWVDb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IHVuaXF1ZSB0ZXh0cyBhbHBoYWJldGljYWxseSBvciBieSBjb3VudCBpZiBwcmVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlVGV4dHMuc29ydCgpOyAvLyBTaW1wbGUgYWxwaGFiZXRpY2FsIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlVGV4dHMuZm9yRWFjaCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGV4dFZhbHVlQ291bnRzW3RleHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IChjb3VudCAvIHRvdGFsRW50cmllcykgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3RhdEh0bWwgPSBgJHt0ZXh0fTogPHNwYW4gY2xhc3M9XCJzdGF0LXZhbHVlXCI+JHtjb3VudH08L3NwYW4+ICg8c3BhbiBjbGFzcz1cInN0YXQtdmFsdWVcIj4ke3BlcmNlbnRhZ2UudG9GaXhlZCgxKX0lPC9zcGFuPilgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNTdW1tYXJ5Q29udGFpbmVyLmNyZWF0ZUVsKCdwJywgeyBjbHM6ICdpbmxpbmUtc3RhdHMtcGFyYWdyYXBoIHRleHQtc3RhdC1kZXRhaWwnIH0pLmlubmVySFRNTCA9IHRleHRTdGF0SHRtbDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgIGNvbnN0IHZpc3VhbGl6YXRpb25Db250YWluZXIgPSBoYWJpdFN0YXRzU2VjdGlvbi5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoYWJpdC12aXN1YWxpemF0aW9uLWNvbnRhaW5lcicgfSk7XG5cbiAgICAgICAgICAgICAgIC8vIC0tLSBDb25kaXRpb25hbCBSZW5kZXJpbmcgYmFzZWQgb24gSGFiaXQgVHlwZSBhbmQgU3RhdHMgUGVyaW9kIC0tLVxuICAgICAgICAgICAgICAgLy8gSGVhdG1hcCBpcyBmb3IgQm9vbGVhbi9UZXh0IChhbHdheXMgaW4geWVhciB2aWV3KSBvciBOdW1iZXIgKGlmIHN0YXRzVHlwZSBpcyBoZWF0bWFwIGFuZCBwZXJpb2QgaXMgeWVhcilcbiAgICAgICAgICAgICAgIC8vIENoYXJ0cyBhcmUgZm9yIE51bWJlciAoYmFyL2xpbmUvY29tYm8pIGluIG1vbnRoIG9yIHllYXIgdmlld1xuXG4gICAgICAgICAgICAgICAvLyBFbnN1cmUgaGFiaXQuc3RhdHNUeXBlIGlzIGRlZmF1bHRlZCBpZiBtaXNzaW5nXG4gICAgICAgICAgICAgICBjb25zdCBoYWJpdFN0YXRzVHlwZSA9IGhhYml0LnN0YXRzVHlwZSB8fCAoaGFiaXQudHlwZSA9PT0gJ251bWJlcicgPyAnYmFyJyA6ICdoZWF0bWFwJyk7XG5cblxuICAgICAgICAgICAgICAgY29uc3QgaXNIZWF0bWFwID0gaGFiaXRTdGF0c1R5cGUgPT09ICdoZWF0bWFwJzsgLy8gSGVhdG1hcCBpcyBvbmx5IGNvbmZpZ3VyZWQgdHlwZSBmb3IgYm9vbGVhbi90ZXh0LCBhbmQgYW4gb3B0aW9uIGZvciBudW1iZXJcbiAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hhcnQgPSAhaXNIZWF0bWFwICYmIGhhYml0LnR5cGUgPT09ICdudW1iZXInOyAvLyBDaGFydHMgYXJlIG9ubHkgZm9yIG51bWJlciBoYWJpdHMgd2l0aCBub24taGVhdG1hcCBzdGF0c1R5cGVcblxuXG4gICAgICAgICAgICAgICBpZiAoaXNIZWF0bWFwKSB7XG4gICAgICAgICAgICAgICAgICAgLy8gLS0tIFJlbmRlciBIZWF0bWFwIEdyaWQgLS0tXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRzUGVyaW9kICE9PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9WaXpNZXNzYWdlID0gdmlzdWFsaXphdGlvbkNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgY2xzOiAnbm8tdmlzdWFsaXphdGlvbi1tZXNzYWdlJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgbm9WaXpNZXNzYWdlLnNldFRleHQoYEhlYXRtYXAgdmlzdWFsaXphdGlvbiBmb3IgJHtoYWJpdC50eXBlfSBoYWJpdHMgaXMgb25seSBhdmFpbGFibGUgaW4gWWVhciB2aWV3LmApO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHllYXIgLSBIZWF0bWFwIGZvciBCb29sZWFuL1RleHQgKGRlZmF1bHQpIG9yIE51bWJlciAoaWYgc3RhdHNUeXBlIGlzIGhlYXRtYXApXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHllYXJseUhlYXRtYXBDb250YWluZXIgPSB2aXN1YWxpemF0aW9uQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LXN0YXRzLXllYXJseS1oZWF0bWFwLWNvbnRhaW5lcicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0WWVhciA9IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKTtcblxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoU3RhcnREYXRlID0gc3RhcnRZZWFyLmNsb25lKCkuYWRkKGksICdtb250aHMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9udGhseUhlYXRtYXBDb250YWluZXIgPSB5ZWFybHlIZWF0bWFwQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hhYml0LXN0YXRzLW1vbnRobHktaGVhdG1hcCcgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRobHlIZWF0bWFwQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IHRleHQ6IG1vbnRoU3RhcnREYXRlLmZvcm1hdCgnTU1NJyksIGNsczogJ21vbnRobHktaGVhdG1hcC1sYWJlbCcgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdGVkIGRheSBvZiB3ZWVrIGxhYmVscyBiYXNlZCBvbiBzdGFydCBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlPZldlZWtMYWJlbHNTaG9ydCA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkRGF5c09mV2VlayA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnREYXlJbmRleCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLndlZWtTdGFydHNPbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgNzsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZERheXNPZldlZWsucHVzaChkYXlPZldlZWtMYWJlbHNTaG9ydFsoc3RhcnREYXlJbmRleCArIGQpICUgN10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlPZldlZWtIZWFkZXJSb3cgPSBtb250aGx5SGVhdG1hcENvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb250aGx5LWhlYXRtYXAtZGF5b2Z3ZWVrLXJvdycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkRGF5c09mV2Vlay5mb3JFYWNoKGRheUxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlPZldlZWtIZWFkZXJSb3cuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogZGF5TGFiZWwuc3Vic3RyaW5nKDAsIDEpLCBjbHM6ICdtb250aGx5LWhlYXRtYXAtZGF5b2Z3ZWVrLWxhYmVsJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aEdyaWQgPSBtb250aGx5SGVhdG1hcENvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoZWF0bWFwLWdyaWQtbW9udGgnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhHcmlkLnN0eWxlLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBgcmVwZWF0KDcsIDFmcilgO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBtb250aFN0YXJ0RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ21vbnRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlPZldlZWtPZkZpcnN0RGF5ID0gZmlyc3REYXlPZk1vbnRoLmRheSgpOyAvLyAwIGZvciBTdW5kYXksIDYgZm9yIFNhdHVyZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUNlbGxzTmVlZGVkID0gKGRheU9mV2Vla09mRmlyc3REYXkgLSB0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWVrU3RhcnRzT24gKyA3KSAlIDc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZW1wdHlDZWxsc05lZWRlZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhHcmlkLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hlYXRtYXAtY2VsbCBlbXB0eScgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mTW9udGggPSBtb250aFN0YXJ0RGF0ZS5jbG9uZSgpLmRhdGUobW9udGhTdGFydERhdGUuZGF5c0luTW9udGgoKSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudERheUluTW9udGggPSBtb250aFN0YXJ0RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudERheUluTW9udGguaXNTYW1lT3JCZWZvcmUoZW5kT2ZNb250aCwgJ2RheScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGN1cnJlbnREYXlJbk1vbnRoLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gbW9udGhHcmlkLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2hlYXRtYXAtY2VsbCcgfSk7IC8vIFVzZSBoZWF0bWFwLWNlbGwgY2xhc3NcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIEZvciB0ZXh0IGhhYml0cywgZGlzcGxheSB0aGUgdGV4dCB2YWx1ZSBpbnNpZGUgdGhlIGhlYXRtYXAgY2VsbCBpdHNlbGYgLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdTdGF0dXMgPSBjb21wbGV0aW9uRGF0YVtkYXRlXT8uW2hhYml0Lm5hbWVdOyAvLyBHZXQgcmF3IHN0YXR1cyBhZ2FpbiBmb3IgdGV4dCBkaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3U3RhdHVzID09PSAnc3RyaW5nJyAmJiByYXdTdGF0dXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBsaWtlbHkgYW4gZW1vamkgdG8gYXBwbHkgZW1vamkgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xpa2VseUVtb2ppID0gcmF3U3RhdHVzLmxlbmd0aCA+IDAgJiYgcmF3U3RhdHVzLmxlbmd0aCA8PSA0OyAvLyBTaW1wbGUgaGV1cmlzdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaWtlbHlFbW9qaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY3JlYXRlU3Bhbih7IHRleHQ6IHJhd1N0YXR1cywgY2xzOiAnaGVhdG1hcC10ZXh0LXZhbHVlIGlzLWVtb2ppJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFkZENsYXNzKCdpcy1lbW9qaScpOyAvLyBBZGQgY2xhc3MgdG8gY2VsbCBmb3IgZW1vamkgc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNyZWF0ZVNwYW4oeyB0ZXh0OiByYXdTdGF0dXMsIGNsczogJ2hlYXRtYXAtdGV4dC12YWx1ZScgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U3RhdHVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbZGF0ZV0/LltoYWJpdC5uYW1lXSA/PyBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBoZWF0bWFwLCB3ZSBuZWVkIHRvIHBhc3MgdGhlIGFwcHJvcHJpYXRlIHN0YXR1cyBiYXNlZCBvbiB0eXBlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gQm9vbGVhbiAoRGFpbHkgR29hbCA8PSAxIG9yIFdlZWtseSk6IHJhd1N0YXR1cyAodHJ1ZS9udWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gQm9vbGVhbiAoRGFpbHkgR29hbCA+IDEpOiByYXdTdGF0dXMgKG51bWJlciBjb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIE51bWJlcjogZGFpbHkgc3VtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBUZXh0OiByYXdTdGF0dXMgKHN0cmluZykgLS0gTm90ZTogRm9yIFRleHQgaGVhdG1hcCwgdGhlIGNvbG9yaW5nIGlzIGp1c3QgcHJlc2VuY2UvYWJzZW5jZSBmb3IgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzRm9yQXBwZWFyYW5jZTogYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSByYXdTdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LnR5cGUgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkocmF3U3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNGb3JBcHBlYXJhbmNlID0gcmF3U3RhdHVzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9tZW50KCkuaXNTYW1lKGRhdGUsICdkYXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFkZENsYXNzKCdpcy10b2RheScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBQYXNzIHdlZWtseSBwZXJjZW50YWdlIGZvciB3ZWVrbHkgYm9vbGVhbiBoZWF0bWFwcyAtLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla2x5UGVyY2VudGFnZUZvckNlbGw6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnYm9vbGVhbicgJiYgaGFiaXQuZnJlcXVlbmN5ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Vla1N0YXJ0RGF0ZUZvckNlbGwgPSBjdXJyZW50RGF5SW5Nb250aC5jbG9uZSgpLnN0YXJ0T2YoJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Vla1N0YXJ0RGF0ZVN0cmluZyA9IHdlZWtTdGFydERhdGVGb3JDZWxsLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vla2x5UGVyY2VudGFnZUZvckNlbGwgPSB3ZWVrbHlCb29sZWFuUGVyY2VudGFnZXNbd2Vla1N0YXJ0RGF0ZVN0cmluZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gQ2VsbCAke2RhdGV9IGJlbG9uZ3MgdG8gd2VlayBzdGFydGluZyAke3dlZWtTdGFydERhdGVTdHJpbmd9LiBQZXJjZW50YWdlOiAke3dlZWtseVBlcmNlbnRhZ2VGb3JDZWxsfWApOyAvLyBMb2cgd2Vla2x5IHBlcmNlbnRhZ2UgbG9va3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYXBwZWFyYW5jZSBiYXNlZCBvbiB0aGUgZGFpbHkgc3RhdHVzIGFuZCBoYWJpdCB0eXBlICh1c2luZyB0aGUgc2hhcmVkIGhlbHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2hhcmVkIGhlbHBlciB3aWxsIGhhbmRsZSBjb2xvcmluZyBsb2dpYyBpbmNsdWRpbmcgd2Vla2x5IGJvb2xlYW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwYXNzIHRoZSBjZWxsIGVsZW1lbnQgaXRzZWxmLCB0aGUgaGFiaXQgb2JqZWN0LCBhbmQgdGhlIGFwcHJvcHJpYXRlIHN0YXR1c0ZvckFwcGVhcmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBjZWxsIGl0c2VsZiBmb3IgaGVhdG1hcCBzdHlsaW5nLCBBTkQgdGhlIHdlZWtseSBwZXJjZW50YWdlIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNlbGxBcHBlYXJhbmNlKGNlbGwsIGhhYml0LCBzdGF0dXNGb3JBcHBlYXJhbmNlLCB3ZWVrbHlQZXJjZW50YWdlRm9yQ2VsbCk7IC8vIFBhc3Mgd2Vla2x5UGVyY2VudGFnZVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG9vbHRpcCBzaG93aW5nIGRhdGUgYW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBUZXh0ID0gYCR7aGFiaXQubmFtZX0gLSAke2RhdGV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3U3RhdHVzICE9PSBudWxsICYmIHJhd1N0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC5mcmVxdWVuY3kgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGFpbHkgYm9vbGVhbjogU2hvdyBkYWlseSBzdGF0dXMgYW5kIGNvdW50IGlmIGdvYWwgPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhaWx5U3RhdHVzRGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJhd1N0YXR1cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx1NTk4Mlx1Njc5QyByYXdTdGF0dXMgXHU2NjJGXHU0RTAwXHU0RTJBXHU1RTAzXHU1QzE0XHU1MDNDICh0cnVlL2ZhbHNlKVx1RkYwQ1x1NTIxOVx1NjMwOVx1NkI2M1x1NUUzOFx1NUUwM1x1NUMxNFx1OTAzQlx1OEY5MVx1NjYzRVx1NzkzQVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYWlseVN0YXR1c0Rpc3BsYXkgPSByYXdTdGF0dXMgPT09IHRydWUgPyAnQ29tcGxldGVkJyA6ICdOb3QgQ29tcGxldGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXdTdGF0dXMgPT09ICdudW1iZXInICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx1NTk4Mlx1Njc5QyByYXdTdGF0dXMgXHU2NjJGXHU0RTAwXHU0RTJBXHU2NTcwXHU1QjU3IChcdTRGOEJcdTU5ODIgMylcdUZGMENcdTVFNzZcdTRFMTRcdThCQkVcdTdGNkVcdTRFODZcdTc2RUVcdTY4MDcgKGNvbXBsZXRpb25Hb2FsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcdTUyMTlcdTUyMjRcdTY1QURcdTY2MkZcdTU0MjZcdThGQkVcdTUyMzBcdTc2RUVcdTY4MDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFpbHlTdGF0dXNEaXNwbGF5ID0gcmF3U3RhdHVzID49IGhhYml0LmNvbXBsZXRpb25Hb2FsID8gJ0NvbXBsZXRlZCcgOiAnTm90IENvbXBsZXRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHU1MTc2XHU0RUQ2XHU2MEM1XHU1MUI1XHVGRjA4XHU0RjhCXHU1OTgyIHJhd1N0YXR1cyBcdTY1RTJcdTRFMERcdTY2MkZcdTVFMDNcdTVDMTRcdTRFNUZcdTRFMERcdTY2MkZcdTY1NzBcdTVCNTdcdUZGMENcdTYyMTZcdTgwMDVcdTZDQTFcdTY3MDlcdThCQkVcdTdGNkVcdTc2RUVcdTY4MDdcdUZGMDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFpbHlTdGF0dXNEaXNwbGF5ID0gJ05vdCBDb21wbGV0ZWQnOyAvLyBcdTlFRDhcdThCQTRcdTY2M0VcdTc5M0FcdTRFM0EgJ05vdCBDb21wbGV0ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGA6ICR7ZGFpbHlTdGF0dXNEaXNwbGF5fWA7IC8vIFx1NUU5NFx1NzUyOFx1Nzg2RVx1NUI5QVx1NzY4NFx1NzJCNlx1NjAwMVx1NjU4N1x1NjcyQ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgPiAxICYmIHR5cGVvZiByYXdTdGF0dXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dCArPSBgICgke3Jhd1N0YXR1c30vJHtoYWJpdC5jb21wbGV0aW9uR29hbH0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBmcmVxdWVuY3kgPT09ICd3ZWVrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlZWtseSBib29sZWFuOiBTaG93IGRhaWx5IHN0YXR1cyBBTkQgd2Vla2x5IHByb2dyZXNzICh1c2UgcHJlLWNhbGN1bGF0ZWQgcGVyY2VudGFnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dCArPSBgOiAke3Jhd1N0YXR1cyA9PT0gdHJ1ZSA/ICdDb21wbGV0ZWQgZm9yIHRvZGF5JyA6ICdOb3QgY29tcGxldGVkIGZvciB0b2RheSd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Vla1N0YXJ0RGF0ZUZvckNlbGwgPSBjdXJyZW50RGF5SW5Nb250aC5jbG9uZSgpLnN0YXJ0T2YoJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Vla1N0YXJ0RGF0ZVN0cmluZyA9IHdlZWtTdGFydERhdGVGb3JDZWxsLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Vla2x5UGVyY2VudGFnZSA9IHdlZWtseUJvb2xlYW5QZXJjZW50YWdlc1t3ZWVrU3RhcnREYXRlU3RyaW5nXSAhPT0gdW5kZWZpbmVkID8gd2Vla2x5Qm9vbGVhblBlcmNlbnRhZ2VzW3dlZWtTdGFydERhdGVTdHJpbmddIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvbkdvYWwgPSBoYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSBudWxsICYmIGhhYml0LmNvbXBsZXRpb25Hb2FsID4gMCA/IGhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB3ZWVrbHkgY29tcGxldGlvbnMgaGVyZSBmb3IgdG9vbHRpcCBkaXNwbGF5IGFjY3VyYWN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ZWVrbHlDb21wbGV0aW9uc0ZvclRvb2x0aXAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWVrRW5kRGF0ZUZvckNlbGwgPSB3ZWVrU3RhcnREYXRlRm9yQ2VsbC5jbG9uZSgpLmVuZE9mKCd3ZWVrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXlJdGVyYXRvckZvclRvb2x0aXAgPSB3ZWVrU3RhcnREYXRlRm9yQ2VsbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGF5SXRlcmF0b3JGb3JUb29sdGlwLmlzU2FtZU9yQmVmb3JlKHdlZWtFbmREYXRlRm9yQ2VsbCwgJ2RheScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF5U3RyID0gZGF5SXRlcmF0b3JGb3JUb29sdGlwLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNGb3JEYXkgPSBjb21wbGV0aW9uRGF0YVtkYXlTdHJdPy5baGFiaXQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0ZvckRheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlDb21wbGV0aW9uc0ZvclRvb2x0aXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5SXRlcmF0b3JGb3JUb29sdGlwLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dCArPSBgIChXZWVrIFByb2dyZXNzOiAke3dlZWtseUNvbXBsZXRpb25zRm9yVG9vbHRpcH0vJHtjb21wbGV0aW9uR29hbH0sICR7d2Vla2x5UGVyY2VudGFnZS50b0ZpeGVkKDEpfSUpYDsgLy8gQWRkIHdlZWtseSBwcm9ncmVzcyBhbmQgcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYWlseVN1bSA9IEFycmF5LmlzQXJyYXkocmF3U3RhdHVzKSA/IHJhd1N0YXR1cy5yZWR1Y2UoKHN1bSwgY3VycmVudCkgPT4gc3VtICsgY3VycmVudCwgMCkgOiAodHlwZW9mIHJhd1N0YXR1cyA9PT0gJ251bWJlcicgPyByYXdTdGF0dXMgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGA6ICR7ZGFpbHlTdW0udG9GaXhlZCgyKX0ke2hhYml0LnVuaXQgfHwgJyd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC5nb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuZ29hbCAhPT0gbnVsbCAmJiBoYWJpdC5nb2FsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGAgKEdvYWw6ICR7aGFiaXQuZ29hbH0ke2hhYml0LnVuaXQgfHwgJyd9KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGV4dCArPSBgOiBcIiR7cmF3U3RhdHVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGA6IE5vIGVudHJ5YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0b29sdGlwVGV4dCk7IC8vIEFkZCB0b29sdGlwXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjbGljayBldmVudCBsaXN0ZW5lciAtIG9wZW5zIG1vZGFsIChzYW1lIGFzIGNoZWNrLWluIGdyaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZEhhYml0TmFtZSA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhYml0LW5hbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2tlZERhdGUgPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrZWRIYWJpdFR5cGUgPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1oYWJpdC10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrZWRIYWJpdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0cy5maW5kKGggPT4gaC5uYW1lID09PSBjbGlja2VkSGFiaXROYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaWNrZWRIYWJpdE5hbWUgfHwgIWNsaWNrZWREYXRlIHx8ICFjbGlja2VkSGFiaXRUeXBlIHx8ICFjbGlja2VkSGFiaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDbGlja2VkIGNlbGwgbWlzc2luZyBkYXRhIGF0dHJpYnV0ZXMgb3IgaGFiaXQgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjbGljayBiYXNlZCBvbiBoYWJpdCB0eXBlIChzYW1lIGxvZ2ljIGFzIGNoZWNrLWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpY2tlZEhhYml0VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uR29hbCA9IGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIGNsaWNrZWRIYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gbnVsbCAmJiBjbGlja2VkSGFiaXQuY29tcGxldGlvbkdvYWwgPiAwID8gY2xpY2tlZEhhYml0LmNvbXBsZXRpb25Hb2FsIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlja2VkSGFiaXQuZnJlcXVlbmN5ID09PSAnZGF5JyAmJiBjb21wbGV0aW9uR29hbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvdW50ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdIGFzIG51bWJlciB8IG51bGwgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q291bnQgPSBjdXJyZW50Q291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb3VudCA+IGNvbXBsZXRpb25Hb2FsKSBuZXdDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdID0gbmV3Q291bnQgPiAwID8gbmV3Q291bnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7Y2xpY2tlZEhhYml0TmFtZX0gb24gJHtjbGlja2VkRGF0ZX06IENvdW50OiAke25ld0NvdW50ID4gMCA/IG5ld0NvdW50IDogJzAnfS8ke2NvbXBsZXRpb25Hb2FsfS5gLCAyMDAwKTsgLy8gU2hvcnRlciBub3RpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2NsaWNrZWREYXRlXVtjbGlja2VkSGFiaXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0dXMgPSBjdXJyZW50U3RhdHVzID09PSB0cnVlID8gbnVsbCA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbY2xpY2tlZERhdGVdW2NsaWNrZWRIYWJpdE5hbWVdID0gbmV3U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7Y2xpY2tlZEhhYml0TmFtZX0gb24gJHtjbGlja2VkRGF0ZX0gJHtuZXdTdGF0dXMgPT09IHRydWUgPyAnbWFya2VkIGFzIENvbXBsZXRlZC4nIDogJ2VudHJ5IGNsZWFyZWQuJ31gLCAyMDAwKTsgLy8gU2hvcnRlciBub3RpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogT25seSByZS1yZW5kZXIgdGhlIHN0YXRzIGNvbnRlbnQgKHdoaWNoIGluY2x1ZGVzIGhlYXRtYXApIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRzQ29udGVudCh0aGlzLnN0YXRzQ29udGVudENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gRU5EIE1PRElGSUVEIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsaWNrZWRIYWJpdFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTnVtYmVySW5wdXRNb2RhbCh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sIGNsaWNrZWREYXRlLCBjbGlja2VkSGFiaXROYW1lLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV1bY2xpY2tlZEhhYml0TmFtZV0gYXMgbnVtYmVyW10gfCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBNT0RJRklFRDogT25seSByZS1yZW5kZXIgdGhlIHN0YXRzIGNvbnRlbnQgKHdoaWNoIGluY2x1ZGVzIGhlYXRtYXApIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRzQ29udGVudCh0aGlzLnN0YXRzQ29udGVudENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gRU5EIE1PRElGSUVEIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGlja2VkSGFiaXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0SW5wdXRNb2RhbCh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sIGNsaWNrZWREYXRlLCBjbGlja2VkSGFiaXROYW1lLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtjbGlja2VkRGF0ZV1bY2xpY2tlZEhhYml0TmFtZV0gYXMgc3RyaW5nIHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIE1PRElGSUVEOiBPbmx5IHJlLXJlbmRlciB0aGUgc3RhdHMgY29udGVudCAod2hpY2ggaW5jbHVkZXMgaGVhdG1hcCkgLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0c0NvbnRlbnQodGhpcy5zdGF0c0NvbnRlbnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gRU5EIE1PRElGSUVEIC0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXlJbk1vbnRoLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbXB0eSBjZWxscyBhdCB0aGUgZW5kIHRvIGNvbXBsZXRlIHRoZSBsYXN0IHdlZWsgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsc0FscmVhZHlBZGRlZCA9IG1vbnRoR3JpZC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGF5cyByZW1haW5pbmcgaW4gdGhlIGxhc3Qgd2VlayByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0NlbGxzID0gKDcgLSAoY2VsbHNBbHJlYWR5QWRkZWQgJSA3KSkgJSA3O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVtYWluaW5nQ2VsbHM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoR3JpZC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdoZWF0bWFwLWNlbGwgZW1wdHknIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgY2hhcnRzIG9ubHkgZm9yIE51bWJlciBoYWJpdHMgd2l0aCBjaGFydCB0eXBlc1xuICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtIYWJpdCBUcmFja2VyXSBDaGFydCByZW5kZXJpbmcgYXR0ZW1wdCBmb3Igbm9uLW51bWJlciBoYWJpdCBcIiR7aGFiaXQubmFtZX1cIiAoVHlwZTogJHtoYWJpdC50eXBlfSwgU3RhdHNUeXBlOiAke2hhYml0U3RhdHNUeXBlfSkuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vVml6TWVzc2FnZSA9IHZpc3VhbGl6YXRpb25Db250YWluZXIuY3JlYXRlRWwoJ3AnLCB7IGNsczogJ25vLXZpc3VhbGl6YXRpb24tbWVzc2FnZScgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgIG5vVml6TWVzc2FnZS5zZXRUZXh0KGBDaGFydHMgYXJlIG9ubHkgYXZhaWxhYmxlIGZvciBOdW1iZXIgaGFiaXRzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNraXAgY2hhcnQgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFydENvbnRhaW5lciA9IHZpc3VhbGl6YXRpb25Db250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnaGFiaXQtY2hhcnQtY29udGFpbmVyJyB9KTtcbiAgICAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBjaGFydENvbnRhaW5lci5jcmVhdGVFbCgnY2FudmFzJyk7XG5cbiAgICAgICAgICAgICAgICAgICBsZXQgY2hhcnRMYWJlbHM6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICAgICAgICAgbGV0IGNoYXJ0RGF0YVBlcmlvZFRvdGFsOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgIGxldCBjaGFydERhdGFDdW11bGF0aXZlQXZlcmFnZTogbnVtYmVyW10gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBcIllZWVktTU0tRERcIjtcblxuICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0c1BlcmlvZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGFnZ3JlZ2F0aW9uIGZvciBtb250aCB2aWV3IChvbmx5IE51bWJlciB0eXBlcyB3aXRoIGJhci9saW5lL2NvbWJvIHJlYWNoIGhlcmUpXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVzSW5DdXJyZW50TW9udGggPSBhbGxEYXRlc0luUGVyaW9kLmZpbHRlcihkYXRlID0+IG1vbWVudChkYXRlLCBkYXRlRm9ybWF0KS5pc1NhbWUodGhpcy5jdXJyZW50U3RhdHNEYXRlLCAnbW9udGgnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1bXVsYXRpdmVUb3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBjdW11bGF0aXZlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBkYXlzIHdpdGggZGF0YSA+IDBcblxuICAgICAgICAgICAgICAgICAgICAgICBkYXRlc0luQ3VycmVudE1vbnRoLmZvckVhY2goZGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdTdGF0dXMgPSBjb21wbGV0aW9uRGF0YVtkYXRlXT8uW2hhYml0Lm5hbWVdID8/IG51bGw7IC8vIFVzZSBudWxsaXNoIGNvYWxlc2NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYWlseVZhbHVlID0gMDsgLy8gRGVmYXVsdCB0byAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhdGEgZm9yIG51bWJlciBoYWJpdCBpcyBhbHdheXMgYW4gYXJyYXkgb3IgbnVsbCBhZnRlciBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYWlseVZhbHVlID0gcmF3U3RhdHVzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd1N0YXR1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgdW5leHBlY3RlZCBzaW5nbGUgbnVtYmVyIGRhdGEgKHNob3VsZCBiZSByYXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIEVuY291bnRlcmVkIHNpbmdsZSBudW1iZXIgZGF0YSBmb3IgXCIke2hhYml0Lm5hbWV9XCIgb24gJHtkYXRlfSBkdXJpbmcgc3RhdHMgYWdncmVnYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFpbHlWYWx1ZSA9IHJhd1N0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFydERhdGFQZXJpb2RUb3RhbC5wdXNoKGRhaWx5VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGl2ZVRvdGFsICs9IGRhaWx5VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGFpbHlWYWx1ZSA+IDApIGN1bXVsYXRpdmVDb3VudCArPSAxOyAvLyBDb3VudCBkYXlzIHdpdGggZW50cnkgPiAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0RGF0YUN1bXVsYXRpdmVBdmVyYWdlLnB1c2goY3VtdWxhdGl2ZUNvdW50ID4gMCA/IGN1bXVsYXRpdmVUb3RhbCAvIGN1bXVsYXRpdmVDb3VudCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRMYWJlbHMgPSBkYXRlc0luQ3VycmVudE1vbnRoLm1hcChkYXRlID0+IG1vbWVudChkYXRlLCBkYXRlRm9ybWF0KS5mb3JtYXQoJ01NLUREJykpO1xuXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8geWVhciAtIEFnZ3JlZ2F0ZSBkYXRhIFdFRUtMWSBmb3IgdGhlIHllYXIgKG9ubHkgTnVtYmVyIHR5cGVzIHdpdGggYmFyL2xpbmUvY29tYm8gcmVhY2ggaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeWVhclN0YXJ0RGF0ZSA9IHRoaXMuY3VycmVudFN0YXRzRGF0ZS5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeWVhckVuZERhdGUgPSB0aGlzLmN1cnJlbnRTdGF0c0RhdGUuY2xvbmUoKS5lbmRPZigneWVhcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCB3ZWVrSXRlcmF0b3IgPSB5ZWFyU3RhcnREYXRlLmNsb25lKCkuc3RhcnRPZignd2VlaycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBjdW11bGF0aXZlV2Vla2x5VG90YWxTdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VtdWxhdGl2ZVdlZWtzV2l0aEVudHJpZXNDb3VudCA9IDA7IC8vIENvdW50IHdlZWtzIHdpdGggYXQgbGVhc3Qgb25lIGRheSBoYXZpbmcgZW50cnkgPiAwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmaXJzdCB3ZWVrIG51bWJlciB0byBzdGFydCBsYWJlbHMgZnJvbSAxXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0V2Vla09mWWVhck1vbWVudCA9IHllYXJTdGFydERhdGUuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJyk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod2Vla0l0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHllYXJFbmREYXRlLCAnZGF5JykpIHsgLy8gSXRlcmF0ZSB3ZWVrIGJ5IHdlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ZWVrbHlUb3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2Vla2x5RW50cnlDb3VudCA9IDA7IC8vIENvdW50IGRheXMgd2l0aCBlbnRyeSA+IDAgaW4gdGhlIHdlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtFbmREYXRlID0gd2Vla0l0ZXJhdG9yLmNsb25lKCkuZW5kT2YoJ3dlZWsnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWdncmVnYXRlIGRhdGEgZm9yIHRoZSBjdXJyZW50IHdlZWssIGVuc3VyaW5nIHdlIHN0YXkgd2l0aGluIHRoZSB5ZWFyJ3MgYm91bmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF5SXRlcmF0b3IgPSB3ZWVrSXRlcmF0b3IuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChkYXlJdGVyYXRvci5pc1NhbWVPckJlZm9yZSh3ZWVrRW5kRGF0ZSwgJ2RheScpICYmIGRheUl0ZXJhdG9yLmlzU2FtZU9yQmVmb3JlKHllYXJFbmREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gZGF5SXRlcmF0b3IuZm9ybWF0KGRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1N0YXR1cyA9IGNvbXBsZXRpb25EYXRhW2RhdGVTdHJpbmddPy5baGFiaXQubmFtZV0gPz8gbnVsbDsgLy8gVXNlIG51bGxpc2ggY29hbGVzY2luZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LnR5cGUgPT09ICdudW1iZXInKSB7IC8vIFNob3VsZCBhbHdheXMgYmUgbnVtYmVyIGhlcmUgZHVlIHRvIGZpbHRlcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYWlseVN1bSA9IHJhd1N0YXR1cy5yZWR1Y2UoKHN1bSwgY3VycmVudCkgPT4gc3VtICsgY3VycmVudCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWVrbHlUb3RhbCArPSBkYWlseVN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYWlseVN1bSA+IDApIHdlZWtseUVudHJ5Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmF3U3RhdHVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIHVuZXhwZWN0ZWQgc2luZ2xlIG51bWJlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtIYWJpdCBUcmFja2VyXSBFbmNvdW50ZXJlZCBzaW5nbGUgbnVtYmVyIGRhdGEgZm9yIFwiJHtoYWJpdC5uYW1lfVwiIG9uICR7ZGF0ZVN0cmluZ30gZHVyaW5nIHN0YXRzIGFnZ3JlZ2F0aW9uLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vla2x5VG90YWwgKz0gcmF3U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1N0YXR1cyA+IDApIHdlZWtseUVudHJ5Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlJdGVyYXRvci5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGRhdGEgcG9pbnRzIGZvciB3ZWVrcyB0aGF0IGFyZSBhdCBsZWFzdCBwYXJ0aWFsbHkgd2l0aGluIHRoZSBzZWxlY3RlZCBwZXJpb2QgKHllYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbG9vcCBjb25kaXRpb24gZW5zdXJlcyB3ZSBhcmUgd2l0aGluIHRoZSB5ZWFyIGJvdW5kcywgYnV0IGNoZWNraW5nIGFnYWluIGZvciBjbGFyaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZmllZCBjb25kaXRpb24gdG8gY2hlY2sgaWYgdGhlIHdlZWsgb3ZlcmxhcHMgKmF0IGFsbCogd2l0aCB0aGUgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlZWtJdGVyYXRvci5pc1NhbWVPckJlZm9yZSh5ZWFyRW5kRGF0ZSwgJ2RheScpICYmIHdlZWtFbmREYXRlLmlzU2FtZU9yQWZ0ZXIoeWVhclN0YXJ0RGF0ZSwgJ2RheScpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgd2VlayBudW1iZXIgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSB5ZWFyLCBoYW5kbGluZyBwb3RlbnRpYWwgd2VlayAwIGlzc3VlIHdpdGggc29tZSBtb21lbnQgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXlzU2luY2VZZWFyU3RhcnQgPSB3ZWVrSXRlcmF0b3IuZGlmZih5ZWFyU3RhcnREYXRlLmNsb25lKCkuc3RhcnRPZignZGF5JyksICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVudGlhbFdlZWtJbmRleCA9IE1hdGguZmxvb3IoZGF5c1NpbmNlWWVhclN0YXJ0IC8gNyk7IC8vIFNpbXBsZSBpbmRleFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRMYWJlbHMucHVzaChgVyR7c2VxdWVudGlhbFdlZWtJbmRleCArIDF9YCk7IC8vIExhYmVsIGxpa2UgVzEsIFcyLCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnREYXRhUGVyaW9kVG90YWwucHVzaCh3ZWVrbHlUb3RhbCk7IC8vIFVzZSB3ZWVrbHkgdG90YWxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVXZWVrbHlUb3RhbFN1bSArPSB3ZWVrbHlUb3RhbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWVrbHlFbnRyeUNvdW50ID4gMCkgeyAvLyBDb3VudCB3ZWVrcyB3aXRoIGF0IGxlYXN0IG9uZSBkYXkgaGF2aW5nIGVudHJ5ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0aXZlV2Vla3NXaXRoRW50cmllc0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnREYXRhQ3VtdWxhdGl2ZUF2ZXJhZ2UucHVzaChjdW11bGF0aXZlV2Vla3NXaXRoRW50cmllc0NvdW50ID4gMCA/IGN1bXVsYXRpdmVXZWVrbHlUb3RhbFN1bSAvIGN1bXVsYXRpdmVXZWVrc1dpdGhFbnRyaWVzQ291bnQgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vla0l0ZXJhdG9yLmFkZCgxLCAnd2VlaycpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0hhYml0IFRyYWNrZXJdIENoYXJ0aW5nIGRhdGEgZm9yIFwiJHtoYWJpdC5uYW1lfVwiICgke3RoaXMuY3VycmVudFN0YXRzUGVyaW9kfSwgVHlwZTogJHtoYWJpdC50eXBlfSwgU3RhdHNUeXBlOiAke2hhYml0U3RhdHNUeXBlfSk6YCk7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiICAgICBMYWJlbHM6XCIsIGNoYXJ0TGFiZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgICAgIFBlcmlvZCBUb3RhbC9EYWlseSBWYWx1ZSBEYXRhOlwiLCBjaGFydERhdGFQZXJpb2RUb3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiICAgICBDdW11bGF0aXZlIEF2ZXJhZ2UgRGF0YTpcIiwgY2hhcnREYXRhQ3VtdWxhdGl2ZUF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgICAgQ2FudmFzOlwiLCBjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgICAgQ29udGV4dDpcIiwgY3R4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hhcnRDb25maWc6IGFueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZURhdGFzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDEwMCwgMTIwLCAyNTUsIDEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJ0U3RhdHNUeXBlID0gaGFiaXRTdGF0c1R5cGU7IC8vIFVzZSBoYWJpdCdzIHJlc29sdmVkIHN0YXRzVHlwZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnRTdGF0c1R5cGUgPT09ICdjb21ibycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFydENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JhcicsIC8vIFRoZSBwcmltYXJ5IHR5cGUgZm9yIGNvbWJvIGlzIGJhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IGNoYXJ0TGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VEYXRhc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdWYWx1ZScgKyAoaGFiaXQudW5pdCA/IGAgKCR7aGFiaXQudW5pdH0pYCA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hhcnREYXRhUGVyaW9kVG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTAwLCAxMjAsIDI1NSwgMC42KScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlRGF0YXNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0F2ZXJhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjaGFydERhdGFDdW11bGF0aXZlQXZlcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDI1NSwgMTU5LCA2NCwgMSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMTU5LCA2NCwgMC4yKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb246IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAzLCAvLyBBZGQgcG9pbnQgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHsgLy8gQWRkIHRvb2x0aXAgZm9yIGhvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZ1bmN0aW9uIChjb250ZXh0OiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBjb250ZXh0LmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBhcnNlZC55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsICs9IGNvbnRleHQucGFyc2VkLnkudG9GaXhlZCgyKSArIChjb250ZXh0LmRhdGFzZXQubGFiZWwgPT09ICdWYWx1ZScgJiYgaGFiaXQudW5pdCA/IGhhYml0LnVuaXQgOiAnJyk7IC8vIEFkZCB1bml0IG9ubHkgZm9yIFZhbHVlIGRhdGFzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogeyAvLyBBZGQgbGF5b3V0IHBhZGRpbmcgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnRUeXBlID0gY2hhcnRTdGF0c1R5cGUgPT09ICdsaW5lJyA/ICdsaW5lJyA6ICdiYXInO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVRvVXNlRm9yU2luZ2xlID0gY2hhcnREYXRhUGVyaW9kVG90YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFydENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IGNoYXJ0TGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZURhdGFzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGhhYml0Lm5hbWUgKyAoaGFiaXQudW5pdCA/IGAgKCR7aGFiaXQudW5pdH0pYCA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhVG9Vc2VGb3JTaW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjaGFydFR5cGUgPT09ICdiYXInID8gJ3JnYmEoMTAwLCAxMjAsIDI1NSwgMC42KScgOiAncmdiYSgxMDAsIDEyMCwgMjU1LCAwLjIpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiBjaGFydFR5cGUgPT09ICdsaW5lJyA/IDAuMSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjaGFydFR5cGUgPT09ICdsaW5lJyA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogY2hhcnRUeXBlID09PSAnbGluZScgPyAzIDogdW5kZWZpbmVkLCAvLyBBZGQgcG9pbnQgcmFkaXVzIGZvciBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHsgLy8gQWRkIHRvb2x0aXAgZm9yIGhvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZ1bmN0aW9uIChjb250ZXh0OiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBjb250ZXh0LmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBhcnNlZC55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsICs9IGNvbnRleHQucGFyc2VkLnkudG9GaXhlZCgyKSArIChoYWJpdC51bml0IHx8ICcnKTsgLy8gQWRkIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogeyAvLyBBZGQgbGF5b3V0IHBhZGRpbmcgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCBjaGFydENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0SW5zdGFuY2VzLnNldChoYWJpdC5uYW1lLCBjaGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbSGFiaXQgVHJhY2tlcl0gRmFpbGVkIHRvIGdldCAyRCBjb250ZXh0IGZvciBjYW52YXMgZm9yIGhhYml0OiBcIiR7aGFiaXQubmFtZX1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzdWFsaXphdGlvbkNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgdGV4dDogYENvdWxkIG5vdCByZW5kZXIgY2hhcnQgZm9yIGhhYml0IFwiJHtoYWJpdC5uYW1lfVwiLiBDYW52YXMgY29udGV4dCB1bmF2YWlsYWJsZS5gIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0hhYml0IFRyYWNrZXJdIENhbnZhcyBlbGVtZW50IG5vdCBmb3VuZCBmb3IgaGFiaXQ6IFwiJHtoYWJpdC5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgICAgIHZpc3VhbGl6YXRpb25Db250YWluZXIuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBDb3VsZCBub3QgcmVuZGVyIGNoYXJ0IGZvciBoYWJpdCBcIiR7aGFiaXQubmFtZX1cIi4gQ2FudmFzIGVsZW1lbnQgbm90IGZvdW5kLmAgfSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAvLyBObyB2aXN1YWxpemF0aW9uIGZvciB0aGlzIGhhYml0IGluIHRoaXMgcGVyaW9kL3R5cGUvc3RhdHNUeXBlIGNvbWJpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgY29uc3Qgbm9WaXpNZXNzYWdlID0gdmlzdWFsaXphdGlvbkNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHsgY2xzOiAnbm8tdmlzdWFsaXphdGlvbi1tZXNzYWdlJyB9KTtcblxuICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBoYWJpdC5zdGF0c1R5cGUgaXMgZGVmYXVsdGVkIGZvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgY29uc3QgaGFiaXRTdGF0c1R5cGUgPSBoYWJpdC5zdGF0c1R5cGUgfHwgKGhhYml0LnR5cGUgPT09ICdudW1iZXInID8gJ2JhcicgOiAnaGVhdG1hcCcpO1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRzUGVyaW9kID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBtb250aCB2aWV3LCBvbmx5IE51bWJlciBoYWJpdHMgd2l0aCBjaGFydCB0eXBlcyBhcmUgc2hvd24gaW4gcmVuZGVyU3RhdHNDb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggaGVyZSBmb3IgYSBub24tbnVtYmVyIGhhYml0LCBpdCBtZWFucyBpdCB3YXMgZmlsdGVyZWQgb3V0IGVhcmxpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaCBoZXJlIGZvciBhIG51bWJlciBoYWJpdCwgaXQgbWVhbnMgaXRzIHN0YXRzVHlwZSBpcyBoZWF0bWFwLCB3aGljaCBpcyBub3Qgc2hvd24gaW4gbW9udGggdmlldy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnbnVtYmVyJyAmJiBoYWJpdFN0YXRzVHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9WaXpNZXNzYWdlLnNldFRleHQoYEhlYXRtYXAgdmlzdWFsaXphdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBpbiBZZWFyIHZpZXcgZm9yIE51bWJlciBoYWJpdHMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhYml0LnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgaWRlYWxseSBub3QgYmUgcmVhY2hlZCBpZiBmaWx0ZXJpbmcgaXMgY29ycmVjdCwgYnV0IGZvciBzYWZldHk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vVml6TWVzc2FnZS5zZXRUZXh0KGBPbmx5IGNoYXJ0IHZpc3VhbGl6YXRpb25zIGZvciBOdW1iZXIgaGFiaXRzIGFyZSBhdmFpbGFibGUgaW4gTW9udGggdmlldy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFN0YXRzUGVyaW9kID09PSAneWVhcicgJiYgaGFiaXQudHlwZSA9PT0gJ251bWJlcicgJiYgKGhhYml0U3RhdHNUeXBlICE9PSAnaGVhdG1hcCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhc2UgaW1wbGllcyBhIE51bWJlciBoYWJpdCB0aGF0IHNob3VsZCBoYXZlIGEgY2hhcnQgdHlwZSwgYnV0IGlzIG5vdCBzaG93aW5nIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVzc2FnZSBtaWdodCBiZSByZWR1bmRhbnQgaWYgZmlsdGVyaW5nIGlzIGNvcnJlY3QsIGJ1dCB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHNob3VsZCBzaG93IGEgY2hhcnQsIHNvIHRoaXMgbWVzc2FnZSBpbXBsaWVzIGEgY2hhcnQgcmVuZGVyaW5nIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBub1Zpek1lc3NhZ2Uuc2V0VGV4dChgQ2hhcnQgdmlzdWFsaXphdGlvbiBpcyBjb25maWd1cmVkIGJ1dCBmYWlsZWQgdG8gcmVuZGVyLmApOyAvLyBNb3JlIGFjY3VyYXRlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgYW55IG90aGVyIHVuaGFuZGxlZCBjYXNlIChzaG91bGQgYmUgcmFyZSB3aXRoIGNvcnJlY3QgZmlsdGVyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICBub1Zpek1lc3NhZ2Uuc2V0VGV4dChgTm8gdmlzdWFsaXphdGlvbiBjb25maWd1cmVkIGZvciB0aGlzIGhhYml0IGluIHRoZSBjdXJyZW50IHZpZXcuYCk7XG4gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHNlcGFyYXRvciBpZiBpdCdzIG5vdCB0aGUgbGFzdCBoYWJpdCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGhhYml0XG4gICAgICAgICAgICAgICAvLyBUaGlzIGxvZ2ljIHdhcyBmb3IgdGhlIGVudGlyZSBzdGF0cyBzZWN0aW9uLCBidXQgbm93IHdlIGFyZSByZW5kZXJpbmcgd2l0aGluIHN0YXRzQ29udGVudENvbnRhaW5lclxuICAgICAgICAgICAgICAgLy8gTGV0J3MgYWRkIHNlcGFyYXRvcnMgYmV0d2VlbiBoYWJpdCBzZWN0aW9ucyB3aXRoaW4gc3RhdHNDb250ZW50Q29udGFpbmVyXG4gICAgICAgICAgICAgICBpZiAoaGFiaXRzVG9EaXNwbGF5LmluZGV4T2YoaGFiaXQpIDwgaGFiaXRzVG9EaXNwbGF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICBoYWJpdFN0YXRzU2VjdGlvbi5jcmVhdGVFbCgnaHInKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW1vdmUgdGhlIGxhc3QgSFIgaGVyZSwgYXMgaXQncyBvbmx5IGFkZGVkIGJldHdlZW4gaXRlbXMuXG4gICAgICAgfVxuXG5cbiAgICBhc3luYyBvbkNsb3NlKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuY2hhcnRJbnN0YW5jZXMuZm9yRWFjaChjaGFydCA9PiBjaGFydC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLmNoYXJ0SW5zdGFuY2VzLmNsZWFyKCk7XG4gICAgICAgIC8vIENsZWFyIHJlZmVyZW5jZXMgdG8gY29udGFpbmVycyBhbmQgZWxlbWVudHMgd2hlbiBjbG9zaW5nXG4gICAgICAgIHRoaXMubW9udGhseU92ZXJ2aWV3R3JpZENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMubW9udGhseU92ZXJ2aWV3RGF0ZURpc3BsYXlFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHNDb250ZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0c0RhdGVEaXNwbGF5RWwgPSBudWxsO1xuICAgIH1cbn1cblxuXG4vLyAtLS0gSW5wdXQgTW9kYWwgQ2xhc3NlcyAtLS1cblxuY2xhc3MgVGV4dElucHV0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgcGx1Z2luOiBUcmFja2VyUGx1Z2luO1xuICAgIGRhdGU6IHN0cmluZztcbiAgICBoYWJpdE5hbWU6IHN0cmluZztcbiAgICBpbml0aWFsVmFsdWU6IHN0cmluZyB8IG51bGw7XG4gICAgdGV4dElucHV0OiBUZXh0QXJlYUNvbXBvbmVudDtcbiAgICBvblNhdmVDYWxsYmFjazogKCkgPT4gdm9pZDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFRyYWNrZXJQbHVnaW4sIGRhdGU6IHN0cmluZywgaGFiaXROYW1lOiBzdHJpbmcsIGluaXRpYWxWYWx1ZTogc3RyaW5nIHwgbnVsbCwgb25TYXZlQ2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gICAgICAgIHRoaXMuaGFiaXROYW1lID0gaGFiaXROYW1lO1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgdGhpcy5vblNhdmVDYWxsYmFjayA9IG9uU2F2ZUNhbGxiYWNrO1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwsIG1vZGFsRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuXG4gICAgICAgIC8vIE1vZGlmaWVkOiBSZW1vdmVkIFwiTG9nIFRleHQgZm9yXCIgZnJvbSB0aGUgdGl0bGVcbiAgICAgICAgdGhpcy50aXRsZUVsLnNldFRleHQoYCR7dGhpcy5oYWJpdE5hbWV9IG9uICR7dGhpcy5kYXRlfWApO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdUZXh0IEVudHJ5JykgLy8gQ2hhbmdlZCBuYW1lIHRvIGJlIG1vcmUgZ2VuZXJpY1xuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRleHQgaGVyZS4uLicpIC8vIEFkZGVkIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dEFyZWEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dElucHV0ID0gdGV4dEFyZWE7XG4gICAgICAgICAgICAgICAgdGV4dEFyZWEuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHRleHQuLi4nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5pbml0aWFsVmFsdWUgfHwgJycpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZSBpcyBzdG9yZWQgaW4gdGhlIGNvbXBvbmVudCwgd2lsbCByZWFkIG9uIHNhdmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5hZGRDbGFzcygnaGFiaXQtdGV4dC1pbnB1dCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gbW9kYWxFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb2RhbC1idXR0b24tY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBzYXZlQnV0dG9uID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdTYXZlJywgY2xzOiAnbW9kLWN0YScgfSk7XG4gICAgICAgIGNvbnN0IGNsZWFyQnV0dG9uID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDbGVhcicgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnQ2FuY2VsJyB9KTtcblxuICAgICAgICBzYXZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnRleHRJbnB1dC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVt0aGlzLmRhdGVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbdGhpcy5kYXRlXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbdGhpcy5kYXRlXVt0aGlzLmhhYml0TmFtZV0gPSBuZXdWYWx1ZSB8fCBudWxsO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRleHQgZm9yIFwiJHt0aGlzLmhhYml0TmFtZX1cIiBvbiAke3RoaXMuZGF0ZX0gc2F2ZWQuYCwgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2s/LigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjbGVhckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbdGhpcy5kYXRlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdmFsdWUgdG8gbnVsbCB0byBjbGVhciBhbGwgZW50cmllcyBmb3IgdGhlIGRheVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbdGhpcy5kYXRlXVt0aGlzLmhhYml0TmFtZV0gPSBudWxsO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVudHJ5IGZvciBcIiR7dGhpcy5oYWJpdE5hbWV9XCIgb24gJHt0aGlzLmRhdGV9IGNsZWFyZWQuYCwgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2s/LigpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIH1cbn1cblxuLy8gTW9kaWZpZWQ6IE51bWJlcklucHV0TW9kYWwgdG8gaGFuZGxlIG11bHRpcGxlIGVudHJpZXMgYW5kIHVwZGF0ZWQgVUkgdGV4dFxuY2xhc3MgTnVtYmVySW5wdXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwbHVnaW46IFRyYWNrZXJQbHVnaW47XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIGhhYml0TmFtZTogc3RyaW5nO1xuICAgIC8vIE1vZGlmaWVkOiBpbml0aWFsVmFsdWUgaXMgbm93IGFuIGFycmF5IG9mIG51bWJlcnMgb3IgbnVsbFxuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyW10gfCBudWxsO1xuICAgIG51bWJlcklucHV0OiBUZXh0Q29tcG9uZW50O1xuICAgIG9uU2F2ZUNhbGxiYWNrOiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogUGx1Z2luLCBkYXRlOiBzdHJpbmcsIGhhYml0TmFtZTogc3RyaW5nLCBpbml0aWFsVmFsdWU6IG51bWJlcltdIHwgbnVsbCwgb25TYXZlQ2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gICAgICAgIHRoaXMuaGFiaXROYW1lID0gaGFiaXROYW1lO1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFZhbHVlIGlzIGFuIGFycmF5IGlmIG5vdCBudWxsXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gQXJyYXkuaXNBcnJheShpbml0aWFsVmFsdWUpID8gaW5pdGlhbFZhbHVlIDogKGluaXRpYWxWYWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBbaW5pdGlhbFZhbHVlIGFzIG51bWJlcl0pOyAvLyBIYW5kbGUgcG90ZW50aWFsIG9sZCBmb3JtYXQgbWlncmF0aW9uXG4gICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2sgPSBvblNhdmVDYWxsYmFjaztcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsLCBtb2RhbEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcblxuICAgICAgICAvLyBNb2RpZmllZDogUmVtb3ZlZCBcIkxvZyBOdW1iZXIgZm9yXCIgZnJvbSB0aGUgdGl0bGVcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogYCR7dGhpcy5oYWJpdE5hbWV9IG9uICR7dGhpcy5kYXRlfWAgfSk7XG5cbiAgICAgICAgLy8gRGlzcGxheSBjdXJyZW50IGVudHJpZXMgYW5kIHRvdGFsXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbnRyaWVzQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ2N1cnJlbnQtbnVtYmVyLWVudHJpZXMnIH0pO1xuICAgICAgICB0aGlzLnJlbmRlckVudHJpZXMoY3VycmVudEVudHJpZXNDb250YWluZXIpO1xuXG5cbiAgICAgICAgLy8gSW5wdXQgZm9yIG5ldyBlbnRyeVxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQWRkJykgLy8gTW9kaWZpZWQ6IENoYW5nZWQgbGFiZWwgdG8gXCJBZGRcIlxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIGEgbnVtYmVyIHZhbHVlIHRvIGFkZCB0byB0b2RheVxcJ3MgdG90YWwuJykgLy8gQWRkZWQgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtYmVySW5wdXQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIG51bWJlci4uLicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSgnJykgLy8gQ2xlYXIgaW5wdXQgb24gb3BlblxuICAgICAgICAgICAgICAgICAgICAuaW5wdXRFbC50eXBlID0gJ251bWJlcic7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCcpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gdGhpcy5udW1iZXJJbnB1dC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhcnNlRmxvYXQoaW5wdXRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnSW5wdXQgY2Fubm90IGJlIGVtcHR5LicsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnSW52YWxpZCBudW1iZXIgaW5wdXQuJywgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGRhdGEsIGVuc3VyZSBpdCdzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV1bdGhpcy5oYWJpdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudERhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YSA9IFtdOyAvLyBTdGFydCB3aXRoIGVtcHR5IGFycmF5IGlmIG51bGwgb3Igb3RoZXIgdHlwZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGEucHVzaChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV1bdGhpcy5oYWJpdE5hbWVdID0gY3VycmVudERhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEFkZGVkICR7bmV3VmFsdWV9IHRvIFwiJHt0aGlzLmhhYml0TmFtZX1cIiBvbiAke3RoaXMuZGF0ZX0uYCwgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYW5kIHJlLXJlbmRlciBlbnRyaWVzIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1iZXJJbnB1dC5zZXRWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW50cmllcyhjdXJyZW50RW50cmllc0NvbnRhaW5lcik7IC8vIFJlLXJlbmRlciB0aGUgZW50cmllcyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2s/LigpOyAvLyBUcmlnZ2VyIHJlLXJlbmRlciBvZiBtYWluIHZpZXdcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gbW9kYWxFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb2RhbC1idXR0b24tY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBjbGVhckJ1dHRvbiA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnQ2xlYXIgQWxsJyB9KTtcbiAgICAgICAgY29uc3QgY2xvc2VCdXR0b24gPSBidXR0b25Db250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0Nsb3NlJyB9KTsgLy8gQ2hhbmdlZCBmcm9tIENhbmNlbCB0byBDbG9zZVxuXG5cbiAgICAgICAgY2xlYXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVt0aGlzLmRhdGVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIHRvIG51bGwgdG8gY2xlYXIgYWxsIGVudHJpZXMgZm9yIHRoZSBkYXlcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW3RoaXMuZGF0ZV1bdGhpcy5oYWJpdE5hbWVdID0gbnVsbDtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBBbGwgZW50cmllcyBmb3IgXCIke3RoaXMuaGFiaXROYW1lfVwiIG9uICR7dGhpcy5kYXRlfSBjbGVhcmVkLmAsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLm9uU2F2ZUNhbGxiYWNrPy4oKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyIHRvIHJlbmRlciB0aGUgbGlzdCBvZiBlbnRyaWVzIGFuZCB0aGUgdG90YWxcbiAgICByZW5kZXJFbnRyaWVzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpOyAvLyBDbGVhciBwcmV2aW91cyBkaXNwbGF5XG5cbiAgICAgICAgY29uc3QgY3VycmVudERhdGEgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVt0aGlzLmRhdGVdPy5bdGhpcy5oYWJpdE5hbWVdO1xuICAgICAgICBjb25zdCBoYWJpdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0cy5maW5kKGggPT4gaC5uYW1lID09PSB0aGlzLmhhYml0TmFtZSk7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBoYWJpdD8udW5pdCB8fCAnJztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50RGF0YSkgJiYgY3VycmVudERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdDdXJyZW50IEVudHJpZXM6JywgY2xzOiAnbW9kYWwtZW50cmllcy1saXN0LWxhYmVsJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXNMaXN0ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJywgeyBjbHM6ICdtb2RhbC1lbnRyaWVzLWxpc3QnIH0pO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnREYXRhLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNMaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogYCR7ZW50cnkudG9GaXhlZCgyKX0ke3VuaXR9YCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gZW50cnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHVuZXhwZWN0ZWQgZGF0YSBpbiBhcnJheSAtIG1heWJlIHJlbW92ZSBpdCBvciBsb2cgYSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hhYml0IFRyYWNrZXJdIFVuZXhwZWN0ZWQgbm9uLW51bWJlciBlbnRyeSBpbiBhcnJheSBmb3IgXCIke3RoaXMuaGFiaXROYW1lfVwiIG9uICR7dGhpcy5kYXRlfTpgLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogYFRvdGFsIGZvciB0b2RheTogJHt0b3RhbC50b0ZpeGVkKDIpfSR7dW5pdH1gLCBjbHM6ICdtb2RhbC10b3RhbC1kaXNwbGF5JyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnTm8gZW50cmllcyBmb3IgdG9kYXkuJywgY2xzOiAnbW9kYWwtbm8tZW50cmllcycgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5cbi8vIC0tLSBIYWJpdCBFZGl0IE1vZGFsIGNsYXNzIChmb3IgU2V0dGluZ3MgVGFiKSAtLS1cbmNsYXNzIEhhYml0RWRpdE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHBsdWdpbjogVHJhY2tlclBsdWdpbjtcbiAgICBoYWJpdEluZGV4OiBudW1iZXI7XG4gICAgaGFiaXQ6IEhhYml0OyAvLyBUaGlzIGhvbGRzIHRoZSBoYWJpdCBvYmplY3QgYmVpbmcgZWRpdGVkIChhIGNvcHkpXG5cbiAgICBuYW1lSW5wdXQ6IFRleHRDb21wb25lbnQ7XG4gICAgdHlwZURyb3Bkb3duOiBEcm9wZG93bkNvbXBvbmVudDtcblxuICAgIC8vIE51bWJlciBvcHRpb25zXG4gICAgdW5pdFNldHRpbmdFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDsgLy8gSW5pdGlhbGl6ZSB0byBudWxsXG4gICAgdW5pdElucHV0OiBUZXh0Q29tcG9uZW50O1xuICAgIGdvYWxTZXR0aW5nRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7IC8vIEluaXRpYWxpemUgdG8gbnVsbCAvLyBUaGlzIGdvYWwgaXMgZm9yIG51bWJlciBoYWJpdHNcbiAgICBnb2FsSW5wdXQ6IFRleHRDb21wb25lbnQ7XG4gICAgc3RhdHNUeXBlU2V0dGluZ0VsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsOyAvLyBJbml0aWFsaXplIHRvIG51bGxcbiAgICBzdGF0c1R5cGVEcm9wZG93bjogRHJvcGRvd25Db21wb25lbnQ7IC8vIFJlbW92ZWQgb3B0aW9uYWxcblxuICAgIC8vIEJvb2xlYW4gb3B0aW9uc1xuICAgIGZyZXF1ZW5jeVNldHRpbmdFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDsgLy8gSW5pdGlhbGl6ZSB0byBudWxsXG4gICAgZnJlcXVlbmN5RHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50OyAvLyBSZW1vdmVkIG9wdGlvbmFsXG4gICAgY29tcGxldGlvbkdvYWxTZXR0aW5nRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7IC8vIEluaXRpYWxpemUgdG8gbnVsbCAvLyBUaGlzIGdvYWwgaXMgZm9yIGJvb2xlYW4gaGFiaXRzXG4gICAgY29tcGxldGlvbkdvYWxJbnB1dDogVGV4dENvbXBvbmVudDsgLy8gUmVtb3ZlZCBvcHRpb25hbFxuXG5cbiAgICBzZXR0aW5nc1RhYjogU2FtcGxlU2V0dGluZ1RhYjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFRyYWNrZXJQbHVnaW4sIGhhYml0SW5kZXg6IG51bWJlciwgc2V0dGluZ3NUYWI6IFNhbXBsZVNldHRpbmdUYWIpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIC8vIENyZWF0ZSBhICpjb3B5KiBvZiB0aGUgaGFiaXQgb2JqZWN0IHRvIGVkaXQsIHNvIGNoYW5nZXMgYXJlbid0IGFwcGxpZWQgdW50aWwgc2F2ZWRcbiAgICAgICAgdGhpcy5oYWJpdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW2hhYml0SW5kZXhdKSk7XG4gICAgICAgIHRoaXMuaGFiaXRJbmRleCA9IGhhYml0SW5kZXg7XG5cblxuICAgICAgICAvLyBFbnN1cmUgZGVmYXVsdCB2YWx1ZXMgaWYgbWlzc2luZywgYmFzZWQgb24gdHlwZSwgZm9yIHRoZSAqY29weSpcbiAgICAgICAgaWYgKHRoaXMuaGFiaXQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYWJpdC5zdGF0c1R5cGUgfHwgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPT09ICdoZWF0bWFwJykgeyAvLyBIZWF0bWFwIGlzIG5vdCBhIHZhbGlkIGNoYXJ0IHR5cGUgZm9yIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMuaGFiaXQuc3RhdHNUeXBlID0gJ2Jhcic7IC8vIERlZmF1bHQgdG8gYmFyIGZvciBudW1iZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSB1bml0L2dvYWwgYXJlIGRlZmluZWQgZm9yIG51bWJlciBpZiB0aGV5IGV4aXN0XG4gICAgICAgICAgICB0aGlzLmhhYml0LnVuaXQgPSB0aGlzLmhhYml0LnVuaXQgPz8gJyc7XG4gICAgICAgICAgICB0aGlzLmhhYml0LmdvYWwgPSB0aGlzLmhhYml0LmdvYWwgPz8gdW5kZWZpbmVkOyAvLyBLZWVwIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYWJpdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFiaXQuZnJlcXVlbmN5ID0gdGhpcy5oYWJpdC5mcmVxdWVuY3kgPz8gJ2RheSc7XG4gICAgICAgICAgICB0aGlzLmhhYml0LmNvbXBsZXRpb25Hb2FsID0gdGhpcy5oYWJpdC5jb21wbGV0aW9uR29hbCA/PyB1bmRlZmluZWQ7IC8vIEtlZXAgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gaGFiaXRzIHNob3VsZCBkZWZhdWx0IHRvIGhlYXRtYXAgc3RhdHMgdHlwZVxuICAgICAgICAgICAgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPSAnaGVhdG1hcCc7IC8vIERlZmF1bHQgQm9vbGVhbiB0byBoZWF0bWFwXG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHRleHQsIGVuc3VyZSBzdGF0c1R5cGUgaXMgaGVhdG1hcFxuICAgICAgICBpZiAodGhpcy5oYWJpdC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFiaXQuc3RhdHNUeXBlID0gJ2hlYXRtYXAnOyAvLyBEZWZhdWx0IFRleHQgdG8gaGVhdG1hcFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgaXJyZWxldmFudCBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvcHkgYmFzZWQgb24gaXRzIHR5cGVcbiAgICAgICAgaWYgKHRoaXMuaGFiaXQudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAodGhpcy5oYWJpdCBhcyBhbnkpLnVuaXQ7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuaGFiaXQgYXMgYW55KS5nb2FsOyAvLyBEZWxldGUgbnVtYmVyIGdvYWxcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYWJpdC50eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAodGhpcy5oYWJpdCBhcyBhbnkpLmZyZXF1ZW5jeTtcbiAgICAgICAgICAgIGRlbGV0ZSAodGhpcy5oYWJpdCBhcyBhbnkpLmNvbXBsZXRpb25Hb2FsOyAvLyBEZWxldGUgYm9vbGVhbiBnb2FsXG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3NUYWIgPSBzZXR0aW5nc1RhYjtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsLCBtb2RhbEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcblxuICAgICAgICB0aGlzLnRpdGxlRWwuc2V0VGV4dChgRWRpdCBIYWJpdDogXCIke3RoaXMuaGFiaXQubmFtZX1cImApO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdIYWJpdCBOYW1lJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZUlucHV0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBoYWJpdCBuYW1lJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuaGFiaXQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFiaXQubmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHR5cGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0hhYml0IFR5cGUnKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVEcm9wZG93biA9IGRyb3Bkb3duO1xuICAgICAgICAgICAgICAgIC8vIE1vZGlmaWVkOiBDaGFuZ2VkIGRpc3BsYXkgdGV4dCBmb3IgaGFiaXQgdHlwZXNcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oJ2Jvb2xlYW4nLCAnQm9vbGVhbicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ3RleHQnLCAnVGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ251bWJlcicsICdOdW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5oYWJpdC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7IC8vIEFkZGVkIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUeXBlID0gdmFsdWUgYXMgSGFiaXRbJ3R5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFR5cGUgPSB0aGlzLmhhYml0LnR5cGU7IC8vIENhcHR1cmUgb2xkIHR5cGUgYmVmb3JlIHVwZGF0aW5nXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHlwZSBpbiB0aGUgbW9kYWwncyBoYWJpdCBjb3B5IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhYml0LnR5cGUgPSBuZXdUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgdmlzaWJpbGl0eSBvZiB0eXBlLXNwZWNpZmljIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlTnVtYmVyT3B0aW9ucyhuZXdUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQm9vbGVhbk9wdGlvbnMobmV3VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVN0YXRzVHlwZU9wdGlvbihuZXdUeXBlKTsgLy8gU3RhdHMgdHlwZSBkZXBlbmRzIG9uIG51bWJlciB0eXBlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgd2FybmluZyBub3RpY2UgaWYgdHlwZSBjaGFuZ2VkLCBidXQgRE8gTk9UIGNsZWFyIGRhdGEgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VHlwZSAhPT0gb2xkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gSGFiaXQgdHlwZSBjaGFuZ2VkIGZyb20gJHtvbGRUeXBlfSB0byAke25ld1R5cGV9IGZvciBcIiR7dGhpcy5oYWJpdC5uYW1lfVwiLiBEYXRhIHdpbGwgYmUgY2xlYXJlZCBvbiBTYXZlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFdhcm5pbmc6IENoYW5naW5nIGhhYml0IHR5cGUgd2lsbCBjbGVhciBleGlzdGluZyBkYXRhIGZvciBcIiR7dGhpcy5oYWJpdC5uYW1lfVwiLiBDbGljayBTYXZlIHRvIGNvbmZpcm0uYCwgNTAwMCk7IC8vIFNob3cgd2FybmluZyBmb3IgNSBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgaXJyZWxldmFudCBwcm9wZXJ0aWVzIGZyb20gdGhlICptb2RhbCdzIGNvcHkqIG9mIHRoZSBoYWJpdCBvYmplY3QgaW1tZWRpYXRlbHkgb24gdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdUeXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhhYml0LnVuaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGFiaXQuZ29hbDsgLy8gRGVsZXRlIG51bWJlciBnb2FsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBudW1iZXIgcHJvcGVydGllcyBleGlzdCB3aXRoIGRlZmF1bHRzIGlmIGNoYW5naW5nIHRvIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFiaXQudW5pdCA9IHRoaXMuaGFiaXQudW5pdCA/PyAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhYml0LmdvYWwgPSB0aGlzLmhhYml0LmdvYWwgPz8gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGFiaXQuZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhhYml0LmNvbXBsZXRpb25Hb2FsOyAvLyBEZWxldGUgYm9vbGVhbiBnb2FsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBib29sZWFuIHByb3BlcnRpZXMgZXhpc3Qgd2l0aCBkZWZhdWx0cyBpZiBjaGFuZ2luZyB0byBib29sZWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5mcmVxdWVuY3kgPSB0aGlzLmhhYml0LmZyZXF1ZW5jeSA/PyAnZGF5JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhYml0LmNvbXBsZXRpb25Hb2FsID0gdGhpcy5oYWJpdC5jb21wbGV0aW9uR29hbCA/PyB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHN0YXRzVHlwZSBpcyBjb3JyZWN0bHkgZGVmYXVsdGVkIGJhc2VkIG9uIHRoZSBuZXcgdHlwZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1R5cGUgPT09ICdib29sZWFuJyB8fCBuZXdUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhYml0LnN0YXRzVHlwZSA9ICdoZWF0bWFwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFiaXQuc3RhdHNUeXBlIHx8IHRoaXMuaGFiaXQuc3RhdHNUeXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPSAnYmFyJzsgLy8gRGVmYXVsdCBudW1iZXIgdG8gYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1yZW5kZXIgdGhlIG1vZGFsIGNvbnRlbnQgdG8gcmVmbGVjdCB2aXNpYmlsaXR5IGNoYW5nZXMgKE9wdGlvbmFsLCB0b2dnbGluZyBjbGFzc2VzIHNob3VsZCBiZSBlbm91Z2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLm9uT3BlbigpOyAvLyBBdm9pZCByZS1vcGVuaW5nIG1vZGFsLCBqdXN0IHRvZ2dsZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tIE51bWJlciBPcHRpb25zIC0tLVxuICAgICAgICBjb25zdCB1bml0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdVbml0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdPcHRpb25hbCB1bml0IGZvciBudW1iZXIgaGFiaXQgKGUuZS4sIFwia2dcIiwgXCJtaW51dGVzXCIpJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pdElucHV0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB1bml0IChvcHRpb25hbCknKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5oYWJpdC51bml0IHx8ICcnKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC51bml0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5pdFNldHRpbmdFbCA9IHVuaXRTZXR0aW5nLnNldHRpbmdFbDsgLy8gU3RvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy51bml0U2V0dGluZ0VsLmFkZENsYXNzKCdlZGl0LW51bWJlci1vcHRpb24nKTtcblxuICAgICAgICAvLyBUaGlzIGdvYWwgaXMgZm9yIE51bWJlciBoYWJpdHNcbiAgICAgICAgY29uc3QgZ29hbFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnR29hbCAoTnVtYmVyKScpIC8vIENsYXJpZnkgd2hpY2ggZ29hbFxuICAgICAgICAgICAgLnNldERlc2MoJ09wdGlvbmFsIHRhcmdldCB2YWx1ZSBmb3IgbnVtYmVyIGhhYml0IHN0YXRpc3RpY3MnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb2FsSW5wdXQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGdvYWwgbnVtYmVyIChvcHRpb25hbCknKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5oYWJpdC5nb2FsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5oYWJpdC5nb2FsICE9PSBudWxsID8gU3RyaW5nKHRoaXMuaGFiaXQuZ29hbCkgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgLmlucHV0RWwudHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIHRleHQub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnb2FsVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5nb2FsID0gIWlzTmFOKGdvYWxWYWx1ZSkgPyBnb2FsVmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nb2FsU2V0dGluZ0VsID0gZ29hbFNldHRpbmcuc2V0dGluZ0VsOyAvLyBTdG9yZSB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLmdvYWxTZXR0aW5nRWwuYWRkQ2xhc3MoJ2VkaXQtbnVtYmVyLW9wdGlvbicpO1xuXG5cbiAgICAgICAgY29uc3Qgc3RhdHNUeXBlU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdTdGF0aXN0aWNzIFZpc3VhbGl6YXRpb24nKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSBob3cgdG8gdmlzdWFsaXplIHRoaXMgaGFiaXQgaW4gc3RhdGlzdGljcycpO1xuICAgICAgICAvLyBhZGRDb21wb25lbnQgaXMgc3luY2hyb25vdXMsIGFzc2lnbm1lbnQgc2hvdWxkIGhhcHBlbiBoZXJlXG4gICAgICAgIHN0YXRzVHlwZVNldHRpbmcuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0c1R5cGVEcm9wZG93biA9IGRyb3Bkb3duOyAvLyBBc3NpZ24gdGhlIGluc3RhbmNlIGhlcmVcblxuICAgICAgICAgICAgLy8gQWRkIGFsbCBwb3NzaWJsZSBvcHRpb25zIGZvciBudW1iZXIgdHlwZXNcbiAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignYmFyJywgJ0JhciBDaGFydCcpO1xuICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKCdsaW5lJywgJ0xpbmUgQ2hhcnQnKTtcbiAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignY29tYm8nLCAnQ29tYm8gKEJhciAmIExpbmUpJyk7XG4gICAgICAgICAgICAvLyBBZGQgaGVhdG1hcCBvcHRpb24gYXMgd2VsbCwgdGhvdWdoIGl0J3MgdGhlIGRlZmF1bHQgZm9yIG5vbi1udW1iZXJcbiAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignaGVhdG1hcCcsICdIZWF0bWFwJyk7XG5cblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWUgYmFzZWQgb24gY3VycmVudCBoYWJpdCB0eXBlIGFuZCBzdGF0c1R5cGVcbiAgICAgICAgICAgIGlmICh0aGlzLmhhYml0LnR5cGUgPT09ICdudW1iZXInICYmIHRoaXMuaGFiaXQuc3RhdHNUeXBlICE9PSAnaGVhdG1hcCcgJiYgdGhpcy5oYWJpdC5zdGF0c1R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50IGhhYml0IHR5cGUgaXMgbnVtYmVyIGFuZCBhIHZhbGlkIGNoYXJ0IHR5cGUgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUodGhpcy5oYWJpdC5zdGF0c1R5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRlZmF1bHQgdG8gaGVhdG1hcCAoZm9yIGJvb2xlYW4vdGV4dCkgb3IgYmFyIChmb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIGJvb2xlYW4vdGV4dCBoYWJpdCBpcyBiZWluZyBlZGl0ZWQgKGRlZmF1bHRzIHRvIGhlYXRtYXAgVUkpXG4gICAgICAgICAgICAgICAgLy8gb3IgYSBudW1iZXIgaGFiaXQgd2l0aCBpbnZhbGlkL2hlYXRtYXAgc3RhdHNUeXBlIGlzIGJlaW5nIGVkaXRlZCAoZGVmYXVsdHMgdG8gYmFyIFVJKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuaGFiaXQudHlwZSA9PT0gJ251bWJlcicgPyAnYmFyJyA6ICdoZWF0bWFwJztcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvU2V0ID0gdGhpcy5oYWJpdC5zdGF0c1R5cGUgfHwgZGVmYXVsdFZhbHVlOyAvLyBVc2UgZXhpc3Rpbmcgc3RhdHNUeXBlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUodmFsdWVUb1NldCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGhhYml0IG9iamVjdCdzIHN0YXRzVHlwZSBpZiBpdCB3YXMgb3JpZ2luYWxseSBoZWF0bWFwIGZvciBhIG51bWJlciB0eXBlIGJlaW5nIGVkaXRlZFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgaW50ZXJuYWwgaGFiaXQgb2JqZWN0J3Mgc3RhdHNUeXBlIGlzIHZhbGlkIGZvciB0aGUgY3VycmVudCB0eXBlIHVwb24gbW9kYWwgb3BlblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhYml0LnR5cGUgPT09ICdudW1iZXInICYmICh0aGlzLmhhYml0LnN0YXRzVHlwZSA9PT0gJ2hlYXRtYXAnIHx8ICF0aGlzLmhhYml0LnN0YXRzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPSAnYmFyJzsgLy8gRW5zdXJlIHRoZSBpbnRlcm5hbCBoYWJpdCBvYmplY3QgcmVmbGVjdHMgdGhlIFVJIGRlZmF1bHRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFiaXQudHlwZSAhPT0gJ251bWJlcicgJiYgdGhpcy5oYWJpdC5zdGF0c1R5cGUgIT09ICdoZWF0bWFwJykge1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPSAnaGVhdG1hcCc7IC8vIEVuc3VyZSBub24tbnVtYmVyIGludGVybmFsIG9iamVjdCByZWZsZWN0cyBoZWF0bWFwIGlmIGl0IHdhc24ndCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5oYWJpdC5zdGF0c1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRzVHlwZSB3YXMgY29tcGxldGVseSBtaXNzaW5nLCBzZXQgdGhlIGRlZmF1bHQgYmFzZWQgb24gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYWJpdC5zdGF0c1R5cGUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2VsZWN0ZWQgdmFsdWUgaW4gdGhlIGhhYml0IG9iamVjdCBiZWluZyBlZGl0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmhhYml0LnN0YXRzVHlwZSA9IHZhbHVlIGFzIEhhYml0WydzdGF0c1R5cGUnXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0c1R5cGVTZXR0aW5nRWwgPSBzdGF0c1R5cGVTZXR0aW5nLnNldHRpbmdFbDsgLy8gU3RvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5zdGF0c1R5cGVTZXR0aW5nRWwuYWRkQ2xhc3MoJ2VkaXQtc3RhdHMtdHlwZS1vcHRpb24nKTtcbiAgICAgICAgLy8gSGlkZSBpbml0aWFsbHkgaWYgbm90IG51bWJlciB0eXBlXG4gICAgICAgIGlmICh0aGlzLmhhYml0LnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzVHlwZVNldHRpbmdFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyAtLS0gQm9vbGVhbiBPcHRpb25zIC0tLVxuICAgICAgICBjb25zdCBmcmVxdWVuY3lTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ZyZXF1ZW5jeScpXG4gICAgICAgICAgICAuc2V0RGVzYygnSG93IG9mdGVuIGRvIHlvdSB0cmFjayB0aGlzIGhhYml0PycpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5RHJvcGRvd24gPSBkcm9wZG93bjsgLy8gQ29ycmVjdGx5IGFzc2lnbiB0aGUgRHJvcGRvd25Db21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oJ2RheScsICdEYWlseScpO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignd2VlaycsICdXZWVrbHknKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLmhhYml0LmZyZXF1ZW5jeSB8fCAnZGF5Jyk7IC8vIERlZmF1bHQgdG8gJ2RheSdcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZyZXEgPSB2YWx1ZSBhcyBIYWJpdFsnZnJlcXVlbmN5J107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFiaXQuZnJlcXVlbmN5ID0gbmV3RnJlcTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbXBsZXRpb24gZ29hbCBkZXNjcmlwdGlvbiBzaG91bGQgdXBkYXRlIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGZyZXF1ZW5jeSwgYnV0IHRoYXQgcmVxdWlyZXMgbW9yZSBjb21wbGV4IERPTSBtYW5pcHVsYXRpb24gb3IgcmUtcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBqdXN0IHVwZGF0ZSB0aGUgZGF0YSBtb2RlbC5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeVNldHRpbmdFbCA9IGZyZXF1ZW5jeVNldHRpbmcuc2V0dGluZ0VsO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeVNldHRpbmdFbC5hZGRDbGFzcygnZWRpdC1ib29sZWFuLW9wdGlvbicpOyAvLyBBZGQgbmV3IGNsYXNzIGZvciBib29sZWFuIG9wdGlvbnNcblxuXG4gICAgICAgIC8vIFRoaXMgZ29hbCBpcyBmb3IgQm9vbGVhbiBoYWJpdHMgKGRhaWx5IG9yIHdlZWtseSBiYXNlZCBvbiBmcmVxdWVuY3kpXG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25Hb2FsU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdDb21wbGV0aW9uIEdvYWwnKSAvLyBVc2UgQ29tcGxldGlvbiBHb2FsXG4gICAgICAgICAgICAuc2V0RGVzYygnVGFyZ2V0IG51bWJlciBvZiBjb21wbGV0aW9ucyBwZXIgZGF5IG9yIHBlciB3ZWVrLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25Hb2FsSW5wdXQgPSB0ZXh0OyAvLyBVc2UgQ29tcGxldGlvbiBHb2FsIElucHV0XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgZ29hbCBudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5oYWJpdC5jb21wbGV0aW9uR29hbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IG51bGwgPyBTdHJpbmcodGhpcy5oYWJpdC5jb21wbGV0aW9uR29hbCkgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgLmlucHV0RWwudHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIHRleHQub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnb2FsVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApOyAvLyBVc2UgcGFyc2VJbnQgZm9yIGZyZXF1ZW5jeSBjb3VudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhYml0LmNvbXBsZXRpb25Hb2FsID0gKCFpc05hTihnb2FsVmFsdWUpICYmIGdvYWxWYWx1ZSA+IDApID8gZ29hbFZhbHVlIDogdW5kZWZpbmVkOyAvLyBFbnN1cmUgcG9zaXRpdmUgaW50ZWdlciBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25Hb2FsU2V0dGluZ0VsID0gY29tcGxldGlvbkdvYWxTZXR0aW5nLnNldHRpbmdFbDsgLy8gU3RvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uR29hbFNldHRpbmdFbC5hZGRDbGFzcygnZWRpdC1ib29sZWFuLW9wdGlvbicpOyAvLyBBZGQgbmV3IGNsYXNzIGZvciBib29sZWFuIG9wdGlvbnNcblxuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgdG9nZ2xpbmcgYmFzZWQgb24gdGhlIGhhYml0IHR5cGVcbiAgICAgICAgdGhpcy50b2dnbGVOdW1iZXJPcHRpb25zKHRoaXMuaGFiaXQudHlwZSk7XG4gICAgICAgIHRoaXMudG9nZ2xlQm9vbGVhbk9wdGlvbnModGhpcy5oYWJpdC50eXBlKTsgLy8gVG9nZ2xlIGJvb2xlYW4gb3B0aW9ucyBpbml0aWFsbHlcbiAgICAgICAgLy8gdG9nZ2xlU3RhdHNUeXBlT3B0aW9uIGlzIG5vdyBwcmltYXJpbHkgZm9yIHZpc2liaWxpdHkgYWZ0ZXIgdHlwZSBjaGFuZ2UsXG4gICAgICAgIC8vIGluaXRpYWwgcG9wdWxhdGlvbiBpcyBkb25lIGluIHRoZSBhZGREcm9wZG93biBjYWxsYmFjayBpdHNlbGYuXG4gICAgICAgIC8vIFRoZSBpbml0aWFsIHZpc2liaWxpdHkgaXMgYWxzbyBzZXQgaW4gdGhlIGFkZERyb3Bkb3duIGNhbGxiYWNrLlxuICAgICAgICAvLyBObyBuZWVkIHRvIGNhbGwgdG9nZ2xlU3RhdHNUeXBlT3B0aW9uIGhlcmUgaW5pdGlhbGx5IGZvciB2aXNpYmlsaXR5LlxuXG5cbiAgICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gbW9kYWxFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdtb2RhbC1idXR0b24tY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBzYXZlQnV0dG9uID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdTYXZlJywgY2xzOiAnbW9kLWN0YScgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnQ2FuY2VsJyB9KTtcblxuICAgICAgICBzYXZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3TmFtZSA9IHRoaXMubmFtZUlucHV0LmdldFZhbHVlKCkudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbmV3VHlwZSA9IHRoaXMuaGFiaXQudHlwZTsgLy8gR2V0IHRoZSBwb3RlbnRpYWxseSBjaGFuZ2VkIHR5cGUgZnJvbSB0aGUgbW9kYWwncyBoYWJpdCBjb3B5XG5cbiAgICAgICAgICAgIC8vIEdldCBvcmlnaW5hbCBoYWJpdCBkZXRhaWxzIGZyb20gc2V0dGluZ3MgYmVmb3JlIG1ha2luZyBjaGFuZ2VzXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhhYml0SW5TZXR0aW5ncyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1t0aGlzLmhhYml0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb2xkSGFiaXROYW1lID0gb3JpZ2luYWxIYWJpdEluU2V0dGluZ3MubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEhhYml0VHlwZSA9IG9yaWdpbmFsSGFiaXRJblNldHRpbmdzLnR5cGU7XG5cblxuICAgICAgICAgICAgaWYgKCFuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnSGFiaXQgbmFtZSBjYW5ub3QgYmUgZW1wdHkuJywgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVFeGlzdHMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHMuc29tZSgoaCwgaSkgPT5cbiAgICAgICAgICAgICAgICBpICE9PSB0aGlzLmhhYml0SW5kZXggJiYgaC5uYW1lID09PSBuZXdOYW1lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZHVwbGljYXRlRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgSGFiaXQgXCIke25ld05hbWV9XCIgYWxyZWFkeSBleGlzdHMuYCwgMjAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0gRGF0YSBNaWdyYXRpb24vQ2xlYXJpbmcgTG9naWMgb24gU2F2ZSAtLS1cbiAgICAgICAgICAgIGlmIChuZXdUeXBlICE9PSBvbGRIYWJpdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0eXBlIGNoYW5nZWQsIGNsZWFyIGRhdGEgZm9yIHRoZSBPTEQgaGFiaXQgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gU2F2aW5nOiBIYWJpdCB0eXBlIGNoYW5nZWQgZnJvbSAke29sZEhhYml0VHlwZX0gdG8gJHtuZXdUeXBlfSBmb3IgXCIke29sZEhhYml0TmFtZX1cIi4gRGF0YSB3aWxsIGJlIGNsZWFyZWQgb24gU2F2ZS5gKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGUgaW4gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVdPy5bb2xkSGFiaXROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbZGF0ZV1bb2xkSGFiaXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBEYXRhIGZvciBcIiR7b2xkSGFiaXROYW1lfVwiIGNsZWFyZWQgZHVlIHRvIGhhYml0IHR5cGUgY2hhbmdlIG9uIFNhdmUuYCwgMzAwMCk7IC8vIFNob3J0ZXIgbm90aWNlIG9uIHNhdmVcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdOYW1lICE9PSBvbGRIYWJpdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBvbmx5IG5hbWUgY2hhbmdlZCAodHlwZSBpcyB0aGUgc2FtZSksIG1pZ3JhdGUgZGF0YSBmcm9tIG9sZCBuYW1lIHRvIG5ldyBuYW1lXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBTYXZpbmc6IEhhYml0IHJlbmFtZWQgZnJvbSBcIiR7b2xkSGFiaXROYW1lfVwiIHRvIFwiJHtuZXdOYW1lfVwiLiBNaWdyYXRpbmcgZGF0YS5gKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGUgaW4gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVdPy5bb2xkSGFiaXROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGREYXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbZGF0ZV1bb2xkSGFiaXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBkYXRhIHRvIHRoZSBuZXcgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGFbZGF0ZV1bbmV3TmFtZV0gPSBvbGREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGRhdGEgZnJvbSB0aGUgb2xkIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21wbGV0aW9uRGF0YVtkYXRlXVtvbGRIYWJpdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEhhYml0IFwiJHtvbGRIYWJpdE5hbWV9XCIgcmVuYW1lZCB0byBcIiR7bmV3TmFtZX1cIi4gRGF0YSBtaWdyYXRlZC5gLCAzMDAwKTsgLy8gU2hvcnRlciBub3RpY2VcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBuZWl0aGVyIG5hbWUgbm9yIHR5cGUgY2hhbmdlZCwganVzdCB1cGRhdGVkIG90aGVyIHNldHRpbmdzICh1bml0LCBnb2FsLCBmcmVxdWVuY3ksIHN0YXRzVHlwZSlcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBIYWJpdCBcIiR7bmV3TmFtZX1cIiB1cGRhdGVkLmAsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tIEVuZCBEYXRhIE1pZ3JhdGlvbi9DbGVhcmluZyBMb2dpYyAtLS1cblxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhYml0IGluIHNldHRpbmdzIHdpdGggdGhlIG1vZGlmaWVkIGNvcHlcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1t0aGlzLmhhYml0SW5kZXhdID0geyAuLi50aGlzLmhhYml0IH07XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGlycmVsZXZhbnQgcHJvcGVydGllcyBmcm9tIHRoZSBzYXZlZCBzZXR0aW5ncyBvYmplY3QganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAvLyBUaGlzIGxvZ2ljIHNob3VsZCBpZGVhbGx5IG1hdGNoIHRoZSBjbGVhbmluZyBpbiB0aGUgY29uc3RydWN0b3IvdHlwZSBjaGFuZ2UsXG4gICAgICAgICAgICAvLyBidXQgZG9pbmcgaXQgb24gc2F2ZSBwcm92aWRlcyBhIGZpbmFsIGNsZWFudXAuXG4gICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW3RoaXMuaGFiaXRJbmRleF0udHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgKHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1t0aGlzLmhhYml0SW5kZXhdIGFzIGFueSkudW5pdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgKHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1t0aGlzLmhhYml0SW5kZXhdIGFzIGFueSkuZ29hbDsgLy8gRGVsZXRlIG51bWJlciBnb2FsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW3RoaXMuaGFiaXRJbmRleF0udHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHNbdGhpcy5oYWJpdEluZGV4XSBhcyBhbnkpLmZyZXF1ZW5jeTtcbiAgICAgICAgICAgICAgICBkZWxldGUgKHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1t0aGlzLmhhYml0SW5kZXhdIGFzIGFueSkuY29tcGxldGlvbkdvYWw7IC8vIERlbGV0ZSBib29sZWFuIGdvYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSBzdGF0c1R5cGUgaXMgaGVhdG1hcCBmb3IgYm9vbGVhbi90ZXh0IGluIHRoZSBzYXZlZCBvYmplY3RcbiAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHNbdGhpcy5oYWJpdEluZGV4XS50eXBlID09PSAnYm9vbGVhbicgfHwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW3RoaXMuaGFiaXRJbmRleF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW3RoaXMuaGFiaXRJbmRleF0uc3RhdHNUeXBlID0gJ2hlYXRtYXAnO1xuICAgICAgICAgICAgfSAvLyBGb3IgbnVtYmVyLCB0aGUgc2VsZWN0ZWQgc3RhdHNUeXBlIGlzIGFscmVhZHkgaW4gdGhpcy5oYWJpdFxuXG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpOyAvLyBDbG9zZSBtb2RhbCBhZnRlciBzYXZpbmdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpOyAvLyBDbG9zZSBtb2RhbCBvbiBjYW5jZWxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTW9kaWZpZWQ6IHRvZ2dsZU51bWJlck9wdGlvbnMgbm93IG9ubHkgaGFuZGxlcyBVbml0IGFuZCBHb2FsIGZvciBudW1iZXIgdHlwZVxuICAgIHRvZ2dsZU51bWJlck9wdGlvbnModHlwZTogSGFiaXRbJ3R5cGUnXSkge1xuICAgICAgICBpZiAodGhpcy51bml0U2V0dGluZ0VsKSB0aGlzLnVuaXRTZXR0aW5nRWwuc3R5bGUuZGlzcGxheSA9IHR5cGUgPT09ICdudW1iZXInID8gJ2ZsZXgnIDogJ25vbmUnO1xuICAgICAgICBpZiAodGhpcy5nb2FsU2V0dGluZ0VsKSB0aGlzLmdvYWxTZXR0aW5nRWwuc3R5bGUuZGlzcGxheSA9IHR5cGUgPT09ICdudW1iZXInID8gJ2ZsZXgnIDogJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIE1vZGlmaWVkOiBNZXRob2QgdG8gdG9nZ2xlIEJvb2xlYW4gb3B0aW9ucyAoRnJlcXVlbmN5IGFuZCBDb21wbGV0aW9uIEdvYWwpXG4gICAgdG9nZ2xlQm9vbGVhbk9wdGlvbnModHlwZTogSGFiaXRbJ3R5cGUnXSkge1xuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSB0eXBlID09PSAnYm9vbGVhbic7XG4gICAgICAgIGlmICh0aGlzLmZyZXF1ZW5jeVNldHRpbmdFbCkgdGhpcy5mcmVxdWVuY3lTZXR0aW5nRWwuc3R5bGUuZGlzcGxheSA9IGlzQm9vbGVhbiA/ICdmbGV4JyA6ICdub25lJztcbiAgICAgICAgLy8gQ29ycmVjdGVkIHR5cG8gaGVyZTogY29tcGxldGlvbkdvYWxDb21wbGV0aW9uR29hbEVsIC0+IGNvbXBsZXRpb25Hb2FsU2V0dGluZ0VsXG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRpb25Hb2FsU2V0dGluZ0VsKSB0aGlzLmNvbXBsZXRpb25Hb2FsU2V0dGluZ0VsLnN0eWxlLmRpc3BsYXkgPSBpc0Jvb2xlYW4gPyAnZmxleCcgOiAnbm9uZSc7XG4gICAgfVxuXG5cbiAgICAvLyBNb2RpZmllZCB0b2dnbGVTdGF0c1R5cGVPcHRpb24gbG9naWMgZm9yIGVkaXQgbW9kYWxcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIG9ubHkgaGFuZGxlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3RhdHMgdHlwZSBzZXR0aW5nIGVsZW1lbnQuXG4gICAgLy8gVGhlIHBvcHVsYXRpb24gYW5kIHZhbHVlIHNldHRpbmcgb2YgdGhlIGRyb3Bkb3duIGhhcHBlbiB3aGVuIHRoZSBzZXR0aW5nIGlzIGNyZWF0ZWQgaW4gb25PcGVuLlxuICAgIHRvZ2dsZVN0YXRzVHlwZU9wdGlvbih0eXBlOiBIYWJpdFsndHlwZSddKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZXR0aW5nIGVsZW1lbnQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLnN0YXRzVHlwZVNldHRpbmdFbCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1R5cGVTZXR0aW5nRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGJvb2xlYW4gb3IgdGV4dFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNUeXBlU2V0dGluZ0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBhY2Nlc3MgdGhpcy5zdGF0c1R5cGVEcm9wZG93biBoZXJlLlxuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIC8vIFJlLXJlbmRlciBzZXR0aW5ncyB0YWIgZXhwbGljaXRseSBhZnRlciBjbG9zaW5nIG1vZGFsXG4gICAgICAgIC8vIFRoaXMgYWxzbyBpbXBsaWNpdGx5IHJlLXJlbmRlcnMgdGhlIG1haW4gdmlldyBiZWNhdXNlIHRoZSBzZXR0aW5ncyB0YWIgYGRpc3BsYXkoKWBcbiAgICAgICAgLy8gbWV0aG9kIGxpa2VseSB0cmlnZ2VycyBhIHJlLXJlbmRlciBvZiB0aGUgcGx1Z2luJ3MgZGF0YS92aWV3cy5cbiAgICAgICAgdGhpcy5zZXR0aW5nc1RhYi5kaXNwbGF5KCk7XG4gICAgICAgIC8vIFJlLWFjdGl2YXRpbmcgdGhlIHZpZXcgZW5zdXJlcyB0aGUgbWFpbiBVSSB1cGRhdGVzIHdpdGggYW55IGhhYml0IGNoYW5nZXNcbiAgICAgICAgdGhpcy5wbHVnaW4uYWN0aXZhdGVWaWV3KEhBQklUX1RSQUNLRVJfVklFV19UWVBFKTtcbiAgICB9XG59XG5cblxuLy8gU2FtcGxlU2V0dGluZ1RhYiBoYW5kbGVzIHRoZSBoYWJpdCBsaXN0XG5jbGFzcyBTYW1wbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBUcmFja2VyUGx1Z2luO1xuXG4gICAgbmV3SGFiaXROYW1lSW5wdXQ6IFRleHRDb21wb25lbnQ7XG4gICAgbmV3SGFiaXRUeXBlRHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50O1xuXG4gICAgLy8gTmV3IEhhYml0IE51bWJlciBPcHRpb25zXG4gICAgbmV3SGFiaXRVbml0SW5wdXQ6IFRleHRDb21wb25lbnQ7XG4gICAgbmV3SGFiaXRHb2FsSW5wdXQ6IFRleHRDb21wb25lbnQ7IC8vIFRoaXMgZ29hbCBpcyBmb3IgbnVtYmVyIGhhYml0c1xuICAgIG5ld0hhYml0U3RhdHNUeXBlRHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50OyAvLyBSZW1vdmVkIG9wdGlvbmFsXG4gICAgbmV3SGFiaXRTdGF0c1R5cGVTZXR0aW5nRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7IC8vIEluaXRpYWxpemUgdG8gbnVsbCAvLyBTdG9yZSBlbGVtZW50IGZvciB2aXNpYmlsaXR5IHRvZ2dsZVxuXG4gICAgLy8gTmV3IEhhYml0IEJvb2xlYW4gT3B0aW9uc1xuICAgIG5ld0hhYml0RnJlcXVlbmN5RHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50OyAvLyBSZW1vdmVkIG9wdGlvbmFsXG4gICAgbmV3SGFiaXRDb21wbGV0aW9uR29hbElucHV0OiBUZXh0Q29tcG9uZW50OyAvLyBSZW1vdmVkIG9wdGlvbmFsIC8vIFRoaXMgZ29hbCBpcyBmb3IgYm9vbGVhbiBoYWJpdHNcbiAgICBuZXdIYWJpdENvbXBsZXRpb25Hb2FsU2V0dGluZ0VsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsOyAvLyBJbml0aWFsaXplIHRvIG51bGwgLy8gU3RvcmUgZWxlbWVudCBmb3IgdmlzaWJpbGl0eSB0b2dnbGVcblxuXG4gICAgLy8gU3RhdGUgdmFyaWFibGVzIGZvciBuZXcgaGFiaXQgaW5wdXRzXG4gICAgcHJpdmF0ZSBjdXJyZW50TmV3SGFiaXROYW1lOiBzdHJpbmcgPSAnJztcbiAgICBwcml2YXRlIGN1cnJlbnROZXdIYWJpdFR5cGU6IEhhYml0Wyd0eXBlJ10gPSAnYm9vbGVhbic7XG4gICAgcHJpdmF0ZSBjdXJyZW50TmV3SGFiaXRVbml0OiBzdHJpbmcgPSAnJztcbiAgICBwcml2YXRlIGN1cnJlbnROZXdIYWJpdEdvYWw6IHN0cmluZyA9ICcnOyAvLyBGb3IgbnVtYmVyIGdvYWwgKHVzZSBzdHJpbmcgZm9yIGlucHV0KVxuICAgIHByaXZhdGUgY3VycmVudE5ld0hhYml0U3RhdHNUeXBlOiBIYWJpdFsnc3RhdHNUeXBlJ10gPSAnaGVhdG1hcCc7IC8vIERlZmF1bHQgZm9yIG5vbi1udW1iZXIsIHdpbGwgYmUgc2V0IGZvciBudW1iZXJcbiAgICBwcml2YXRlIGN1cnJlbnROZXdIYWJpdEZyZXF1ZW5jeTogSGFiaXRbJ2ZyZXF1ZW5jeSddID0gJ2RheSc7IC8vIERlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICBwcml2YXRlIGN1cnJlbnROZXdIYWJpdENvbXBsZXRpb25Hb2FsOiBzdHJpbmcgPSAnJzsgLy8gRm9yIGJvb2xlYW4gZ29hbCAodXNlIHN0cmluZyBmb3IgaW5wdXQpXG5cblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFRyYWNrZXJQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlZCBTYW1wbGUgU2V0dGluZyBzZWN0aW9uXG4gICAgICAgIC8vIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAvLyAgLnNldE5hbWUoJ1NhbXBsZSBTZXR0aW5nJylcbiAgICAgICAgLy8gIC5zZXREZXNjKCdBIHNhbXBsZSBzZXR0aW5nIGRlc2NyaXB0aW9uLicpXG4gICAgICAgIC8vICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLy8gICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXG4gICAgICAgIC8vICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXG4gICAgICAgIC8vICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcbiAgICAgICAgLy8gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgLy8gICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1N0YXJ0IG9mIFdlZWsnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSB0aGUgZGF5IHlvdXIgd2VlayBzdGFydHMgb24uJylcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKCcwJywgJ1N1bmRheScpO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignMScsICdNb25kYXknKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZShTdHJpbmcodGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vla1N0YXJ0c09uKSk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLndlZWtTdGFydHNPbiA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZS1yZW5kZXIgc2V0dGluZ3MgdGFiIHRvIHJlZmxlY3QgcG90ZW50aWFsIGNoYW5nZXMgaW4gd2VlayBkaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZS1yZW5kZXIgbWFpbiB2aWV3IGFzIHdlZWsgdmlldyBkZXBlbmRzIG9uIHRoaXMgc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5hY3RpdmF0ZVZpZXcoSEFCSVRfVFJBQ0tFUl9WSUVXX1RZUEUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSGFiaXRzIENvbmZpZ3VyYXRpb24nIH0pO1xuXG4gICAgICAgIC8vIEFkZCBidXR0b25zIGZvciByZW9yZGVyaW5nIGhhYml0c1xuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHMuZm9yRWFjaCgoaGFiaXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYWJpdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShgJHtoYWJpdC5uYW1lfSAoJHtoYWJpdC50eXBlfSlgKTtcblxuICAgICAgICAgICAgbGV0IGRlc2MgPSAnJztcbiAgICAgICAgICAgIGlmIChoYWJpdC50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChoYWJpdC51bml0KSBkZXNjICs9IGBVbml0OiAke2hhYml0LnVuaXR9YDtcbiAgICAgICAgICAgICAgICBpZiAoaGFiaXQuZ29hbCAhPT0gdW5kZWZpbmVkICYmIGhhYml0LmdvYWwgIT09IG51bGwgJiYgIWlzTmFOKGhhYml0LmdvYWwpKSBkZXNjICs9IGAke2Rlc2MgPyAnLCAnIDogJyd9IEdvYWw6ICR7aGFiaXQuZ29hbH0ke2hhYml0LnVuaXQgfHwgJyd9YDtcbiAgICAgICAgICAgICAgICBkZXNjICs9IGAke2Rlc2MgPyAnLCAnIDogJyd9IFN0YXRzOiAke2hhYml0LnN0YXRzVHlwZSB8fCAnaGVhdG1hcCd9YDsgLy8gU2hvdyBzdGF0cyB0eXBlIGZvciBudW1iZXJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGV4dCBoYWJpdHMgb25seSBzaG93IHR5cGUgYW5kIG5hbWUgaW4gbGlzdGluZywgc3RhdHMgdHlwZSBpcyBhbHdheXMgaGVhdG1hcFxuICAgICAgICAgICAgICAgIGRlc2MgKz0gYFN0YXRzOiBIZWF0bWFwYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFiaXQudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZGVzYyArPSBgRnJlcXVlbmN5OiAke2hhYml0LmZyZXF1ZW5jeSB8fCAnRGFpbHknfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhhYml0LmNvbXBsZXRpb25Hb2FsICE9PSB1bmRlZmluZWQgJiYgaGFiaXQuY29tcGxldGlvbkdvYWwgIT09IG51bGwgJiYgIWlzTmFOKGhhYml0LmNvbXBsZXRpb25Hb2FsKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjICs9IGAsIEdvYWw6ICR7aGFiaXQuY29tcGxldGlvbkdvYWx9JHtoYWJpdC5mcmVxdWVuY3kgPT09ICd3ZWVrJyA/ICcvd2VlaycgOiAnL2RheSd9YDsgLy8gU2hvdyBnb2FsIGJhc2VkIG9uIGZyZXF1ZW5jeVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCb29sZWFuIGhhYml0cyBhbHdheXMgc2hvdyBoZWF0bWFwIHN0YXRzIHR5cGUgaW4gbGlzdGluZ1xuICAgICAgICAgICAgICAgIGRlc2MgKz0gYCwgU3RhdHM6IEhlYXRtYXBgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYykgaGFiaXRTZXR0aW5nLnNldERlc2MoZGVzYyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBNb3ZlIFVwIGJ1dHRvblxuICAgICAgICAgICAgaGFiaXRTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEljb24oJ3VwLWNoZXZyb24tZ2x5cGgnKSAvLyBPYnNpZGlhbiBidWlsdC1pbiBpY29uIGZvciB1cCBhcnJvd1xuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdNb3ZlIGhhYml0IHVwJylcbiAgICAgICAgICAgICAgICAuc2V0RGlzYWJsZWQoaW5kZXggPT09IDApIC8vIERpc2FibGUgaWYgaXQncyB0aGUgZmlyc3QgaGFiaXRcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIGN1cnJlbnQgaGFiaXQgd2l0aCB0aGUgb25lIGFib3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIYWJpdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1tpbmRleF0gPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW2luZGV4IC0gMV0gPSBjdXJyZW50SGFiaXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpOyAvLyBSZS1yZW5kZXIgc2V0dGluZ3MgdGFiXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmFjdGl2YXRlVmlldyhIQUJJVF9UUkFDS0VSX1ZJRVdfVFlQRSk7IC8vIFJlLXJlbmRlciBtYWluIHZpZXdcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBNb3ZlIERvd24gYnV0dG9uXG4gICAgICAgICAgICBoYWJpdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZG93bi1jaGV2cm9uLWdseXBoJykgLy8gT2JzaWRpYW4gYnVpbHQtaW4gaWNvbiBmb3IgZG93biBhcnJvd1xuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdNb3ZlIGhhYml0IGRvd24nKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZChpbmRleCA9PT0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzLmxlbmd0aCAtIDEpIC8vIERpc2FibGUgaWYgaXQncyB0aGUgbGFzdCBoYWJpdFxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgY3VycmVudCBoYWJpdCB3aXRoIHRoZSBvbmUgYmVsb3cgaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEhhYml0ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW2luZGV4XSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0c1tpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHNbaW5kZXggKyAxXSA9IGN1cnJlbnRIYWJpdDtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciBzZXR0aW5ncyB0YWJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uYWN0aXZhdGVWaWV3KEhBQklUX1RSQUNLRVJfVklFV19UWVBFKTsgLy8gUmUtcmVuZGVyIG1haW4gdmlld1xuICAgICAgICAgICAgICAgIH0pKTtcblxuXG4gICAgICAgICAgICBoYWJpdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZWRpdCcpXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0VkaXQgdGhpcyBoYWJpdCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0TW9kYWwgPSBuZXcgSGFiaXRFZGl0TW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLCBpbmRleCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRNb2RhbC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBoYWJpdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdSZW1vdmUgdGhpcyBoYWJpdCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVkSGFiaXROYW1lID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzW2luZGV4XS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBjb25maXJtYXRpb24gbW9kYWwgZm9yIGRlbGV0aW5nIGEgaGFiaXQgd2l0aCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDb25maXJtYXRpb25Nb2RhbCh0aGlzLmFwcCwgYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgaGFiaXQgXCIke3JlbW92ZWRIYWJpdE5hbWV9XCIgYW5kIGFsbCBpdHMgZGF0YT9gLCBhc3luYyAoY29uZmlybWVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGFiaXRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGUgaW4gdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29tcGxldGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVdPy5bcmVtb3ZlZEhhYml0TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbXBsZXRpb25EYXRhW2RhdGVdW3JlbW92ZWRIYWJpdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgSGFiaXQgXCIke3JlbW92ZWRIYWJpdE5hbWV9XCIgcmVtb3ZlZC5gLCAzMDAwKTsgLy8gU2hvcnRlciBub3RpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmUtcmVuZGVyIHNldHRpbmdzIHRhYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmFjdGl2YXRlVmlldyhIQUJJVF9UUkFDS0VSX1ZJRVdfVFlQRSk7IC8vIFJlLXJlbmRlciBtYWluIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnQWRkIE5ldyBIYWJpdCcgfSk7XG5cbiAgICAgICAgY29uc3QgbmV3SGFiaXRJbnB1dHNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICduZXctaGFiaXQtaW5wdXRzLWNvbnRhaW5lcicgfSk7XG5cbiAgICAgICAgY29uc3QgbmV3SGFiaXRTZXR0aW5nID0gbmV3IFNldHRpbmcobmV3SGFiaXRJbnB1dHNDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSGFiaXQgRGV0YWlscycpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0hhYml0TmFtZUlucHV0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBoYWJpdCBuYW1lJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuY3VycmVudE5ld0hhYml0TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5ld0hhYml0TmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SGFiaXRUeXBlRHJvcGRvd24gPSBkcm9wZG93bjtcbiAgICAgICAgICAgICAgICAvLyBNb2RpZmllZDogQ2hhbmdlZCBkaXNwbGF5IHRleHQgZm9yIGhhYml0IHR5cGVzXG4gICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKCdib29sZWFuJywgJ0Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCd0ZXh0JywgJ1RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdudW1iZXInLCAnTnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1R5cGUgPSB2YWx1ZSBhcyBIYWJpdFsndHlwZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlID0gbmV3VHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3SGFiaXRJbnB1dHNDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgbnVtYmVyIG9wdGlvbnMgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctbnVtYmVyLW9wdGlvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LW51bWJlci1vcHRpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgbnVtYmVyIHNwZWNpZmljIGN1cnJlbnQgdmFsdWVzIHdoZW4gaGlkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRVbml0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRHb2FsID0gJyc7IC8vIFJlc2V0IG51bWJlciBnb2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV3SGFiaXRVbml0SW5wdXQpIHRoaXMubmV3SGFiaXRVbml0SW5wdXQuc2V0VmFsdWUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld0hhYml0R29hbElucHV0KSB0aGlzLm5ld0hhYml0R29hbElucHV0LnNldFZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9nZ2xlIGJvb2xlYW4gb3B0aW9ucyB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctYm9vbGVhbi1vcHRpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDbGFzcygnc2hvdy1ib29sZWFuLW9wdGlvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBib29sZWFuIHNwZWNpZmljIGN1cnJlbnQgdmFsdWVzIHdoZW4gaGlkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRGcmVxdWVuY3kgPSAnZGF5JzsgLy8gUmVzZXQgYm9vbGVhbiBmcmVxdWVuY3kgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROZXdIYWJpdENvbXBsZXRpb25Hb2FsID0gJyc7IC8vIFJlc2V0IGJvb2xlYW4gZ29hbCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld0hhYml0RnJlcXVlbmN5RHJvcGRvd24pIHRoaXMubmV3SGFiaXRGcmVxdWVuY3lEcm9wZG93bi5zZXRWYWx1ZSgnZGF5Jyk7IC8vIFJlc2V0IFVJIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV3SGFiaXRDb21wbGV0aW9uR29hbElucHV0KSB0aGlzLm5ld0hhYml0Q29tcGxldGlvbkdvYWxJbnB1dC5zZXRWYWx1ZSgnJyk7IC8vIFJlc2V0IFVJIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBUZXh0IHR5cGUsIGhpZGUgYWxsIHR5cGUtc3BlY2lmaWMgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LW51bWJlci1vcHRpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LWJvb2xlYW4tb3B0aW9ucycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgc3RhdHMgdHlwZSBvcHRpb24gdmlzaWJpbGl0eSBiYXNlZCBvbiB0eXBlIGFuZCB1cGRhdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVOZXdIYWJpdFN0YXRzVHlwZU9wdGlvblZpc2liaWxpdHkoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLSBOZXcgSGFiaXQgTnVtYmVyIE9wdGlvbnMgLS0tXG4gICAgICAgIGNvbnN0IHVuaXRTZXR0aW5nID0gbmV3IFNldHRpbmcobmV3SGFiaXRJbnB1dHNDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVW5pdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnT3B0aW9uYWwgdW5pdCBmb3IgbnVtYmVyIGhhYml0IChlLmUuLCBcImtnXCIsIFwibWludXRlc1wiKScpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0hhYml0VW5pdElucHV0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB1bml0IChvcHRpb25hbCknKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5jdXJyZW50TmV3SGFiaXRVbml0KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRVbml0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHVuaXRTZXR0aW5nLnNldHRpbmdFbC5hZGRDbGFzcygnbnVtYmVyLW9wdGlvbi1zZXR0aW5nJyk7IC8vIENsYXNzIGZvciBudW1iZXIgb3B0aW9uc1xuXG5cbiAgICAgICAgLy8gVGhpcyBnb2FsIGlzIGZvciBOdW1iZXIgaGFiaXRzXG4gICAgICAgIGNvbnN0IGdvYWxTZXR0aW5nID0gbmV3IFNldHRpbmcobmV3SGFiaXRJbnB1dHNDb250YWluZXIpXG4gICAgICAgICAgICAuc2V0TmFtZSgnR29hbCAoTnVtYmVyKScpIC8vIENsYXJpZnkgd2hpY2ggZ29hbFxuICAgICAgICAgICAgLnNldERlc2MoJ09wdGlvbmFsIHRhcmdldCB2YWx1ZSBmb3IgbnVtYmVyIGhhYml0IHN0YXRpc3RpY3MnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdIYWJpdEdvYWxJbnB1dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgZ29hbCBudW1iZXIgKG9wdGlvbmFsKScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLmN1cnJlbnROZXdIYWJpdEdvYWwpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRHb2FsID0gdmFsdWU7IC8vIFN0b3JlIGFzIHN0cmluZyBmb3Igbm93LCBwYXJzZSBvbiBzYXZlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZ29hbFNldHRpbmcuc2V0dGluZ0VsLmFkZENsYXNzKCdudW1iZXItb3B0aW9uLXNldHRpbmcnKTsgLy8gQ2xhc3MgZm9yIG51bWJlciBvcHRpb25zXG5cblxuICAgICAgICBjb25zdCBuZXdIYWJpdFN0YXRzVHlwZVNldHRpbmcgPSBuZXcgU2V0dGluZyhuZXdIYWJpdElucHV0c0NvbnRhaW5lcilcbiAgICAgICAgICAgIC5zZXROYW1lKCdTdGF0aXN0aWNzIFZpc3VhbGl6YXRpb24nKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSBob3cgdG8gdmlzdWFsaXplIHRoaXMgaGFiaXQgaW4gc3RhdGlzdGljcycpO1xuICAgICAgICAvLyBhZGRDb21wb25lbnQgaXMgc3luY2hyb25vdXMsIGFzc2lnbm1lbnQgc2hvdWxkIGhhcHBlbiBoZXJlXG4gICAgICAgIG5ld0hhYml0U3RhdHNUeXBlU2V0dGluZy5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ld0hhYml0U3RhdHNUeXBlRHJvcGRvd24gPSBkcm9wZG93bjsgLy8gQXNzaWduIHRoZSBpbnN0YW5jZSBoZXJlXG5cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgcG9zc2libGUgb3B0aW9ucyAoaGVhdG1hcCBpcyBkZWZhdWx0IGZvciBub24tbnVtYmVyLCBjaGFydHMgZm9yIG51bWJlcilcbiAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignaGVhdG1hcCcsICdIZWF0bWFwJyk7XG4gICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oJ2JhcicsICdCYXIgQ2hhcnQnKTtcbiAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignbGluZScsICdMaW5lIENoYXJ0Jyk7XG4gICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oJ2NvbWJvJywgJ0NvbWJvIChCYXIgJiBMaW5lKScpO1xuXG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlIGJhc2VkIG9uIGN1cnJlbnROZXdIYWJpdFR5cGUgYW5kIGN1cnJlbnROZXdIYWJpdFN0YXRzVHlwZVxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlID09PSAnbnVtYmVyJyA/ICdiYXInIDogJ2hlYXRtYXAnO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVUb1NldCA9ICh0aGlzLmN1cnJlbnROZXdIYWJpdFR5cGUgPT09ICdudW1iZXInICYmIHRoaXMuY3VycmVudE5ld0hhYml0U3RhdHNUeXBlICE9PSAnaGVhdG1hcCcpID8gdGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh2YWx1ZVRvU2V0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5ld0hhYml0U3RhdHNUeXBlID0gdmFsdWVUb1NldCBhcyBIYWJpdFsnc3RhdHNUeXBlJ107IC8vIEVuc3VyZSBzdGF0ZSBtYXRjaGVzXG5cblxuICAgICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzZWxlY3RlZCB2YWx1ZSBpbiB0aGUgc3RhdGUgdmFyaWFibGVcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROZXdIYWJpdFN0YXRzVHlwZSA9IHZhbHVlIGFzIEhhYml0WydzdGF0c1R5cGUnXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uZXdIYWJpdFN0YXRzVHlwZVNldHRpbmdFbCA9IG5ld0hhYml0U3RhdHNUeXBlU2V0dGluZy5zZXR0aW5nRWw7IC8vIFN0b3JlIHRoZSBlbGVtZW50IGZvciB2aXNpYmlsaXR5IHRvZ2dsZVxuICAgICAgICBuZXdIYWJpdFN0YXRzVHlwZVNldHRpbmcuc2V0dGluZ0VsLmFkZENsYXNzKCdzdGF0cy10eXBlLW9wdGlvbi1zZXR0aW5nJyk7IC8vIENsYXNzIGZvciBzdGF0cyB0eXBlIG9wdGlvblxuICAgICAgICAvLyBIaWRlIGluaXRpYWxseSBiYXNlZCBvbiBjdXJyZW50IHR5cGVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMubmV3SGFiaXRTdGF0c1R5cGVTZXR0aW5nRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gLS0tIE5ldyBIYWJpdCBCb29sZWFuIE9wdGlvbnMgLS0tXG4gICAgICAgIGNvbnN0IG5ld0hhYml0RnJlcXVlbmN5U2V0dGluZyA9IG5ldyBTZXR0aW5nKG5ld0hhYml0SW5wdXRzQ29udGFpbmVyKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ZyZXF1ZW5jeScpXG4gICAgICAgICAgICAuc2V0RGVzYygnSG93IG9mdGVuIGRvIHlvdSB0cmFjayB0aGlzIGhhYml0PycpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SGFiaXRGcmVxdWVuY3lEcm9wZG93biA9IGRyb3Bkb3duOyAvLyBDb3JyZWN0bHkgYXNzaWduIHRoZSBEcm9wZG93bkNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbignZGF5JywgJ0RhaWx5Jyk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKCd3ZWVrJywgJ1dlZWtseScpO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKHRoaXMuY3VycmVudE5ld0hhYml0RnJlcXVlbmN5IHx8ICdkYXknKTsgLy8gRGVmYXVsdCB0byAnZGF5J1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RnJlcSA9IHZhbHVlIGFzIEhhYml0WydmcmVxdWVuY3knXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRGcmVxdWVuY3kgPSBuZXdGcmVxO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXBsZXRpb24gZ29hbCBkZXNjcmlwdGlvbiBkeW5hbWljYWxseT8gUmVxdWlyZXMgbW9yZSB3b3JrLlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5ld0hhYml0RnJlcXVlbmN5U2V0dGluZy5zZXR0aW5nRWwuYWRkQ2xhc3MoJ2Jvb2xlYW4tb3B0aW9uLXNldHRpbmcnKTsgLy8gQ2xhc3MgZm9yIGJvb2xlYW4gb3B0aW9uc1xuXG5cbiAgICAgICAgLy8gVGhpcyBnb2FsIGlzIGZvciBCb29sZWFuIGhhYml0c1xuICAgICAgICBjb25zdCBuZXdIYWJpdENvbXBsZXRpb25Hb2FsU2V0dGluZyA9IG5ldyBTZXR0aW5nKG5ld0hhYml0SW5wdXRzQ29udGFpbmVyKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0NvbXBsZXRpb24gR29hbCcpIC8vIFVzZSBDb21wbGV0aW9uIEdvYWxcbiAgICAgICAgICAgIC5zZXREZXNjKCdUYXJnZXQgbnVtYmVyIG9mIGNvbXBsZXRpb25zIHBlciBkYXkgb3IgcGVyIHdlZWsuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SGFiaXRDb21wbGV0aW9uR29hbElucHV0ID0gdGV4dDsgLy8gVXNlIENvbXBsZXRpb24gR29hbCBJbnB1dFxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGdvYWwgbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuY3VycmVudE5ld0hhYml0Q29tcGxldGlvbkdvYWwpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ29hbFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTsgLy8gVXNlIHBhcnNlSW50IGZvciBmcmVxdWVuY3kgY291bnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRDb21wbGV0aW9uR29hbCA9IHZhbHVlOyAvLyBTdG9yZSBhcyBzdHJpbmcgZm9yIG5vdywgcGFyc2Ugb24gc2F2ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmV3SGFiaXRDb21wbGV0aW9uR29hbFNldHRpbmdFbCA9IG5ld0hhYml0Q29tcGxldGlvbkdvYWxTZXR0aW5nLnNldHRpbmdFbDsgLy8gU3RvcmUgdGhlIGVsZW1lbnQgZm9yIHZpc2liaWxpdHkgdG9nZ2xlXG4gICAgICAgIG5ld0hhYml0Q29tcGxldGlvbkdvYWxTZXR0aW5nLnNldHRpbmdFbC5hZGRDbGFzcygnYm9vbGVhbi1vcHRpb24tc2V0dGluZycpOyAvLyBDbGFzcyBmb3IgYm9vbGVhbiBvcHRpb25zXG5cbiAgICAgICAgLy8gLS0tIEluaXRpYWwgVmlzaWJpbGl0eSBUb2dnbGUgZm9yIE5ldyBIYWJpdCBPcHRpb25zIC0tLVxuICAgICAgICAvLyBUaGVzZSB0b2dnbGVzIGFyZSBoYW5kbGVkIGluIHRoZSBuZXdIYWJpdFR5cGVEcm9wZG93biBvbkNoYW5nZVxuICAgICAgICAvLyBhbmQgYWxzbyBpbml0aWFsbHkgYmVsb3cgYmFzZWQgb24gdGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlXG5cbiAgICAgICAgLy8gSW5pdGlhbCB2aXNpYmlsaXR5IGJhc2VkIG9uIHRoZSBkZWZhdWx0IG9yIGxvYWRlZCBjdXJyZW50TmV3SGFiaXRUeXBlIHN0YXRlXG4gICAgICAgIGNvbnN0IGluaXRpYWxDb250YWluZXIgPSBuZXdIYWJpdElucHV0c0NvbnRhaW5lcjtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluaXRpYWxDb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctbnVtYmVyLW9wdGlvbnMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3Nob3ctbnVtYmVyLW9wdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROZXdIYWJpdFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaW5pdGlhbENvbnRhaW5lci5hZGRDbGFzcygnc2hvdy1ib29sZWFuLW9wdGlvbnMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3Nob3ctYm9vbGVhbi1vcHRpb25zJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgVGV4dCB0eXBlLCBoaWRlIGFsbCB0eXBlLXNwZWNpZmljIG9wdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5ld0hhYml0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBpbml0aWFsQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LW51bWJlci1vcHRpb25zJyk7XG4gICAgICAgICAgICBpbml0aWFsQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LWJvb2xlYW4tb3B0aW9ucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbCB2aXNpYmlsaXR5IGFuZCB2YWx1ZSBzZXR0aW5nIGZvciB0aGUgbmV3IGhhYml0IHN0YXRzIHR5cGUgZHJvcGRvd25cbiAgICAgICAgdGhpcy50b2dnbGVOZXdIYWJpdFN0YXRzVHlwZU9wdGlvblZpc2liaWxpdHkoaW5pdGlhbENvbnRhaW5lcik7XG5cblxuICAgICAgICAvLyAtLS0gQWRkIEhhYml0IEJ1dHRvbiAtLS1cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0SWNvbigncGx1cycpXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0FkZCBoYWJpdCcpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltIYWJpdCBUcmFja2VyXSBBZGQgaGFiaXQgYnV0dG9uIGNsaWNrZWQuXCIpOyAvLyBMb2cgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGFiaXROYW1lID0gdGhpcy5uZXdIYWJpdE5hbWVJbnB1dC5nZXRWYWx1ZSgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGFiaXRUeXBlID0gdGhpcy5uZXdIYWJpdFR5cGVEcm9wZG93bi5nZXRWYWx1ZSgpIGFzIEhhYml0Wyd0eXBlJ107XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbSGFiaXQgVHJhY2tlcl0gTmV3IGhhYml0IGRldGFpbHMgYmVmb3JlIHByb2Nlc3Npbmc6XCIsIHsgbmFtZTogbmV3SGFiaXROYW1lLCB0eXBlOiBuZXdIYWJpdFR5cGUsIHVuaXQ6IHRoaXMuY3VycmVudE5ld0hhYml0VW5pdCwgZ29hbDogdGhpcy5jdXJyZW50TmV3SGFiaXRHb2FsLCBzdGF0c1R5cGU6IHRoaXMuY3VycmVudE5ld0hhYml0U3RhdHNUeXBlLCBmcmVxdWVuY3k6IHRoaXMuY3VycmVudE5ld0hhYml0RnJlcXVlbmN5LCBjb21wbGV0aW9uR29hbDogdGhpcy5jdXJyZW50TmV3SGFiaXRDb21wbGV0aW9uR29hbCB9KTsgLy8gTG9nIGdhdGhlcmVkIGRhdGFcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3SGFiaXROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdIYWJpdCBuYW1lIGNhbm5vdCBiZSBlbXB0eS4nLCAyMDAwKTsgLy8gU2hvcnRlciBub3RpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIEhhYml0IG5hbWUgaXMgZW1wdHksIHNob3dpbmcgbm90aWNlLlwiKTsgLy8gTG9nIHZhbGlkYXRpb24gZmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0cy5zb21lKGggPT4gaC5uYW1lID09PSBuZXdIYWJpdE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBIYWJpdCBcIiR7bmV3SGFiaXROYW1lfVwiIGFscmVhZHkgZXhpc3RzLmAsIDIwMDApOyAvLyBTaG9ydGVyIG5vdGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYWJpdCBUcmFja2VyXSBEdXBsaWNhdGUgaGFiaXQgbmFtZSBcIiR7bmV3SGFiaXROYW1lfVwiLCBzaG93aW5nIG5vdGljZS5gKTsgLy8gTG9nIHZhbGlkYXRpb24gZmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGFiaXQ6IEhhYml0ID0geyBuYW1lOiBuZXdIYWJpdE5hbWUsIHR5cGU6IG5ld0hhYml0VHlwZSB9OyAvLyBTdGFydCB3aXRoIGJhc2UgcHJvcGVydGllc1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0eXBlLXNwZWNpZmljIHByb3BlcnRpZXMgYmFzZWQgb24gdGhlIHNlbGVjdGVkIHR5cGUgYW5kIHN0YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SGFiaXRUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SGFiaXQudW5pdCA9IHRoaXMuY3VycmVudE5ld0hhYml0VW5pdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnb2FsVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuY3VycmVudE5ld0hhYml0R29hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdIYWJpdC5nb2FsID0gKCFpc05hTihnb2FsVmFsdWUpICYmIHRoaXMuY3VycmVudE5ld0hhYml0R29hbCAhPT0gJycpID8gZ29hbFZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdHNUeXBlIGZvciBudW1iZXIgaXMgdGFrZW4gZnJvbSB0aGUgZHJvcGRvd24gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hhYml0LnN0YXRzVHlwZSA9ICh0aGlzLmN1cnJlbnROZXdIYWJpdFN0YXRzVHlwZSAhPT0gJ2hlYXRtYXAnICYmIHRoaXMuY3VycmVudE5ld0hhYml0U3RhdHNUeXBlICE9PSB1bmRlZmluZWQpID8gdGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgOiAnYmFyJzsgLy8gRGVmYXVsdCB0byBiYXIgaWYgaGVhdG1hcCBvciB1bmRlZmluZWQgc3RhdGVcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld0hhYml0VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdIYWJpdC5mcmVxdWVuY3kgPSB0aGlzLmN1cnJlbnROZXdIYWJpdEZyZXF1ZW5jeSB8fCAnZGF5JzsgLy8gU2hvdWxkIGFsd2F5cyBoYXZlIGEgZnJlcXVlbmN5IGZyb20gZHJvcGRvd24gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25Hb2FsVmFsdWUgPSBwYXJzZUludCh0aGlzLmN1cnJlbnROZXdIYWJpdENvbXBsZXRpb25Hb2FsLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdIYWJpdC5jb21wbGV0aW9uR29hbCA9ICghaXNOYU4oY29tcGxldGlvbkdvYWxWYWx1ZSkgJiYgY29tcGxldGlvbkdvYWxWYWx1ZSA+IDAgJiYgdGhpcy5jdXJyZW50TmV3SGFiaXRDb21wbGV0aW9uR29hbCAhPT0gJycpID8gY29tcGxldGlvbkdvYWxWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gaGFiaXRzIGFsd2F5cyBoYXZlIGhlYXRtYXAgc3RhdHMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SGFiaXQuc3RhdHNUeXBlID0gJ2hlYXRtYXAnO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3SGFiaXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRleHQgaGFiaXQgYWx3YXlzIGhhcyBoZWF0bWFwIHN0YXRzIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hhYml0LnN0YXRzVHlwZSA9ICdoZWF0bWFwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbSGFiaXQgVHJhY2tlcl0gQWRkaW5nIG5ldyBoYWJpdCB0byBzZXR0aW5nczpcIiwgbmV3SGFiaXQpOyAvLyBMb2cgYmVmb3JlIGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oYWJpdHMucHVzaChuZXdIYWJpdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIEhhYml0cyBhZnRlciBhZGRpbmc6XCIsIHRoaXMucGx1Z2luLnNldHRpbmdzLmhhYml0cyk7IC8vIExvZyBhZnRlciBhZGRpbmdcblxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIFNhdmluZyBzZXR0aW5ncy4uLlwiKTsgLy8gTG9nIGJlZm9yZSBzYXZpbmdcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hhYml0IFRyYWNrZXJdIFNldHRpbmdzIHNhdmVkLlwiKTsgLy8gTG9nIGFmdGVyIHNhdmluZ1xuXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEhhYml0IFwiJHtuZXdIYWJpdE5hbWV9XCIgYWRkZWQuYCwgMzAwMCk7IC8vIFNob3J0ZXIgbm90aWNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFiaXQgVHJhY2tlcl0gU2hvd2luZyBzdWNjZXNzIG5vdGljZSBmb3IgXCIke25ld0hhYml0TmFtZX1cIi5gKTsgLy8gTG9nIG5vdGljZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlucHV0IGZpZWxkcyBhbmQgY3VycmVudCBzdGF0ZSB2YXJpYWJsZXMgZm9yIHRoZSBhZGQgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0hhYml0TmFtZUlucHV0LnNldFZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXROYW1lID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdIYWJpdFR5cGVEcm9wZG93bi5zZXRWYWx1ZSgnYm9vbGVhbicpOyAvLyBSZXNldCB0eXBlIGRyb3Bkb3duIHRvIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlID0gJ2Jvb2xlYW4nOyAvLyBSZXNldCB0eXBlIHN0YXRlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc3BlY2lmaWMgaW5wdXQgdmFsdWVzIGFuZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzZXQgdHlwZSAoYm9vbGVhbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRVbml0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld0hhYml0VW5pdElucHV0KSB0aGlzLm5ld0hhYml0VW5pdElucHV0LnNldFZhbHVlKCcnKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROZXdIYWJpdEdvYWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV3SGFiaXRHb2FsSW5wdXQpIHRoaXMubmV3SGFiaXRHb2FsSW5wdXQuc2V0VmFsdWUoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5ld0hhYml0RnJlcXVlbmN5ID0gJ2RheSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld0hhYml0RnJlcXVlbmN5RHJvcGRvd24pIHRoaXMubmV3SGFiaXRGcmVxdWVuY3lEcm9wZG93bi5zZXRWYWx1ZSgnZGF5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRDb21wbGV0aW9uR29hbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdIYWJpdENvbXBsZXRpb25Hb2FsSW5wdXQpIHRoaXMubmV3SGFiaXRDb21wbGV0aW9uR29hbElucHV0LnNldFZhbHVlKCcnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdGF0cyB0eXBlIGRyb3Bkb3duIGFuZCBzdGF0ZSBmb3IgdGhlIGRlZmF1bHQgYm9vbGVhbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5ld0hhYml0U3RhdHNUeXBlID0gJ2hlYXRtYXAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdIYWJpdFN0YXRzVHlwZURyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGVtcHR5IGFuZCByZS1hZGQsIGp1c3Qgc2V0IHRoZSB2YWx1ZSBhbmQgZW5zdXJlIG9wdGlvbnMgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3SGFiaXRTdGF0c1R5cGVEcm9wZG93bi5zZXRWYWx1ZSgnaGVhdG1hcCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIG51bWJlciBvcHRpb25zIGFuZCBlbnN1cmUgYm9vbGVhbiBvcHRpb25zIGFyZSBzaG93biBmb3IgdGhlIHJlc2V0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgbmV3SGFiaXRJbnB1dHNDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3Nob3ctbnVtYmVyLW9wdGlvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGFiaXRJbnB1dHNDb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctYm9vbGVhbi1vcHRpb25zJyk7IC8vIEVuc3VyZSBib29sZWFuIG9wdGlvbnMgYXJlIHZpc2libGVcblxuICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgc3RhdHMgdHlwZSBvcHRpb24gdmlzaWJpbGl0eSBiYXNlZCBvbiB0aGUgcmVzZXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZU5ld0hhYml0U3RhdHNUeXBlT3B0aW9uVmlzaWJpbGl0eShuZXdIYWJpdElucHV0c0NvbnRhaW5lcik7XG5cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmUtcmVuZGVyIHNldHRpbmdzIHRhYiB0byBzaG93IHRoZSBuZXcgaGFiaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbSGFiaXQgVHJhY2tlcl0gU2V0dGluZ3MgdGFiIHJlLXJlbmRlcmVkLlwiKTsgLy8gTG9nIGFmdGVyIHJlLXJlbmRlcmluZ1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmFjdGl2YXRlVmlldyhIQUJJVF9UUkFDS0VSX1ZJRVdfVFlQRSk7IC8vIFJlLXJlbmRlciBtYWluIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbSGFiaXQgVHJhY2tlcl0gTWFpbiB2aWV3IGFjdGl2YXRlZC5cIik7IC8vIExvZyBhZnRlciBhY3RpdmF0aW5nIHZpZXdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbmV3IGhhYml0IHN0YXRzIHR5cGUgZHJvcGRvd25cbiAgICAvLyBhbmQgdXBkYXRlIHRoZSBjdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgc3RhdGUgYmFzZWQgb24gdGhlIHR5cGVcbiAgICB0b2dnbGVOZXdIYWJpdFN0YXRzVHlwZU9wdGlvblZpc2liaWxpdHkoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHN0YXRzVHlwZVNldHRpbmdFbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5zdGF0cy10eXBlLW9wdGlvbi1zZXR0aW5nJykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZXR0aW5nIGVsZW1lbnQgYW5kIGRyb3Bkb3duIGluc3RhbmNlIGV4aXN0XG4gICAgICAgIGlmIChzdGF0c1R5cGVTZXR0aW5nRWwgJiYgdGhpcy5uZXdIYWJpdFN0YXRzVHlwZURyb3Bkb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TmV3SGFiaXRUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0YXRzVHlwZVNldHRpbmdFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc3RhdGUgdmFyaWFibGUgaGFzIGEgdmFsaWQgY2hhcnQgdHlwZSBpZiBpdCB3YXMgaGVhdG1hcCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgPT09ICdoZWF0bWFwJyB8fCAhdGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgPSAnYmFyJzsgLy8gRGVmYXVsdCB0byBiYXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdIYWJpdFN0YXRzVHlwZURyb3Bkb3duLnNldFZhbHVlKCdiYXInKTsgLy8gVXBkYXRlIGRyb3Bkb3duIFVJXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB2YWxpZCBjaGFydCB0eXBlIHdhcyBhbHJlYWR5IGluIHN0YXRlLCBlbnN1cmUgZHJvcGRvd24gbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0hhYml0U3RhdHNUeXBlRHJvcGRvd24uc2V0VmFsdWUodGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gYm9vbGVhbiBvciB0ZXh0XG4gICAgICAgICAgICAgICAgc3RhdHNUeXBlU2V0dGluZ0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzdGF0ZSB2YXJpYWJsZSBpcyBoZWF0bWFwIGZvciBub24tbnVtYmVyIHR5cGVzXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TmV3SGFiaXRTdGF0c1R5cGUgPSAnaGVhdG1hcCc7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdIYWJpdFN0YXRzVHlwZURyb3Bkb3duLnNldFZhbHVlKCdoZWF0bWFwJyk7IC8vIFVwZGF0ZSBkcm9wZG93biBVSVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzVHlwZVNldHRpbmdFbCkge1xuICAgICAgICAgICAgLy8gVGhlIGRyb3Bkb3duIGNvbXBvbmVudCBoYXNuJ3QgYmVlbiBhc3NpZ25lZCB5ZXQsIGJ1dCB0aGUgc2V0dGluZyBlbGVtZW50IGV4aXN0cy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IHRoZSBpbml0aWFsIGNhbGwgZHVyaW5nIGRpc3BsYXkgYmVmb3JlIGFkZERyb3Bkb3duIGNhbGxiYWNrIGZpbmlzaGVzLlxuICAgICAgICAgICAgLy8gV2UganVzdCBzZXQgdmlzaWJpbGl0eSBiYXNlZCBvbiB0aGUgY3VycmVudCB0eXBlLlxuICAgICAgICAgICAgc3RhdHNUeXBlU2V0dGluZ0VsLnN0eWxlLmRpc3BsYXkgPSB0aGlzLmN1cnJlbnROZXdIYWJpdFR5cGUgPT09ICdudW1iZXInID8gJ2ZsZXgnIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuICAgICAgICAvLyBXaGVuIGNsb3NpbmcgdGhlIHNldHRpbmdzIHRhYiwgcmUtcmVuZGVyIHRoZSBtYWluIHZpZXcgdG8gcmVmbGVjdCBhbnkgaGFiaXQgY2hhbmdlc1xuICAgICAgICB0aGlzLnBsdWdpbi5hY3RpdmF0ZVZpZXcoSEFCSVRfVFJBQ0tFUl9WSUVXX1RZUEUpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzd2FwIGVsZW1lbnRzIGluIGFuIGFycmF5IC0gTm90IHVzZWQgaW4gcHJvdmlkZWQgY29kZSBmb3IgcmVvcmRlcmluZywgYnV0IGNhbiBiZSB1c2VmdWxcbiAgICAvLyBzd2FwQXJyYXlFbGVtZW50cyhhcnI6IGFueVtdLCBpbmRleDE6IG51bWJlciwgaW5kZXgyOiBudW1iZXIpIHtcbiAgICAvLyAgaWYgKGluZGV4MSA8IDAgfHwgaW5kZXgxID49IGFyci5sZW5ndGggfHwgaW5kZXgyIDwgMCB8fCBpbmRleDIgPj0gYXJyLmxlbmd0aCkge1xuICAgIC8vICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnZhbGlkIGluZGljZXNcbiAgICAvLyAgfVxuICAgIC8vICBjb25zdCB0ZW1wID0gYXJyW2luZGV4MV07XG4gICAgLy8gIGFycltpbmRleDFdID0gYXJyW2luZGV4Ml07XG4gICAgLy8gIGFycltpbmRleDJdID0gdGVtcDtcbiAgICAvLyAgcmV0dXJuIHRydWU7XG4gICAgLy8gfVxufVxuXG4vLyBIZWxwZXIgTW9kYWwgZm9yIENvbmZpcm1hdGlvbiAoZS5nLiwgZGVsZXRpbmcgaGFiaXQgd2l0aCBkYXRhKVxuY2xhc3MgQ29uZmlybWF0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIGNhbGxiYWNrOiAoY29uZmlybWVkOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG1lc3NhZ2U6IHN0cmluZywgY2FsbGJhY2s6IChjb25maXJtZWQ6IGJvb2xlYW4pID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwsIG1vZGFsRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogdGhpcy5tZXNzYWdlIH0pO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IG1vZGFsRWwuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnbW9kYWwtYnV0dG9uLWNvbnRhaW5lcicgfSk7XG5cbiAgICAgICAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnWWVzJywgY2xzOiAnbW9kLXdhcm5pbmcnIH0pOyAvLyBVc2UgbW9kLXdhcm5pbmcgZm9yIGRlc3RydWN0aXZlIGFjdGlvbnNcbiAgICAgICAgY29uc3QgY2FuY2VsQnV0dG9uID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdObycgfSk7XG5cbiAgICAgICAgY29uZmlybUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuIiwgIi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4zLjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyNCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSwgMCwgMTAwKTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuXG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cblxuY29uc3QgbWFwID0ge1xuXHR4OiAnZGFyaycsXG5cdFo6ICdsaWdodCcsXG5cdFk6ICdyZScsXG5cdFg6ICdibHUnLFxuXHRXOiAnZ3InLFxuXHRWOiAnbWVkaXVtJyxcblx0VTogJ3NsYXRlJyxcblx0QTogJ2VlJyxcblx0VDogJ29sJyxcblx0UzogJ29yJyxcblx0QjogJ3JhJyxcblx0QzogJ2xhdGVnJyxcblx0RDogJ2lnaHRzJyxcblx0UjogJ2luJyxcblx0UTogJ3R1cnF1b2lzJyxcblx0RTogJ2hpJyxcblx0UDogJ3JvJyxcblx0TzogJ2FsJyxcblx0TjogJ2xlJyxcblx0TTogJ2RlJyxcblx0TDogJ3llbGxvJyxcblx0RjogJ2VuJyxcblx0SzogJ2NoJyxcblx0RzogJ2Fya3MnLFxuXHRIOiAnZWEnLFxuXHRJOiAnaWdodGcnLFxuXHRKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMkMSA9IHtcblx0T2ljZVhlOiAnZjBmOGZmJyxcblx0YW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuXHRhcXVhOiAnZmZmZicsXG5cdGFxdWFtYXJSZTogJzdmZmZkNCcsXG5cdGF6dVk6ICdmMGZmZmYnLFxuXHRiZWlnZTogJ2Y1ZjVkYycsXG5cdGJpc3F1ZTogJ2ZmZTRjNCcsXG5cdGJsYWNrOiAnMCcsXG5cdGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG5cdFhlOiAnZmYnLFxuXHRYZXZpVGV0OiAnOGEyYmUyJyxcblx0YlB3bjogJ2E1MmEyYScsXG5cdGJ1cmx5d29vZDogJ2RlYjg4NycsXG5cdGNhTXRYZTogJzVmOWVhMCcsXG5cdEthcnRZdXNlOiAnN2ZmZjAwJyxcblx0S29jVGF0ZTogJ2QyNjkxZScsXG5cdGNTTzogJ2ZmN2Y1MCcsXG5cdGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcblx0Y1Nuc2lsazogJ2ZmZjhkYycsXG5cdGNyaW1zb246ICdkYzE0M2MnLFxuXHRjeWFuOiAnZmZmZicsXG5cdHhYZTogJzhiJyxcblx0eGN5YW46ICc4YjhiJyxcblx0eGdUTW5QZDogJ2I4ODYwYicsXG5cdHhXYXk6ICdhOWE5YTknLFxuXHR4Z1lGOiAnNjQwMCcsXG5cdHhnWXk6ICdhOWE5YTknLFxuXHR4a2hha2k6ICdiZGI3NmInLFxuXHR4bWFnRnRhOiAnOGIwMDhiJyxcblx0eFRpdmVnWUY6ICc1NTZiMmYnLFxuXHR4U2FuZ2U6ICdmZjhjMDAnLFxuXHR4U2NFZDogJzk5MzJjYycsXG5cdHhZZDogJzhiMDAwMCcsXG5cdHhzT21vbjogJ2U5OTY3YScsXG5cdHhzSGdZRjogJzhmYmM4ZicsXG5cdHhVWGU6ICc0ODNkOGInLFxuXHR4VVdheTogJzJmNGY0ZicsXG5cdHhVZ1l5OiAnMmY0ZjRmJyxcblx0eFFlOiAnY2VkMScsXG5cdHh2aVRldDogJzk0MDBkMycsXG5cdGRBcHBSazogJ2ZmMTQ5MycsXG5cdGRBcHNreVhlOiAnYmZmZicsXG5cdGRpbVdheTogJzY5Njk2OScsXG5cdGRpbWdZeTogJzY5Njk2OScsXG5cdGRvZGdlclhlOiAnMWU5MGZmJyxcblx0ZmlZYnJpY2s6ICdiMjIyMjInLFxuXHRmbFNPd0V0ZTogJ2ZmZmFmMCcsXG5cdGZvWXN0V0FuOiAnMjI4YjIyJyxcblx0ZnVLc2lhOiAnZmYwMGZmJyxcblx0Z2FSc2JTbzogJ2RjZGNkYycsXG5cdGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG5cdGdUZDogJ2ZmZDcwMCcsXG5cdGdUTW5QZDogJ2RhYTUyMCcsXG5cdFdheTogJzgwODA4MCcsXG5cdGdZRjogJzgwMDAnLFxuXHRnWUZMdzogJ2FkZmYyZicsXG5cdGdZeTogJzgwODA4MCcsXG5cdGhvbmV5TXc6ICdmMGZmZjAnLFxuXHRob3RwUms6ICdmZjY5YjQnLFxuXHRSZGlhbllkOiAnY2Q1YzVjJyxcblx0UmRpZ286ICc0YjAwODInLFxuXHRpdlN5OiAnZmZmZmYwJyxcblx0a2hha2k6ICdmMGU2OGMnLFxuXHRsYXZGTXI6ICdlNmU2ZmEnLFxuXHRsYXZGTXJYc2g6ICdmZmYwZjUnLFxuXHRsYXduZ1lGOiAnN2NmYzAwJyxcblx0Tm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG5cdFpYZTogJ2FkZDhlNicsXG5cdFpjU086ICdmMDgwODAnLFxuXHRaY3lhbjogJ2UwZmZmZicsXG5cdFpnVE1uUGRMdzogJ2ZhZmFkMicsXG5cdFpXYXk6ICdkM2QzZDMnLFxuXHRaZ1lGOiAnOTBlZTkwJyxcblx0WmdZeTogJ2QzZDNkMycsXG5cdFpwUms6ICdmZmI2YzEnLFxuXHRac09tb246ICdmZmEwN2EnLFxuXHRac0hnWUY6ICcyMGIyYWEnLFxuXHRac2t5WGU6ICc4N2NlZmEnLFxuXHRaVVdheTogJzc3ODg5OScsXG5cdFpVZ1l5OiAnNzc4ODk5Jyxcblx0WnN0QWxYZTogJ2IwYzRkZScsXG5cdFpMdzogJ2ZmZmZlMCcsXG5cdGxpbWU6ICdmZjAwJyxcblx0bGltZWdZRjogJzMyY2QzMicsXG5cdGxSRjogJ2ZhZjBlNicsXG5cdG1hZ0Z0YTogJ2ZmMDBmZicsXG5cdG1hUG9uOiAnODAwMDAwJyxcblx0VmFxdWFtYXJSZTogJzY2Y2RhYScsXG5cdFZYZTogJ2NkJyxcblx0VlNjRWQ6ICdiYTU1ZDMnLFxuXHRWcHVycE46ICc5MzcwZGInLFxuXHRWc0hnWUY6ICczY2IzNzEnLFxuXHRWVVhlOiAnN2I2OGVlJyxcblx0VnNwclJnZ1lGOiAnZmE5YScsXG5cdFZRZTogJzQ4ZDFjYycsXG5cdFZ2aVRldFlkOiAnYzcxNTg1Jyxcblx0bWlkbmlnaHRYZTogJzE5MTk3MCcsXG5cdG1SdGNZYW06ICdmNWZmZmEnLFxuXHRtaXN0eVBzZTogJ2ZmZTRlMScsXG5cdG1vY2Nhc1I6ICdmZmU0YjUnLFxuXHRuYXZham93RXRlOiAnZmZkZWFkJyxcblx0bmF2eTogJzgwJyxcblx0VGRsYWNlOiAnZmRmNWU2Jyxcblx0VGl2ZTogJzgwODAwMCcsXG5cdFRpdmVkQmI6ICc2YjhlMjMnLFxuXHRTYW5nZTogJ2ZmYTUwMCcsXG5cdFNhbmdlWWQ6ICdmZjQ1MDAnLFxuXHRTY0VkOiAnZGE3MGQ2Jyxcblx0cE9lZ1RNblBkOiAnZWVlOGFhJyxcblx0cE9lZ1lGOiAnOThmYjk4Jyxcblx0cE9lUWU6ICdhZmVlZWUnLFxuXHRwT2V2aVRldFlkOiAnZGI3MDkzJyxcblx0cGFwYXlhd0VwOiAnZmZlZmQ1Jyxcblx0cEhLcHVmZjogJ2ZmZGFiOScsXG5cdHBlcnU6ICdjZDg1M2YnLFxuXHRwUms6ICdmZmMwY2InLFxuXHRwbHVtOiAnZGRhMGRkJyxcblx0cG93TXJYZTogJ2IwZTBlNicsXG5cdHB1cnBOOiAnODAwMDgwJyxcblx0WWJlY2NhcHVycE46ICc2NjMzOTknLFxuXHRZZDogJ2ZmMDAwMCcsXG5cdFBzeWJyb3duOiAnYmM4ZjhmJyxcblx0UHlPWGU6ICc0MTY5ZTEnLFxuXHRzYWRkTmJQd246ICc4YjQ1MTMnLFxuXHRzT21vbjogJ2ZhODA3MicsXG5cdHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG5cdHNIZ1lGOiAnMmU4YjU3Jyxcblx0c0hzaGVsbDogJ2ZmZjVlZScsXG5cdHNpRm5hOiAnYTA1MjJkJyxcblx0c2lsdmVyOiAnYzBjMGMwJyxcblx0c2t5WGU6ICc4N2NlZWInLFxuXHRVWGU6ICc2YTVhY2QnLFxuXHRVV2F5OiAnNzA4MDkwJyxcblx0VWdZeTogJzcwODA5MCcsXG5cdHNub3c6ICdmZmZhZmEnLFxuXHRzcHJSZ2dZRjogJ2ZmN2YnLFxuXHRzdEFsWGU6ICc0NjgyYjQnLFxuXHR0YW46ICdkMmI0OGMnLFxuXHR0ZU86ICc4MDgwJyxcblx0dEVzdE46ICdkOGJmZDgnLFxuXHR0b21hdG86ICdmZjYzNDcnLFxuXHRRZTogJzQwZTBkMCcsXG5cdHZpVGV0OiAnZWU4MmVlJyxcblx0Skh0OiAnZjVkZWIzJyxcblx0d0V0ZTogJ2ZmZmZmZicsXG5cdHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG5cdEx3OiAnZmZmZjAwJyxcblx0THdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuICBjb25zdCB1bnBhY2tlZCA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMkMSk7XG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgbGV0IGksIGosIGssIG9rLCBuaztcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvayA9IG5rID0ga2V5c1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGsgPSB0a2V5c1tqXTtcbiAgICAgIG5rID0gbmsucmVwbGFjZShrLCBtYXBba10pO1xuICAgIH1cbiAgICBrID0gcGFyc2VJbnQobmFtZXMkMVtva10sIDE2KTtcbiAgICB1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWQ7XG59XG5cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuXG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuXG5jb25zdCB0byA9IHYgPT4gdiA8PSAwLjAwMzEzMDggPyB2ICogMTIuOTIgOiBNYXRoLnBvdyh2LCAxLjAgLyAyLjQpICogMS4wNTUgLSAwLjA1NTtcbmNvbnN0IGZyb20gPSB2ID0+IHYgPD0gMC4wNDA0NSA/IHYgLyAxMi45MiA6IE1hdGgucG93KCh2ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShyZ2IxLCByZ2IyLCB0KSB7XG4gIGNvbnN0IHIgPSBmcm9tKGIybihyZ2IxLnIpKTtcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xuICBjb25zdCBiID0gZnJvbShiMm4ocmdiMS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcbiAgICBnOiBuMmIodG8oZyArIHQgKiAoZnJvbShiMm4ocmdiMi5nKSkgLSBnKSkpLFxuICAgIGI6IG4yYih0byhiICsgdCAqIChmcm9tKGIybihyZ2IyLmIpKSAtIGIpKSksXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZXhwb3J0IHsgQ29sb3IsIGIybiwgYjJwLCBpbmRleF9lc20gYXMgZGVmYXVsdCwgaGV4UGFyc2UsIGhleFN0cmluZywgaHNsMnJnYiwgaHNsU3RyaW5nLCBoc3YycmdiLCBodWVQYXJzZSwgaHdiMnJnYiwgbGltLCBuMmIsIG4ycCwgbmFtZVBhcnNlLCBwMmIsIHJnYjJoc2wsIHJnYlBhcnNlLCByZ2JTdHJpbmcsIHJvdGF0ZSwgcm91bmQgfTtcbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtBY3RpdmVEYXRhUG9pbnQsIENoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuLyoqXG4gKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcbiAgLyogbm9vcCAqL1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVpZCA9ICgoKSA9PiB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiAoKSA9PiBpZCsrO1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudWxsIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheTxUID0gdW5rbm93bj4odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUW10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQW55T2JqZWN0IHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG4gKiBAcGFyYW0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyRmluaXRlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVtYmVyIHtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xufVxuZXhwb3J0IHtcbiAgaXNOdW1iZXJGaW5pdGUgYXMgaXNGaW5pdGUsXG59O1xuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBmaW5pdGUsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgbm90IGZpbml0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZTogdW5rbm93biwgZGVmYXVsdFZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0PFQ+KHZhbHVlOiBUIHwgdW5kZWZpbmVkLCBkZWZhdWx0VmFsdWU6IFQpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogK3ZhbHVlIC8gZGltZW5zaW9uO1xuXG5leHBvcnQgY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcblxuLyoqXG4gKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsYmFjazxUIGV4dGVuZHMgKHRoaXM6IFRBLCAuLi5yZXN0QXJnczogdW5rbm93bltdKSA9PiBSLCBUQSwgUj4oXG4gIGZuOiBUIHwgdW5kZWZpbmVkLFxuICBhcmdzOiB1bmtub3duW10sXG4gIHRoaXNBcmc/OiBUQVxuKTogUiB8IHVuZGVmaW5lZCB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxuICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2VcbiAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG4gKiBAcGFyYW0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICogQHBhcmFtIFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IHN0cmluZykgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSxcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogbnVtYmVyKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdIHwgUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IGFueSkgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKSB7XG4gIGxldCBpOiBudW1iZXIsIGxlbjogbnVtYmVyLCBrZXlzOiBzdHJpbmdbXTtcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBgYTBgIGFuZCBgYTFgIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcGFyYW0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwOiBBY3RpdmVEYXRhUG9pbnRbXSwgYTE6IEFjdGl2ZURhdGFQb2ludFtdKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdjA6IEFjdGl2ZURhdGFQb2ludCwgdjE6IEFjdGl2ZURhdGFQb2ludDtcblxuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG5cbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmU8VD4oc291cmNlOiBUKTogVCB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSkgYXMgdW5rbm93biBhcyBUO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG5cbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZykge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG4gKiBOb3RlKFNCKTogYWxzbyB1c2VkIGJ5IG1lcmdlQ29uZmlnIGFuZCBtZXJnZVNjYWxlQ29uZmlnIGFzIGZhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXIoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9uczogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXJnZU9wdGlvbnMge1xuICBtZXJnZXI/OiAoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9ucz86IEFueU9iamVjdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XG4gKiBAcGFyYW0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzMsIFM0PihcbiAgdGFyZ2V0OiBULFxuICBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0sXG4gIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnNcbik6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0IHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldCBhcyBBbnlPYmplY3Q7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgbGV0IGN1cnJlbnQ6IEFueU9iamVjdDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3QoY3VycmVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBjdXJyZW50LCBvcHRpb25zIGFzIEFueU9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzMsIFM0Pih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSk6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgcmV0dXJuIG1lcmdlPFQ+KHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcklmKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZTogc3RyaW5nLCB2YWx1ZTogdW5rbm93biwgcHJldmlvdXM6IHN0cmluZywgY3VycmVudDogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuICAgICAgJ1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cblxuLy8gcmVzb2x2ZU9iamVjdEtleSByZXNvbHZlciBjYWNoZVxuY29uc3Qga2V5UmVzb2x2ZXJzID0ge1xuICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgcmVzb2x2ZSBlbXB0eSBrZXkgdG8gcm9vdCBvYmplY3RcbiAgJyc6IHYgPT4gdixcbiAgLy8gZGVmYXVsdCByZXNvbHZlcnNcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKGsgPT09ICcnKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OlxuICAgICAgICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgYnJlYWsgYXQgZW1wdHkga2V5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqOiBBbnlPYmplY3QsIGtleTogc3RyaW5nKTogYW55IHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmVkID0gKHZhbHVlOiB1bmtub3duKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxMTI4ODU1L2NvbXBhcmluZy1lY21hNi1zZXRzLWZvci1lcXVhbGl0eSMzMTEyOTM4NFxuZXhwb3J0IGNvbnN0IHNldHNFcXVhbCA9IDxUPihhOiBTZXQ8VD4sIGI6IFNldDxUPikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGUgLSBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNDbGlja0V2ZW50KGU6IENoYXJ0RXZlbnQpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXG5leHBvcnQgY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IFRBVSA9IDIgKiBQSTtcbmV4cG9ydCBjb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuZXhwb3J0IGNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5leHBvcnQgY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmV4cG9ydCBjb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuZXhwb3J0IGNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RFcXVhbHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZU51bShyYW5nZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWU6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG5cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGF0dGVtcHRpbmcgdG8gY29lcmNlIG4gdG8gc3RyaW5nIG9yIG51bWJlciB3b24ndCB0aHJvdyBhIFR5cGVFcnJvci5cbiAqL1xuZnVuY3Rpb24gaXNOb25QcmltaXRpdmUobjogdW5rbm93bikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdzeW1ib2wnIHx8ICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgbiAhPT0gbnVsbCAmJiAhKFN5bWJvbC50b1ByaW1pdGl2ZSBpbiBuIHx8ICd0b1N0cmluZycgaW4gbiB8fCAndmFsdWVPZicgaW4gbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05vblByaW1pdGl2ZShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuIGFzIHN0cmluZykpICYmIGlzRmluaXRlKG4gYXMgbnVtYmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdFdob2xlKHg6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShcbiAgYXJyYXk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAgdGFyZ2V0OiB7IG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciB9LFxuICBwcm9wZXJ0eTogc3RyaW5nXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeDogbnVtYmVyKSB7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChcbiAgY2VudHJlUG9pbnQ6IFBvaW50LFxuICBhbmdsZVBvaW50OiBQb2ludFxuKSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDE6IFBvaW50LCBwdDI6IFBvaW50KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlRGlmZihhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlPzogYm9vbGVhbikge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cblxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuIiwgImltcG9ydCB7X2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBjbXBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwKFxuICB0YWJsZTogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cDxUPihcbiAgdGFibGU6IFRbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wOiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKToge2xvOiBudW1iZXIsIGhpOiBudW1iZXJ9O1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiB1bmtub3duW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDogbnVtYmVyO1xuXG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bG8sIGhpfTtcbn1cblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGxhc3QgLSBsb29rdXAgbGFzdCBpbmRleFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9sb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXIsXG4gIGxhc3Q/OiBib29sZWFuXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB7XG4gICAgICBjb25zdCB0aSA9IHRhYmxlW2luZGV4XVtrZXldO1xuICAgICAgcmV0dXJuIHRpIDwgdmFsdWUgfHwgdGkgPT09IHZhbHVlICYmIHRhYmxlW2luZGV4ICsgMV1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5cbi8qKlxuICogUmV2ZXJzZSBiaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9ybG9va3VwQnlLZXkgPSAoXG4gIHRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogbnVtYmVyXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5cbi8qKlxuICogUmV0dXJuIHN1YnNldCBvZiBgdmFsdWVzYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBpbmNsdXNpdmUuXG4gKiBWYWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlcyAtIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBtaW4gLSBtaW4gdmFsdWVcbiAqIEBwYXJhbSBtYXggLSBtYXggdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlczogbnVtYmVyW10sIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcblxuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cblxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J10gYXMgY29uc3Q7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlMaXN0ZW5lcjxUPiB7XG4gIF9vbkRhdGFQdXNoPyguLi5pdGVtOiBUW10pOiB2b2lkO1xuICBfb25EYXRhUG9wPygpOiB2b2lkO1xuICBfb25EYXRhU2hpZnQ/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTcGxpY2U/KGluZGV4OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiB2b2lkO1xuICBfb25EYXRhVW5zaGlmdD8oLi4uaXRlbTogVFtdKTogdm9pZDtcbn1cblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnX29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBfb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzPFQ+KGFycmF5OiBUW10sIGxpc3RlbmVyOiBBcnJheUxpc3RlbmVyPFQ+KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG5cbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5VW5pcXVlPFQ+KGl0ZW1zOiBUW10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxUPihpdGVtcyk7XG5cbiAgaWYgKHNldC5zaXplID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydE1ldGEsIFBvaW50RWxlbWVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5pbXBvcnQge19saW1pdFZhbHVlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBzcGFuR2FwcyA9IG1ldGEuZGF0YXNldCA/IG1ldGEuZGF0YXNldC5vcHRpb25zID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgYXhpcywgbWluKS5sbyxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZExvID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoMCwgc3RhcnQgKyAxKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICBzdGFydCAtPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZExvKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGxldCBlbmQgPSBNYXRoLm1heChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoZW5kIC0gMSlcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICBlbmQgKz0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRIaSk7XG4gICAgICB9XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKGVuZCwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4PzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGlmICghY3R4ICYmICFjYW52YXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgY3R4LnNhdmUoKTtcbiAgLy8gY2FudmFzLndpZHRoIGFuZCBjYW52YXMuaGVpZ2h0IGRvIG5vdCBjb25zaWRlciB0aGUgY2FudmFzIHRyYW5zZm9ybSxcbiAgLy8gd2hpbGUgY2xlYXJSZWN0IGRvZXNcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcmF3UG9pbnRPcHRpb25zIHtcbiAgcG9pbnRTdHlsZTogUG9pbnRTdHlsZTtcbiAgcm90YXRpb24/OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBib3JkZXJXaWR0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXJcbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXJcbikge1xuICBsZXQgdHlwZTogc3RyaW5nLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBjb3JuZXJSYWRpdXM6IG51bWJlciwgd2lkdGg6IG51bWJlciwgeE9mZnNldFc6IG51bWJlciwgeU9mZnNldFc6IG51bWJlcjtcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgLy8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuICAgIC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG4gICAgLy8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuICAgIC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG4gICAgLy8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG4gICAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgY3R4LmFyYyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgICAgY3R4LmFyYyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdCc6XG4gICAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3JlY3RSb3QnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0YXInOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXNoJzpcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyksIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gYXJlYSAtIFRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBtYXJnaW4gLSBhbGxvd2VkIG1hcmdpblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKFxuICBwb2ludDogUG9pbnQsXG4gIGFyZWE6IFRSQkwsXG4gIG1hcmdpbj86IG51bWJlclxuKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7IC8vIG1hcmdpbiAtIGRlZmF1bHQgaXMgdG8gbWF0Y2ggcm91bmRlZCBkZWNpbWFsc1xuXG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IFRSQkwpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogUG9pbnQsXG4gIHRhcmdldDogUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuLFxuICBtb2RlPzogc3RyaW5nXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBTcGxpbmVQb2ludCxcbiAgdGFyZ2V0OiBTcGxpbmVQb2ludCxcbiAgZmxpcD86IGJvb2xlYW5cbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogUmVuZGVyVGV4dE9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGxpbmU6IHN0cmluZyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHNcbikge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgLyoqXG4gICAgICogTm93IHRoYXQgSUUxMSBzdXBwb3J0IGhhcyBiZWVuIGRyb3BwZWQsIHdlIGNhbiB1c2UgbW9yZVxuICAgICAqIG9mIHRoZSBUZXh0TWV0cmljcyBvYmplY3QuIFRoZSBhY3R1YWwgYm91bmRpbmcgYm94ZXNcbiAgICAgKiBhcmUgdW5mbGFnZ2VkIGluIENocm9tZSwgRmlyZWZveCwgRWRnZSwgYW5kIFNhZmFyaSBzbyB0aGV5XG4gICAgICogY2FuIGJlIHNhZmVseSB1c2VkLlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dE1ldHJpY3MjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZHJvcChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogQmFja2Ryb3BPcHRpb25zKSB7XG4gIGNvbnN0IG9sZENvbG9yID0gY3R4LmZpbGxTdHlsZTtcblxuICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvciBhcyBzdHJpbmc7XG4gIGN0eC5maWxsUmVjdChvcHRzLmxlZnQsIG9wdHMudG9wLCBvcHRzLndpZHRoLCBvcHRzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBvbGRDb2xvcjtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGV4dCBvbnRvIHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB0ZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGZvbnQ6IENhbnZhc0ZvbnRTcGVjLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0cyA9IHt9XG4pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpOiBudW1iZXIsIGxpbmU6IHN0cmluZztcblxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgaWYgKG9wdHMuYmFja2Ryb3ApIHtcbiAgICAgIGRyYXdCYWNrZHJvcChjdHgsIG9wdHMuYmFja2Ryb3ApO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuXG4gICAgeSArPSBOdW1iZXIoZm9udC5saW5lSGVpZ2h0KTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSByZWN0IC0gQm91bmRpbmcgcmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcmVjdDogUm91bmRlZFJlY3QgJiB7IHJhZGl1czogVFJCTENvcm5lcnMgfVxuKSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcblxuICAvLyB0b3AgbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIDEuNSAqIFBJLCBQSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSBsZWZ0XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG5cbiAgLy8gYm90dG9tIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gbGVmdCB0byBib3R0b20gcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuXG4gIC8vIGJvdHRvbSByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSByaWdodCB0byB0b3AgcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG5cbiAgLy8gdG9wIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIHJpZ2h0IHRvIHRvcCBsZWZ0XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnRTdHJpbmd9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgRm9udFNwZWMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7VFJCTCwgVFJCTENvcm5lcnN9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG5cbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gICAgY2FzZSAncHgnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgJyUnOlxuICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cblxuY29uc3QgbnVtYmVyT3JaZXJvID0gKHY6IHVua25vd24pID0+ICt2IHx8IDA7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SywgbnVtYmVyPiwgcHJvcHM6IEtbXSk6IFJlY29yZDxLLCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmcsIFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SyAmIFQsIG51bWJlcj4sIHByb3BzOiBSZWNvcmQ8VCwgSz4pOiBSZWNvcmQ8VCwgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgcHJvcHM6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkwodmFsdWU6IG51bWJlciB8IFRSQkwgfCBQb2ludCkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlOiBudW1iZXIgfCBUUkJMQ29ybmVycykge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZT86IG51bWJlciB8IFRSQkwpOiBDaGFydEFyZWEge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpIGFzIENoYXJ0QXJlYTtcblxuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnQob3B0aW9uczogUGFydGlhbDxGb250U3BlYz4sIGZhbGxiYWNrPzogUGFydGlhbDxGb250U3BlYz4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udCBhcyBGb250U3BlYztcblxuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcblxuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHM6IEFycmF5PHVua25vd24+LCBjb250ZXh0Pzogb2JqZWN0LCBpbmRleD86IG51bWJlciwgaW5mbz86IHsgY2FjaGVhYmxlOiBib29sZWFuIH0pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IHVua25vd247XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heDogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IH0sIGdyYWNlOiBudW1iZXIgfCBzdHJpbmcsIGJlZ2luQXRaZXJvOiBib29sZWFuKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZTogbnVtYmVyLCBhZGQ6IG51bWJlcikgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgaW5oZXJpdGluZyBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gcGFyZW50Q29udGV4dFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3Q+KHBhcmVudENvbnRleHQ6IG51bGwsIGNvbnRleHQ6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdCwgUCBleHRlbmRzIFQ+KHBhcmVudENvbnRleHQ6IFAsIGNvbnRleHQ6IFQpOiBQICYgVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQ6IG9iamVjdCwgY29udGV4dDogb2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0TWV0YX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlck9iamVjdEtleSxcbiAgUmVzb2x2ZXJDYWNoZSxcbiAgUmVzb2x2ZXJQcm94eSxcbiAgRGVzY3JpcHRvckRlZmF1bHRzLFxuICBEZXNjcmlwdG9yLFxuICBDb250ZXh0Q2FjaGUsXG4gIENvbnRleHRQcm94eVxufSBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIF9jYXBpdGFsaXplfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBmb3IgcmVzb2x2aW5nIHJhdyB2YWx1ZXMgZm9yIG9wdGlvbnMuXG4gKiBAcGFyYW0gc2NvcGVzIC0gVGhlIG9wdGlvbiBzY29wZXMgdG8gbG9vayBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyXG4gKiBAcGFyYW0gcHJlZml4ZXMgLSBUaGUgcHJlZml4ZXMgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSByb290U2NvcGVzIC0gVGhlIHJvb3Qgb3B0aW9uIHNjb3Blc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gUGFyZW50IHNjb3BlcyBmYWxsYmFja1xuICogQHBhcmFtIGdldFRhcmdldCAtIGNhbGxiYWNrIGZvciBnZXR0aW5nIHRoZSB0YXJnZXQgZm9yIGNoYW5nZWQgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm94eVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcjxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHNjb3BlczogVCxcbiAgcHJlZml4ZXMgPSBbJyddLFxuICByb290U2NvcGVzPzogUixcbiAgZmFsbGJhY2s/OiBSZXNvbHZlck9iamVjdEtleSxcbiAgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdXG4pIHtcbiAgY29uc3QgZmluYWxSb290U2NvcGVzID0gcm9vdFNjb3BlcyB8fCBzY29wZXM7XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZTogUmVzb2x2ZXJDYWNoZTxULCBSPiA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IGZpbmFsUm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCBmaW5hbFJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gdG9wIGxldmVsIHNjb3BlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gdG9wIGxldmVsIHNjb3BlICsgY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBSZXNvbHZlclByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gUHJveHkgZm9yIHJlc29sdmluZyBvcHRpb24gdmFsdWVzIHdpdGggY29udGV4dC5cbiAqIEBwYXJhbSBwcm94eSAtIFRoZSBQcm94eSByZXR1cm5lZCBieSBgX2NyZWF0ZVJlc29sdmVyYFxuICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9iamVjdCBmb3Igc2NyaXB0YWJsZS9pbmRleGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHN1YlByb3h5IC0gVGhlIHByb3h5IHByb3ZpZGVkIGZvciBzY3JpcHRhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBkZXNjcmlwdG9yRGVmYXVsdHMgLSBEZWZhdWx0cyBmb3IgZGVzY3JpcHRvcnNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXR0YWNoQ29udGV4dDxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHByb3h5OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBjb250ZXh0OiBBbnlPYmplY3QsXG4gIHN1YlByb3h5PzogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgZGVzY3JpcHRvckRlZmF1bHRzPzogRGVzY3JpcHRvckRlZmF1bHRzXG4pIHtcbiAgY29uc3QgY2FjaGU6IENvbnRleHRDYWNoZTxULCBSPiA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eDogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07IC8vIHJlbW92ZSBmcm9tIHByb3h5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHByb3h5XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBDb250ZXh0UHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhcbiAgcHJveHk6IFJlc29sdmVyQ2FjaGUsXG4gIGRlZmF1bHRzOiBEZXNjcmlwdG9yRGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfVxuKTogRGVzY3JpcHRvciB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuXG5jb25zdCByZWFkS2V5ID0gKHByZWZpeDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5cbmZ1bmN0aW9uIF9jYWNoZWQoXG4gIHRhcmdldDogQW55T2JqZWN0LFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlc29sdmU6ICgpID0+IHVua25vd25cbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgLy8gY2FjaGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQoXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBBbnlPYmplY3Rcbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdOyAvLyByZXNvbHZlIGZyb20gcHJveHlcblxuICAvLyByZXNvbHZlIHdpdGggY29udGV4dFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKFxuICBwcm9wOiBzdHJpbmcsXG4gIGdldFZhbHVlOiAoY3R4OiBBbnlPYmplY3QsIHN1YjogQW55T2JqZWN0KSA9PiB1bmtub3duLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gV2hlbiBzY3JpcHRhYmxlIG9wdGlvbiByZXR1cm5zIGFuIG9iamVjdCwgY3JlYXRlIGEgcmVzb2x2ZXIgb24gdGhhdC5cbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkoXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25bXSxcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIGlzSW5kZXhhYmxlOiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcblxuICBpZiAodHlwZW9mIF9jb250ZXh0LmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHJldHVybiB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgLy8gQXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJuIGFycmF5IG9yIHJlc29sdmVyc1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhcbiAgZmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5IHwgKChwcm9wOiBSZXNvbHZlck9iamVjdEtleSwgdmFsdWU6IHVua25vd24pID0+IFJlc29sdmVyT2JqZWN0S2V5KSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5cbmNvbnN0IGdldFNjb3BlID0gKGtleTogUmVzb2x2ZXJPYmplY3RLZXksIHBhcmVudDogQW55T2JqZWN0KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBhZGRTY29wZXMoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHBhcmVudEZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGRlc2NyaXB0b3IgdGhhdCBkZWZpbmVzIGEgbmV3IF9mYWxsYmFjaywgcmV0dXJuIHRoYXQuXG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayB3aWxsIHJlc3VtZSB0byB0aGF0IG5ldyBzY29wZS5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIHR5cGVvZiBwYXJlbnRGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYGZhbHNlYCByZXN1bHRzIHRvIGBmYWxzZWAsIHdoZW4gZmFsbGluZyBiYWNrIHRvIGRpZmZlcmVudCBrZXkuXG4gICAgICAvLyBGb3IgZXhhbXBsZSBgaW50ZXJhY3Rpb25gIGZyb20gYGhvdmVyYCBvciBgcGx1Z2lucy50b29sdGlwYCBhbmQgYGFuaW1hdGlvbmAgZnJvbSBgYW5pbWF0aW9uc2BcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKFxuICBwYXJlbnRTY29wZXM6IEFueU9iamVjdFtdLFxuICByZXNvbHZlcjogUmVzb2x2ZXJDYWNoZSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8QW55T2JqZWN0PigpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AgYXMgc3RyaW5nLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KFxuICBzZXQ6IFNldDxBbnlPYmplY3Q+LFxuICBhbGxTY29wZXM6IEFueU9iamVjdFtdLFxuICBrZXk6IFJlc29sdmVyT2JqZWN0S2V5LFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGl0ZW06IHVua25vd25cbikge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQoXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0IHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhcbiAgcHJvcDogc3RyaW5nLFxuICBwcmVmaXhlczogc3RyaW5nW10sXG4gIHNjb3BlczogQW55T2JqZWN0W10sXG4gIHByb3h5OiBSZXNvbHZlclByb3h5XG4pIHtcbiAgbGV0IHZhbHVlOiB1bmtub3duO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5OiBzdHJpbmcsIHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldDogUmVzb2x2ZXJDYWNoZSkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXM6IEFueU9iamVjdFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUoXG4gIG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LFxuICBkYXRhOiBBbnlPYmplY3RbXSxcbiAgc3RhcnQ6IG51bWJlcixcbiAgY291bnQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXk8e3I6IHVua25vd259Pihjb3VudCk7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgaXRlbTogQW55T2JqZWN0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiaW1wb3J0IHthbG1vc3RFcXVhbHMsIGRpc3RhbmNlQmV0d2VlblBvaW50cywgc2lnbn0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7U3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblxudHlwZSBPcHRpb25hbFNwbGluZVBvaW50ID0gU3BsaW5lUG9pbnQgfCBmYWxzZVxuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpOiBudW1iZXIpOiBPcHRpb25hbFNwbGluZVBvaW50ID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzOiAneCcgfCAneScpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmUoXG4gIGZpcnN0UG9pbnQ6IFNwbGluZVBvaW50LFxuICBtaWRkbGVQb2ludDogU3BsaW5lUG9pbnQsXG4gIGFmdGVyUG9pbnQ6IFNwbGluZVBvaW50LFxuICB0OiBudW1iZXJcbik6IHtcbiAgICBwcmV2aW91czogU3BsaW5lUG9pbnRcbiAgICBuZXh0OiBTcGxpbmVQb2ludFxuICB9IHtcbiAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gIC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuXG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG4gIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG4gIGNvbnN0IGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcblxuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBkZWx0YUs6IG51bWJlcltdLCBtSzogbnVtYmVyW10pIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgYWxwaGFLOiBudW1iZXIsIGJldGFLOiBudW1iZXIsIHRhdUs6IG51bWJlciwgc3F1YXJlZE1hZ25pdHVkZTogbnVtYmVyLCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHM6IFNwbGluZVBvaW50W10sIG1LOiBudW1iZXJbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YTogbnVtYmVyLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKTtcblxuICAvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcbiAgbGV0IGksIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cblxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuXG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuXG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQ6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cblxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50czogU3BsaW5lUG9pbnRbXSwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhcbiAgcG9pbnRzOiBTcGxpbmVQb2ludFtdLFxuICBvcHRpb25zLFxuICBhcmVhOiBDaGFydEFyZWEsXG4gIGxvb3A6IGJvb2xlYW4sXG4gIGluZGV4QXhpczogJ3gnIHwgJ3knXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBwb2ludDogU3BsaW5lUG9pbnQsIGNvbnRyb2xQb2ludHM6IFJldHVyblR5cGU8dHlwZW9mIHNwbGluZUN1cnZlPjtcblxuICAvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgUHJpdmF0ZUNoYXJ0IGZyb20gJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gdGhpcyBpcyB0aGUgYm9yZGVyIGJveCBvZiB0aGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5cbmNvbnN0IHJvdW5kMSA9ICh2OiBudW1iZXIpID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBiYldpZHRoPzogbnVtYmVyLFxuICBiYkhlaWdodD86IG51bWJlcixcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbik6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG5cbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgLy8gSWYgdGhlIGNhbnZhcyBoYXMgd2lkdGgsIGJ1dCBubyBoZWlnaHQsIGRlZmF1bHQgdG8gYXNwZWN0UmF0aW8gb2YgMiAoY2FudmFzIGRlZmF1bHQpXG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cblxuICBjb25zdCBtYWludGFpbkhlaWdodCA9IGJiV2lkdGggIT09IHVuZGVmaW5lZCB8fCBiYkhlaWdodCAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChtYWludGFpbkhlaWdodCAmJiBhc3BlY3RSYXRpbyAmJiBjb250YWluZXJTaXplLmhlaWdodCAmJiBoZWlnaHQgPiBjb250YWluZXJTaXplLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgfVxuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbi8qKlxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcGFyYW0gZm9yY2VSYXRpb1xuICogQHBhcmFtIGZvcmNlU3R5bGVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNhbnZhcyBjb250ZXh0IHNpemUgb3IgdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRpbmFTY2FsZShcbiAgY2hhcnQ6IENoYXJ0IHwgUHJpdmF0ZUNoYXJ0LFxuICBmb3JjZVJhdGlvOiBudW1iZXIsXG4gIGZvcmNlU3R5bGU/OiBib29sZWFuXG4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuXG4gIChjaGFydCBhcyBQcml2YXRlQ2hhcnQpLmhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0KTtcbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkud2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoKTtcblxuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cbiAgLy8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcbiAgLy8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuXG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnM7XG5cbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMgU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gIHByb3BlcnR5OiAnd2lkdGgnIHwgJ2hlaWdodCdcbik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50LCBTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxOiBQb2ludCwgcDI6IFBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24oXG4gIHAxOiBQb2ludCxcbiAgcDI6IFBvaW50LFxuICB0OiBudW1iZXIsIG1vZGU6ICdtaWRkbGUnIHwgJ2FmdGVyJyB8IHVua25vd25cbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgICAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDE6IFNwbGluZVBvaW50LCBwMjogU3BsaW5lUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgUlRMQWRhcHRlciB7XG4gIHgoeDogbnVtYmVyKTogbnVtYmVyO1xuICBzZXRXaWR0aCh3OiBudW1iZXIpOiB2b2lkO1xuICB0ZXh0QWxpZ24oYWxpZ246ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0Jyk6ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgeFBsdXMoeDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICBsZWZ0Rm9yTHRyKHg6IG51bWJlciwgaXRlbVdpZHRoOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bDogYm9vbGVhbiwgcmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnKSB7XG4gIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgb3JpZ2luYWw6IFtzdHJpbmcsIHN0cmluZ107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG5cbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3JpZ2luYWw/OiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgX2FuZ2xlRGlmZiwgX2lzQmV0d2VlbiwgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gJy4vaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7aXNQYXR0ZXJuT3JHcmFkaWVudH0gZnJvbSAnLi9oZWxwZXJzLmNvbG9yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqIEB0eXBlZGVmIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGxvb3A6IGJvb2xlYW4sIHN0eWxlPzogYW55fX0gU2VnbWVudFxuICovXG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3ViLXNlZ21lbnQocykgb2YgYSBsaW5lIHNlZ21lbnQgdGhhdCBmYWxsIGluIHRoZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudC5zdHlsZV0gLSBzZWdtZW50IHN0eWxlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzIHRoYXQgdGhpcyBzZWdtZW50IHJlZmVycyB0b1xuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IG9mIGEgYFBvaW50RWxlbWVudGAgd2UgYXJlIGJvdW5kaW5nLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG5cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcblxuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG5cbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuXG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG5cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2VnbWVudHMgb2YgdGhlIGxpbmUgdGhhdCBhcmUgaW5zaWRlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHdlIGFyZSBib3VuZGluZyB3aXRoLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGaW5kIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgYSBsaW5lLlxuICovXG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcblxuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICAvLyBsb29wIGFuZCBub3Qgc3Bhbm5pbmcgZ2FwcywgZmlyc3QgZmluZCBhIGdhcCB0byBzdGFydCBmcm9tXG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGZpcnN0IG5vbiBza2lwcGVkIHBvaW50IChhZnRlciB0aGUgZmlyc3QgZ2FwIHBvc3NpYmx5KVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgLy8gaWYgd2UgbG9vcGVkIHRvIGNvdW50LCBzdGFydCBuZWVkcyB0byBiZSAwXG4gIHN0YXJ0ICU9IGNvdW50O1xuXG4gIGlmIChsb29wKSB7XG4gICAgLy8gbG9vcCB3aWxsIGdvIHBhc3QgY291bnQsIGlmIHN0YXJ0ID4gMFxuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuXG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIC8vIGVuZCBjb3VsZCBiZSBtb3JlIHRoYW4gY291bnQsIG5vcm1hbGl6ZVxuICBlbmQgJT0gY291bnQ7XG5cbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHNvbGlkIHNlZ21lbnRzIGZyb20gUG9pbnRzLCB3aGVuIHNwYW5HYXBzID09PSBmYWxzZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBtYXggaW5kZXggKGNhbiBnbyBwYXN0IGNvdW50IG9uIGEgbG9vcClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCAtIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoaXMgd291bGQgYmUgYSBsb29wIGlmIG5vIGdhcHMgYXJlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcblxuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNvbnRpbnVvdXMgc2VnbWVudHMgdGhhdCBkZWZpbmUgdGhlIHdob2xlIGxpbmVcbiAqIFRoZXJlIGNhbiBiZSBza2lwcGVkIHBvaW50cyB3aXRoaW4gYSBzZWdtZW50LCBpZiBzcGFuR2FwcyBpcyB0cnVlLlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuXG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3R5bGUgY2FuIG5vdCBzdGFydC9lbmQgb24gYSBza2lwcGVkIHBvaW50LCBhZGp1c3QgaW5kaWNlcyBhY2NvcmRpbmdseVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICBpZiAoIXByZXZTdHlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghY2FjaGUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmluZGV4T2YodmFsdWUpO1xuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGUsIHJlcGxhY2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlLCByZXBsYWNlcik7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydEFyZWEsIENoYXJ0TWV0YSwgU2NhbGUsIFRSQkx9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gZ2V0U2l6ZUZvckFyZWEoc2NhbGU6IFNjYWxlLCBjaGFydEFyZWE6IENoYXJ0QXJlYSwgZmllbGQ6IGtleW9mIENoYXJ0QXJlYSkge1xuICByZXR1cm4gc2NhbGUub3B0aW9ucy5jbGlwID8gc2NhbGVbZmllbGRdIDogY2hhcnRBcmVhW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YXNldEFyZWEobWV0YTogQ2hhcnRNZXRhLCBjaGFydEFyZWE6IENoYXJ0QXJlYSk6IFRSQkwge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgaWYgKHhTY2FsZSAmJiB5U2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdsZWZ0JyksXG4gICAgICByaWdodDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdyaWdodCcpLFxuICAgICAgdG9wOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ3RvcCcpLFxuICAgICAgYm90dG9tOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ2JvdHRvbScpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2hhcnRBcmVhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YXNldENsaXBBcmVhKGNoYXJ0OiBDaGFydCwgbWV0YTogQ2hhcnRNZXRhKTogVFJCTCB8IGZhbHNlIHtcbiAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gIGlmIChjbGlwLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFyZWEgPSBnZXREYXRhc2V0QXJlYShtZXRhLCBjaGFydC5jaGFydEFyZWEpO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSAoY2xpcC5sZWZ0ID09PSB0cnVlID8gMCA6IGNsaXAubGVmdCksXG4gICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gY2hhcnQud2lkdGggOiBhcmVhLnJpZ2h0ICsgKGNsaXAucmlnaHQgPT09IHRydWUgPyAwIDogY2xpcC5yaWdodCksXG4gICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSAoY2xpcC50b3AgPT09IHRydWUgPyAwIDogY2xpcC50b3ApLFxuICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gY2hhcnQuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyAoY2xpcC5ib3R0b20gPT09IHRydWUgPyAwIDogY2xpcC5ib3R0b20pXG4gIH07XG59XG4iLCAiaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmFuaW1hdGlvbi5qcycpLmRlZmF1bHQgfSBBbmltYXRpb25cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuXG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuXG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhbmQgaXRzIGR1cmF0aW9uIHByb2xvbmdlZCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0b3RhbCBkdXJhdGlvbiBvZiBjdXJyZW50IGFuaW1hdGlvbnMgcnVuIChmb3IgcHJvZ3Jlc3MgZXZlbnQpXG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGJ5IHJlcGxhY2luZyBpdCB3aXRoIGxhc3QgaXRlbSBhbmQgcmVtb3ZpbmcgdGhlIGxhc3RcbiAgICAgICAgICAvLyBBIGxvdCBmYXN0ZXIgdGhhbiBzcGxpY2UuXG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG5cbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuXHQgKi9cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbltdfSBpdGVtcyAtIGFuaW1hdGlvbnNcblx0ICovXG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvdW50cyBudW1iZXIgb2YgYWN0aXZlIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXJ0IGFuaW1hdGluZyAoYWxsIGNoYXJ0cylcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuXG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICogU3RvcCBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBjaGFydCBmcm9tIEFuaW1hdG9yXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IEFuaW1hdG9yKCk7XG4iLCAiaW1wb3J0IGVmZmVjdHMgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmVhc2luZy5qcyc7XG5pbXBvcnQge3Jlc29sdmV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7Y29sb3IgYXMgaGVscGVyc0NvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3JcbiAgICovXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGhlbHBlcnNDb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGhlbHBlcnNDb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcblxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgZXZhbHVhdGVkIHZhbHVlLCBmb3Igc21vb3RoZXIgYW5pbWF0aW9uc1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG5cbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG5cbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuXG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29yZS5hbmltYXRpb24uanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGhhbmRsZSBhbmltYXRpb24gb2YgYG9wdGlvbnNgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIC8vIEdvaW5nIHRvIHNoYXJlZCBvcHRpb25zOlxuICAgICAgLy8gQWZ0ZXIgYWxsIGFuaW1hdGlvbnMgYXJlIGRvbmUsIGFzc2lnbiB0aGUgc2hhcmVkIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBlbGVtZW50XG4gICAgICAvLyBTbyBhbnkgbmV3IHVwZGF0ZXMgdG8gdGhlIHNoYXJlZCBvcHRpb25zIGFyZSBvYnNlcnZlZFxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHJlamVjdGVkLCBub29wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBleGlzdGluZyBhY3RpdmUgYW5pbWF0aW9uLCBsZXQncyB1cGRhdGUgdGhhdFxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIG5vdCBhbmltYXRlZCwgc2V0IGRpcmVjdGx5IHRvIG5ldyB2YWx1ZVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgYHRhcmdldGAgcHJvcGVydGllcyB0byBuZXcgdmFsdWVzLCB1c2luZyBjb25maWd1cmVkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCB0byB1cGRhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG5ldyB0YXJnZXQgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IC0gYHRydWVgIGlmIGFuaW1hdGlvbnMgd2VyZSBzdGFydGVkXG5cdCAqKi9cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBhbmltYXRlZCwganVzdCBhcHBseSB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcblxuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAvLyBHb2luZyBmcm9tIHNoYXJlZCBvcHRpb25zIHRvIGRpc3RpbmN0IG9uZTpcbiAgICAvLyBDcmVhdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBzaGFyZWQgdmFsdWVzIGFuZCBzdGFydCB1cGRhdGluZyB0aGF0LlxuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCAiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRmluaXRlLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIGRlZmluZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7bGlzdGVuQXJyYXlFdmVudHMsIHVubGlzdGVuQXJyYXlFdmVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgc2lnbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKi9cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmFsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSwgbWV0YSkge1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8gJ3gnIDogJ3knO1xuICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgW2lBeGlzS2V5XToga2V5LFxuICAgICAgW3ZBeGlzS2V5XTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7IC8vIG1hcCBzdHJ1Y3R1cmUgaXMge3N0YWNrS2V5OiB7ZGF0YXNldEluZGV4OiB2YWx1ZX19XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG5cbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuXG4gICAgY29uc3QgdmlzdWFsVmFsdWVzID0gc3RhY2suX3Zpc3VhbFZhbHVlcyB8fCAoc3RhY2suX3Zpc3VhbFZhbHVlcyA9IHt9KTtcbiAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAvLyBOb3QgdXNpbmcgbWV0YS5pbmRleCBoZXJlLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGFscmVhZHkgdXBkYXRlZCBpZiB0aGUgZGF0YXNldCBjaGFuZ2VkIGxvY2F0aW9uXG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmVFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50RWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRhdGFzZXRJbmRleFxuXHQgKi9cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCBvYmplY3R9ICovXG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFzZXRFbGVtZW50VHlwZTtcbiAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWxsICYmICF0aGlzLmNoYXJ0LmlzUGx1Z2luRW5hYmxlZCgnZmlsbGVyJykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHVzZSB0aGUgJ2ZpbGwnIG9wdGlvbiB3aXRob3V0IHRoZSAnRmlsbGVyJyBwbHVnaW4gZW5hYmxlZC4gUGxlYXNlIGltcG9ydCBhbmQgcmVnaXN0ZXIgdGhlICdGaWxsZXInIHBsdWdpbiBhbmQgbWFrZSBzdXJlIGl0IGlzIG5vdCBkaXNhYmxlZCBpbiB0aGUgb3B0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblxuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcblxuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cblxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cblxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZUlEXG5cdCAqIEByZXR1cm4ge1NjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW5kIHRodXMgc2ltdWxhdGVcbiAgICAvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcbiAgICAvLyB0aGUgaW50ZXJuYWwgbWV0YWRhdGEgYWNjb3JkaW5nbHkuXG5cbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIERpc2NhcmQgb2xkIHBhcnNlZCBkYXRhIGFuZCBzdGFja3NcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgY2FjaGVkIF9zdGFja2VkIHN0YXR1cyBpcyBjdXJyZW50XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG5cbiAgICAvLyBkZXRlY3QgY2hhbmdlIGluIHN0YWNrIG9wdGlvblxuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHZhbHVlcyBmcm9tIG9sZCBzdGFja1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG5cbiAgICAvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuICAgIC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG5cbiAgICAvLyBpZiBzdGFjayBjaGFuZ2VkLCB1cGRhdGUgc3RhY2sgdmFsdWVzIGZvciB0aGUgd2hvbGUgZGF0YXNldFxuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRQYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgY29uc3QgaVNjYWxlVmFsdWUgPSBjdXJyZW50UGFyc2VkICYmIGN1cnJlbnRQYXJzZWRbaVNjYWxlLmF4aXNdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5fcGFyc2VkLmZpbmQoaXRlbSA9PiBpdGVtW2lTY2FsZS5heGlzXSA9PT0gaVNjYWxlVmFsdWUpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwgJiYgIXJlY3RzW2ldLmhpZGRlbikge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYnViYmxlJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcblxuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcblxuICAgIC8vIEluIGNhc2UgdmFsdWVzIHdlcmUgY2FjaGVkIChhbmQgdGh1cyBmcm96ZW4pLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB2YWx1ZXNcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIHRvUGVyY2VudGFnZSwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBUQVUsIEhBTEZfUEksIF9hbmdsZUJldHdlZW59IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIC8vIElmIHRoZSBjaGFydCdzIGNpcmN1bWZlcmVuY2UgaXNuJ3QgYSBmdWxsIGNpcmNsZSwgY2FsY3VsYXRlIHNpemUgYXMgYSByYXRpbyBvZiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhcmNcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnZG91Z2hudXQnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBEb3VnaG51dFxuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG4gICAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6ICc1MCUnLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnLFxuXG4gICAgLy8gU3BhY2luZyBiZXR3ZWVuIGFyY3NcbiAgICBzcGFjaW5nOiAwLFxuXG4gICAgaW5kZXhBeGlzOiAncicsXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYm9yZGVyRGFzaCcpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2hvdmVyQm9yZGVyRGFzaCcpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHt9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRlIGRhdGEgcGFyc2luZywgc2luY2Ugd2UgYXJlIG5vdCB1c2luZyBzY2FsZXNcblx0ICovXG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuXG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgZXh0ZW50c1xuXHQgKiBhY3Jvc3MgYWxsIHZpc2libGUgZGF0YXNldHMuXG5cdCAqL1xuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuXG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBsaW1pdHMuXG4gICAgLy8gSWYgd2Ugb25seSBjb25zaWRlciBvdXIgZGF0YXNldCwgdGhpcyBjYW4gY2F1c2UgcHJvYmxlbXMgd2hlbiB0d28gZGF0YXNldHNcbiAgICAvLyBhcmUgYm90aCBsZXNzIHRoYW4gYSBjaXJjbGUgd2l0aCBkaWZmZXJlbnQgcm90YXRpb25zIChzdGFydGluZyBhbmdsZXMpXG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuXG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcblxuICAgIGlmICghYXJjcykge1xuICAgICAgLy8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgcmFkaXVzIGxlbmd0aCBvZmZzZXQgb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMgd2VpZ2h0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJsZSBkYXRhIHNldCB3ZWlnaHRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBjb25zdCBwb2ludHNDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcblxuICAgICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBmb3JtYXROdW1iZXIsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BvbGFyQXJlYSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cbiIsICJpbXBvcnQgRG91Z2hudXRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci5kb3VnaG51dC5qcyc7XG5cbi8vIFBpZSBjaGFydHMgYXJlIERvdWdobnV0IGNoYXJ0IHdpdGggZGlmZmVyZW50IGRlZmF1bHRzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncGllJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAwLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnXG4gIH07XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge19wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncmFkYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBlbGVtZW50czoge1xuICAgICAgbGluZToge1xuICAgICAgICBmaWxsOiAnc3RhcnQnXG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgLy8gSW4gcmVzaXplIG1vZGUgb25seSBwb2ludCBsb2NhdGlvbnMgY2hhbmdlLCBzbyBubyBuZWVkIHRvIHNldCB0aGUgcG9pbnRzIG9yIG9wdGlvbnMuXG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG5cbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdzY2F0dGVyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBzaG93TGluZTogZmFsc2UsXG4gICAgZmlsbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG5cbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgbW9kZTogJ3BvaW50J1xuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuXG4gICAgICAvLyBVcGRhdGUgTGluZVxuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVyc1xuICogQHNpbmNlIDIuOC4wXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE9wdGlvbnN9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHR5cGUgVGltZVVuaXQgPSAnbWlsbGlzZWNvbmQnIHwgJ3NlY29uZCcgfCAnbWludXRlJyB8ICdob3VyJyB8ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICdxdWFydGVyJyB8ICd5ZWFyJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQWRhcHRlcjxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PiB7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFQ7XG4gIC8qKlxuICAgKiBXaWxsIGNhbGxlZCB3aXRoIGNoYXJ0IG9wdGlvbnMgYWZ0ZXIgYWRhcHRlciBjcmVhdGlvbi5cbiAgICovXG4gIGluaXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGNoYXJ0T3B0aW9uczogQ2hhcnRPcHRpb25zKTogdm9pZDtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuICAgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuICAgKi9cbiAgZm9ybWF0cyh0aGlzOiBEYXRlQWRhcHRlcjxUPik6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz47XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuICAgKiBAcGFyYW0gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcbiAgICovXG4gIHBhcnNlKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB2YWx1ZTogdW5rbm93biwgZm9ybWF0Pzogc3RyaW5nKTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBhZGQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG4gICAqIEBwYXJhbSBhIC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuICAgKiBAcGFyYW0gYiAtIHRoZSB0aW1lc3RhbXAgdG8gc3VidHJhY3RcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGRpZmYodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqIEBwYXJhbSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG4gICAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG4gICAqL1xuICBzdGFydE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycsIHdlZWtkYXk/OiBudW1iZXIgfCBib29sZWFuKTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBlbmRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBhYnN0cmFjdDxUID0gdm9pZD4oKTogVCB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuXG4vKipcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERhdGVBZGFwdGVyQmFzZSBpbXBsZW1lbnRzIERhdGVBZGFwdGVyIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCBkYXRlIGFkYXB0ZXIgbWV0aG9kcy5cbiAgICogQWNjZXB0cyB0eXBlIHBhcmFtZXRlciB0byBkZWZpbmUgb3B0aW9ucyB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBDaGFydC5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGU8e215QWRhcHRlck9wdGlvbjogc3RyaW5nfT4oe1xuICAgKiAgIGluaXQoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbnMubXlBZGFwdGVyT3B0aW9uKTtcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICApIHtcbiAgICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyQmFzZS5wcm90b3R5cGUsIG1lbWJlcnMpO1xuICB9XG5cbiAgcmVhZG9ubHkgb3B0aW9uczogQW55T2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2UgYXMge1xuICAgIG5ldyAob3B0aW9ucz86IEFueU9iamVjdCk6IERhdGVBZGFwdGVyO1xuICAgIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICAgICk6IHZvaWQ7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbG9va3VwQnlLZXksIF9ybG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0UmVsYXRpdmVQb3NpdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7e2F4aXM/OiBzdHJpbmcsIGludGVyc2VjdD86IGJvb2xlYW4sIGluY2x1ZGVJbnZpc2libGU/OiBib29sZWFufX0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7e2RhdGFzZXRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBlbGVtZW50OiBpbXBvcnQoJy4vY29yZS5lbGVtZW50LmpzJykuZGVmYXVsdH19IEludGVyYWN0aW9uSXRlbVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIGJpbmFyeSBzZWFyY2ggd2hlbiBwb3NzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFzZXQgLSB0aGUgZGF0YXNldCBtZXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIHNob3VsZCB0aGUgZWxlbWVudCBpbnRlcnNlY3RcbiAqIEByZXR1cm5zIHt7bG86bnVtYmVyLCBoaTpudW1iZXJ9fSBpbmRpY2VzIHRvIHNlYXJjaCBkYXRhIGFycmF5IGJldHdlZW5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGNvbnN0IHNwYW5HYXBzID0gbWV0YXNldC5kYXRhc2V0ID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhc2V0LmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuXG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IHt2U2NhbGV9ID0gY29udHJvbGxlci5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3Qge19wYXJzZWR9ID0gbWV0YXNldDtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZExvID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoMCwgcmVzdWx0LmxvICsgMSlcbiAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgcmVzdWx0LmxvIC09IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkTG8pO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkSGkgPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZShyZXN1bHQuaGkpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgcmVzdWx0LmhpICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIC8vIF9zaGFyZWRPcHRpb25zIGluZGljYXRlcyB0aGF0IGVhY2ggZWxlbWVudCBoYXMgZXF1YWwgb3B0aW9ucyAtPiBlcXVhbCBwcm9wb3J0aW9uc1xuICAgICAgLy8gU28gd2UgY2FuIGRvIGEgcmFuZ2VkIGJpbmFyeSBzZWFyY2ggYmFzZWQgb24gdGhlIHJhbmdlIG9mIGZpcnN0IGVsZW1lbnQgYW5kXG4gICAgICAvLyBiZSBjb25maWRlbnQgdG8gZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIGluZGljZXMgdGhhdCBjYW4gaW50ZXJzZWN0IHdpdGggdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHRvIGFsbCBlbGVtZW50cywgd2hlbiBiaW5hcnkgc2VhcmNoIGNhbiBub3QgYmUgdXNlZC5cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbGVjdCBjYW5kaWRhdGUgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBjb25zaWRlciBpbnRlcnNlY3RpbmcgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgcmFkaWFsIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG5cbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgY2FydGVzaWFuIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbWF0Y2hpbmcgYWxvbmcgdGhlIGdpdmVuIFggb3IgWSBheGlzXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0gJiYgZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG4gIC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gUGFydCBvZiB0aGUgcHVibGljIEFQSSB0byBmYWNpbGl0YXRlIGRldmVsb3BlcnMgY3JlYXRpbmcgdGhlaXIgb3duIG1vZGVzXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuICBtb2Rlczoge1xuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwgIi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHdpdGhvdXQgYWNjZXNzIHRvIHRoZSBET00gb3IgdG8gbWFueSBlbGVtZW50IHByb3BlcnRpZXNcbiAqIFRoaXMgcGxhdGZvcm0gaXMgdXNlZCBieSBkZWZhdWx0IGZvciBhbnkgY2hhcnQgcGFzc2VkIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQgQmFzaWNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2ljLmpzJztcbmltcG9ydCBEb21QbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmRvbS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmV4cG9ydCB7QmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBEb21QbGF0Zm9ybX07XG4iLCAiaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHR5cGUge0FuaW1hdGlvbn0gZnJvbSAnLi4vdHlwZXMvYW5pbWF0aW9uLmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudDxUID0gQW55T2JqZWN0LCBPID0gQW55T2JqZWN0PiB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBhY3RpdmUgPSBmYWxzZTtcbiAgb3B0aW9uczogTztcbiAgJGFuaW1hdGlvbnM6IFJlY29yZDxrZXlvZiBULCBBbmltYXRpb24+O1xuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKTogUG9pbnQge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fSBhcyBQb2ludDtcbiAgfVxuXG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBvciBmaW5hbCB2YWx1ZSBvZiBlYWNoIHByb3AuIENhbiByZXR1cm4gZXh0cmEgcHJvcGVydGllcyAod2hvbGUgb2JqZWN0KS5cbiAgICogQHBhcmFtIHByb3BzIC0gcHJvcGVydGllcyB0byBnZXRcbiAgICogQHBhcmFtIFtmaW5hbF0gLSBnZXQgdGhlIGZpbmFsIHZhbHVlIChhbmltYXRpb24gdGFyZ2V0KVxuICAgKi9cbiAgZ2V0UHJvcHM8UCBleHRlbmRzIChrZXlvZiBUKVtdPihwcm9wczogUCwgZmluYWw/OiBib29sZWFuKTogUGljazxULCBQW251bWJlcl0+O1xuICBnZXRQcm9wczxQIGV4dGVuZHMgc3RyaW5nPihwcm9wczogUFtdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxQLCB1bmtub3duPj47XG4gIGdldFByb3BzKHByb3BzOiBzdHJpbmdbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgLy8gbGV0J3Mgbm90IGNyZWF0ZSBhbiBvYmplY3QsIGlmIG5vdCBuZWVkZWRcbiAgICAgIHJldHVybiB0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3AgYXMgc3RyaW5nXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfZmFjdG9yaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdH0gc2NhbGVcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHJldHVybiB7VGlja1tdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgdGlja3NMaW1pdCA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lZE1heFRpY2tzLCBkZXRlcm1pbmVkTWF4VGlja3MpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcblxuICAvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuXG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrc0xpbWl0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG5cbiAgLy8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcbiAgLy8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cblxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKi9cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yU3RhcnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yRW5kXVxuICovXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG5cbiAgbmV4dCA9IHN0YXJ0O1xuXG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG5cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcblxuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FsaWduUGl4ZWwsIF9tZWFzdXJlVGV4dCwgcmVuZGVyVGV4dCwgY2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBlYWNoLCBmaW5pdGVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9pbnQxNlJhbmdlLCBfbGltaXRWYWx1ZSwgSEFMRl9QSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIF9hZGRHcmFjZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHthdXRvU2tpcH0gZnJvbSAnLi9jb3JlLnNjYWxlLmF1dG9za2lwLmpzJztcblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuY29uc3QgZ2V0VGlja3NMaW1pdCA9ICh0aWNrc0xlbmd0aCwgbWF4VGlja3NMaW1pdCkgPT4gTWF0aC5taW4obWF4VGlja3NMaW1pdCB8fCB0aWNrc0xlbmd0aCwgdGlja3NMZW5ndGgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyBudW1JdGVtcyBmcm9tIGFyclxuICogQHBhcmFtIHthbnlbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtSXRlbXNcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9mZnNldEdyaWRMaW5lc1xuICovXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcblxuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcblxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcblxuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICAvKiogQHR5cGUge0NhbnZhc1RleHRBbGlnbn0gKi9cbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcblxuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqL1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICAvKiogQHR5cGUge0NoYXJ0fSAqL1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG5cbiAgICAvLyBpbXBsZW1lbnRzIGJveFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzY2FsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcj19ICovXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7VGlja1tdfSAqL1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0fG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHthbnl9IG9wdGlvbnNcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcblxuICAgIC8vIHBhcnNlIG1pbi9tYXggdmFsdWUsIHNvIHdlIGNhbiBwcm9wZXJseSBkZXRlcm1pbmUgbWluL21heCBmb3Igb3RoZXIgc2NhbGVzXG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhIHN1cHBvcnRlZCBpbnB1dCB2YWx1ZSB0byBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHJhdztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW5EZWZpbmVkOiBib29sZWFuLCBtYXhEZWZpbmVkOiBib29sZWFufX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblN0YWNrXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCAiaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tpZDogc3RyaW5nLCBkZWZhdWx0czogYW55LCBvdmVycmlkZXM/OiBhbnksIGRlZmF1bHRSb3V0ZXM6IGFueX19IElDaGFydENvbXBvbmVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjb3BlIHdoZXJlIGl0ZW1zIGRlZmF1bHRzIHdlcmUgcmVnaXN0ZXJlZCB0by5cblx0ICovXG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG5cbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmVudCBpcyByZWdpc3RlcmVkIGFuZCBub3RlIHRoZSBzY29wZSB3aGVyZSBpdHMgZGVmYXVsdHMgYXJlLlxuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdD99XG5cdCAqL1xuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICovXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cblxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRlZmF1bHRzIGFuZCBrZWVwIGV4aXN0aW5nIGRlZmF1bHRzXG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG5cbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuXG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG5cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwgImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXMsIGRlc2NyaXB0b3JzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHttZXJnZUlmLCByZXNvbHZlT2JqZWN0S2V5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCB2YWx1ZU9yRGVmYXVsdCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2F0dGFjaENvbnRleHQsIF9jcmVhdGVSZXNvbHZlciwgX2Rlc2NyaXB0b3JzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuXG5mdW5jdGlvbiBpZE1hdGNoZXNBeGlzKGlkKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScgfHwgaWQgPT09ICdyJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICBpZiAoaWRNYXRjaGVzQXhpcyhpZCkpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZm9yIChjb25zdCBvcHRzIG9mIHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGF4aXMgPSBvcHRzLmF4aXNcbiAgICAgIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbilcbiAgICAgIHx8IGlkLmxlbmd0aCA+IDEgJiYgaWRNYXRjaGVzQXhpcyhpZFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICcke2lkfScgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLmApO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSA9PT0gaWQpIHtcbiAgICByZXR1cm4ge2F4aXN9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YS5kYXRhc2V0cykge1xuICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpID0+IGQueEF4aXNJRCA9PT0gaWQgfHwgZC55QXhpc0lEID09PSBpZCk7XG4gICAgaWYgKGJvdW5kRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneCcsIGJvdW5kRHNbMF0pIHx8IGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3knLCBib3VuZERzWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gRmlyc3QgZmlndXJlIG91dCBmaXJzdCBzY2FsZSBpZCdzIHBlciBheGlzLlxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG5cbiAgLy8gVGhlbiBtZXJnZSBkYXRhc2V0IGRlZmF1bHRzIHRvIHNjYWxlIGNvbmZpZ3NcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhcHBseSBzY2FsZSBkZWZhdWx0cywgaWYgbm90IG92ZXJyaWRkZW4gYnkgZGF0YXNldCBkZWZhdWx0c1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuXG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuXG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cblxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBhbmltYXRpb24gb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdXNlZCBmb3IgbG9va2luZyB1cCB0aGUgYGFuaW1hdGlvbnNgIGFuZCBgYW5pbWF0aW9uYCBrZXlzXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGVsZW1lbnQgb3B0aW9ucyB0aGF0IGJlbG9uZ1xuICAgKiB0byBhbiBkYXRhc2V0LiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdFxuICAgKiBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgcGx1Z2luIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7e2lkOiBzdHJpbmcsIGFkZGl0aW9uYWxPcHRpb25TY29wZXM/OiBzdHJpbmdbXX19IHBsdWdpblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb2JqZWN0cyBmcm9tIG9wdGlvbnMgYW5kIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsdWUgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW5TY29wZSAtIFRoZSBtYWluIHNjb3BlIG9iamVjdCBmb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGtleUxpc3RzIC0gVGhlIGFycmF5cyBvZiBrZXlzIGluIHJlc29sdXRpb24gb3JkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRDYWNoZV0gLSByZXNldCB0aGUgY2FjaGUgZm9yIHRoaXMgbWFpblNjb3BlXG4gICAqL1xuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuXG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGVzIGZvciByZXNvbHZpbmcgY2hhcnQgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAgICovXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LCAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODUzMVxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgLy8gc3ViUmVzb2x2ZXIgaXMgcGFzc2VkIHRvIHNjcmlwdGFibGUgb3B0aW9ucy4gSXQgc2hvdWxkIG5vdCByZXNvbHZlIHRvIGhvdmVyIG9wdGlvbnMuXG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcGFyYW0ge3tzY3JpcHRhYmxlOiBib29sZWFuLCBpbmRleGFibGU6IGJvb2xlYW4sIGFsbEtleXM/OiBib29sZWFufX0gW2Rlc2NyaXB0b3JEZWZhdWx0c11cbiAgICovXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnNvbWUoKGtleSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtrZXldKSk7XG5cbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCB1aWQsIHZhbHVlT3JEZWZhdWx0LCBfZWxlbWVudHNFcXVhbCwgaXNOdWxsT3JVbmRlZiwgc2V0c0VxdWFsLCBkZWZpbmVkLCBpc0Z1bmN0aW9uLCBfaXNDbGlja0V2ZW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NsZWFyQ2FudmFzLCBjbGlwQXJlYSwgY3JlYXRlQ29udGV4dCwgdW5jbGlwQXJlYSwgX2lzUG9pbnRJbkFyZWEsIF9pc0RvbVN1cHBvcnRlZCwgcmV0aW5hU2NhbGUsIGdldERhdGFzZXRDbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcblxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbi8qKlxuICogQ2hhcnQuanMgY2FuIHRha2UgYSBzdHJpbmcgaWQgb2YgYSBjYW52YXMgZWxlbWVudCwgYSAyZCBjb250ZXh0LCBvciBhIGNhbnZhcyBlbGVtZW50IGl0c2VsZi5cbiAqIEF0dGVtcHQgdG8gdW53cmFwIHRoZSBpdGVtIHBhc3NlZCBpbnRvIHRoZSBjaGFydCBjb25zdHJ1Y3RvciBzbyB0aGF0IGl0IGlzIGEgY2FudmFzIGVsZW1lbnQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5cbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fG51bGx9IGxhc3RFdmVudFxuICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYVxuICogQHBhcmFtIHtib29sZWFufSBpc0NsaWNrXG4gKiBAcmV0dXJucyB7Q2hhcnRFdmVudHxudWxsfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuY2xhc3MgQ2hhcnQge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBzdGF0aWMgaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICBzdGF0aWMgb3ZlcnJpZGVzID0gb3ZlcnJpZGVzO1xuICBzdGF0aWMgcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgc3RhdGljIHZlcnNpb24gPSB2ZXJzaW9uO1xuICBzdGF0aWMgZ2V0Q2hhcnQgPSBnZXRDaGFydDtcblxuICBzdGF0aWMgcmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICBzdGF0aWMgdW5yZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91c2x5IHVzZWQgYXNwZWN0IHJhdGlvIHRvIGRldGVybWluZSBpZiBhIHJlc2l6ZVxuICAgIC8vIGlzIG5lZWRlZCBkdXJpbmcgdXBkYXRlcy4gRG8gdGhpcyBhZnRlciBfb3B0aW9ucyBpcyBzZXQgc2luY2VcbiAgICAvLyBhc3BlY3RSYXRpbyB1c2VzIGEgZ2V0dGVyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAvKiogQHR5cGUgez97YXR0YWNoPzogZnVuY3Rpb24sIGRldGFjaD86IGZ1bmN0aW9uLCByZXNpemU/OiBmdW5jdGlvbn19ICovXG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG5cbiAgICAvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICAvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcbiAgICAgIC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gSWYgYXNwZWN0UmF0aW8gaXMgZGVmaW5lZCBpbiBvcHRpb25zLCB1c2UgdGhhdC5cbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIC8vIElmIG1haW50YWluQXNwZWN0UmF0aW8gaXMgdHJ1dGhseSBhbmQgd2UgaGFkIHByZXZpb3VzbHkgZGV0ZXJtaW5lZCBfYXNwZWN0UmF0aW8sIHVzZSB0aGF0XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICAvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gaXRzIGNvbnRhaW5lciBvciB0byBleHBsaWNpdCBkaW1lbnNpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cblx0ICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcblxuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIC8vIFRoZSByZXNpemUgdXBkYXRlIGlzIGRlbGF5ZWQsIG9ubHkgZHJhdyB3aXRob3V0IHVwZGF0aW5nLlxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICAvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcblxuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcblxuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcblxuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cblxuICAvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXRzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuXG4gICAgLy8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcblxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgLy8gTmV3IGNvbnRyb2xsZXJzIHdpbGwgYmUgcmVzZXQgYWZ0ZXIgdGhlIGxheW91dCBwYXNzLCBzbyB3ZSBvbmx5IHdhbnQgdG8gbW9kaWZ5XG4gICAgICAvLyBlbGVtZW50cyBhZGRlZCB0byBuZXcgZGF0YXNldHNcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcblxuICAgIC8vIE9ubHkgcmVzZXQgdGhlIGNvbnRyb2xsZXJzIGlmIHdlIGhhdmUgYW5pbWF0aW9uc1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgLy8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgICAvLyBSZXNldCBpcyBkb25lIHRvIGdldCB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG5cbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG5cbiAgICAvLyBSZXBsYXkgbGFzdCBldmVudCBmcm9tIGJlZm9yZSB1cGRhdGUsIG9yIHNldCBob3ZlciBzdHlsZXMgb24gYWN0aXZlIGVsZW1lbnRzXG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcblxuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAvLyBUaGUgY29uZmlndXJlZCBldmVudHMgaGF2ZSBjaGFuZ2VkLiBSZWJpbmQuXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcblxuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIC8vIFNraXAgZHJhd2luZyBhbmQgY29uZmlndXJpbmcgY2hhcnRBcmVhIGJveGVzIHdoZW4gY2hhcnRBcmVhIGlzIHplcm8gb3IgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGluIGNvcmUuc2NhbGUudXBkYXRlIGFuZCBvbmNlIGhlcmUuXG4gICAgICAvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0VXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICAvLyBVbnNldCBwZW5kaW5nIHJlc2l6ZSByZXF1ZXN0IG5vdyB0byBhdm9pZCBwb3NzaWJsZSByZWN1cnNpb24gd2l0aGluIF9yZXNpemVcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCZWNhdXNlIG9mIHBsdWdpbiBob29rcyAoYmVmb3JlL2FmdGVyRGF0YXNldHNEcmF3KSwgZGF0YXNldHMgY2FuJ3RcbiAgICAvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcbiAgICAvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuXG4gICAgLy8gUmVzdCBvZiBsYXllcnNcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIGluIGRyYXdpbmcgb3JkZXJcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKHRoaXMsIG1ldGEpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBjbGlwKTtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW4gdGhlIGNoYXJ0IGFyZWEuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXMgKHNlZSwgZS5nLiwgZ2V0UmVsYXRpdmVQb3NpdGlvbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cblxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG5cbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cblxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cblxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgLy8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuICAgIC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cblxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cblxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG5cbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIC8vIEFuaW1hdGUgdmlzaWJsZSBzdGF0ZSwgc28gaGlkZSBhbmltYXRpb24gY2FuIGJlIHNlZW4uIFRoaXMgY291bGQgYmUgaGFuZGxlZCBiZXR0ZXIgaWYgdXBkYXRlIC8gdXBkYXRlRGF0YXNldCByZXR1cm5lZCBhIFByb21pc2UuXG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cblxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cblxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGV0YWNoZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG5cbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG5cbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBTdG9wIGFuaW1hdGluZyBhbmQgcmVtb3ZlIG1ldGFzZXRzLCBzbyB3aGVuIHJlLWF0dGFjaGVkLCB0aGUgYW5pbWF0aW9ucyBzdGFydCBmcm9tIGJlZ2lubmluZy5cbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcblxuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG5cbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHJldHVybnMgYXJyYXlcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgTmV3IGFjdGl2ZSBkYXRhIHBvaW50c1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB1c2UgdGhlIHByZXZpb3VzIG1vdXNlIGV2ZW50IHRvIG92ZXJyaWRlIHRoZSBhY3RpdmUgZWxlbWVudHMgaW4gdXBkYXRlLlxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUucGx1Z2lucy5qcycpLmZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHBsdWdpbiB3aXRoIHRoZSBzcGVjaWZpYyBJRCBpcyByZWdpc3RlcmVkIGFuZCBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5JZCAtIFRoZSBJRCBvZiB0aGUgcGx1Z2luIG9mIHdoaWNoIHRvIGNoZWNrIGlmIGl0IGlzIGVuYWJsZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKHAgPT4gcC5wbHVnaW4uaWQgPT09IHBsdWdpbklkKS5sZW5ndGggPT09IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyByZXBsYXllZCBieSBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSB0cnVlIGlmIHRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBgcmVwbGF5YDpcbiAgICAvLyBJdCdzIHRoZSBsYXN0IGV2ZW50IChleGNsdWRpbmcgY2xpY2spIHRoYXQgaGFzIG9jY3VycmVkIGJlZm9yZSBgdXBkYXRlYC5cbiAgICAvLyBTbyBtb3VzZSBoYXMgbm90IG1vdmVkLiBJdCdzIGFsc28gb3ZlciB0aGUgY2hhcnQsIGJlY2F1c2UgdGhlcmUgaXMgYSBgcmVwbGF5YC5cbiAgICAvL1xuICAgIC8vIFRoZSB3aHk6XG4gICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgYWN0aXZlLCB0aGUgZWxlbWVudHMgaGF2ZW4ndCBtb3ZlZCB5ZXQgY29tcGFyZWQgdG8gc3RhdGUgYmVmb3JlIHVwZGF0ZS5cbiAgICAvLyBCdXQgaWYgdGhleSB3aWxsLCB3ZSBhcmUgYWN0aXZhdGluZyB0aGUgZWxlbWVudHMgdGhhdCB3b3VsZCBiZSBhY3RpdmUsIGlmIHRoaXMgY2hlY2tcbiAgICAvLyB3YXMgZG9uZSBhZnRlciB0aGUgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZC4gPT4gXCJmaW5hbCBwb3NpdGlvbnNcIi5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb25zLCB0aGUgXCJmaW5hbFwiIGFuZCBcImN1cnJlbnRcIiBwb3NpdGlvbnMgYXJlIGVxdWFsLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byBldmFsdWF0ZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgLy8gLSBpdCB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuXG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBTZXQgX2xhc3RFdmVudCB0byBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBldmVudCBoYW5kbGVycy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgcmVjdXJzaW9uIGlmIHRoZSBoYW5kbGVyIGNhbGxzIGNoYXJ0LnVwZGF0ZSgpXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAvLyBJbnZva2Ugb25Ib3ZlciBob29rXG4gICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG5cbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWEgLSBJcyB0aGUgZXZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXR9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBub25aZXJvQmV0d2VlbiA9IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSAmJiBzdGFydEFuZ2xlICE9PSBlbmRBbmdsZTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IG5vblplcm9CZXR3ZWVuO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcblxuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyA0O1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG5cbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIG9mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIG9mZnNldCk7XG4gICAgY29uc3QgZml4ID0gMSAtIE1hdGguc2luKE1hdGgubWluKFBJLCBjaXJjdW1mZXJlbmNlIHx8IDApKTtcbiAgICBjb25zdCByYWRpdXNPZmZzZXQgPSBvZmZzZXQgKiBmaXg7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcblxuICAgIGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYmV6aWVySW50ZXJwb2xhdGlvbiwgX3BvaW50SW5MaW5lLCBfc3RlcHBlZEludGVycG9sYXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLmpzJztcbmltcG9ydCB7X2NvbXB1dGVTZWdtZW50cywgX2JvdW5kU2VnbWVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzJztcbmltcG9ydCB7X3N0ZXBwZWRMaW5lVG8sIF9iZXppZXJDdXJ2ZVRvfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7X3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cblxuICByZXR1cm4gbGluZVRvO1xufVxuXG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuXG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cblxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuXG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuXG4gIHJldHVybiAhIWxvb3A7XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuXG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG1heFkgYW5kIG1pblksIHVzaW5nIHRoZSBhdmVyYWdlIHgtY29vcmRpbmF0ZVxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICAvLyBMaW5lIHRvIHktdmFsdWUgb2YgbGFzdCBwb2ludCBpbiBncm91cC4gU28gdGhlIGxpbmUgY29udGludWVzXG4gICAgICAvLyBmcm9tIGNvcnJlY3QgcG9zaXRpb24uIE5vdCB1c2luZyBtb3ZlLCB0byBoYXZlIHNvbGlkIHBhdGguXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDsgLy8gdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuXG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIC8vIERldGVybWluZSBgbWluWWAgLyBgbWF4WWAgYW5kIGBhdmdYYCB3aGlsZSB3ZSBzdGF5IHdpdGhpbiBzYW1lIHgtcG9zaXRpb25cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIC8vIERyYXcgbGluZSB0byBuZXh0IHgtcG9zaXRpb24sIHVzaW5nIHRoZSBmaXJzdCAob3Igb25seSlcbiAgICAgIC8vIHktdmFsdWUgaW4gdGhhdCBncm91cFxuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHktdmFsdWUgaW4gZ3JvdXBcbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lIC0gdGhlIGxpbmVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgICBmaWxsOiBmYWxzZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gICAgc3RlcHBlZDogZmFsc2UsXG4gICAgdGVuc2lvbjogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cblxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cblxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGaXJzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIExhc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cblxuICAvKipcblx0ICogSW50ZXJwb2xhdGUgYSBwb2ludCBpbiB0aGlzIGxpbmUgYXQgdGhlIHNhbWUgdmFsdWUgb24gYHByb3BlcnR5YCBhc1xuXHQgKiB0aGUgcmVmZXJlbmNlIGBwb2ludGAgcHJvdmlkZWRcblx0ICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHBvaW50IC0gdGhlIHJlZmVyZW5jZSBwb2ludFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHkgdG8gbWF0Y2ggb25cblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcblxuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhIHNlZ21lbnQgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3Bcblx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgc2VnbWVudCBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhbGwgc2VnbWVudHMgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgbGluZSBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuXG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cblxuICAvKipcblx0ICogRHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEFyZWFcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICovXG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgLy8gV2hlbiBsaW5lIGlzIGFuaW1hdGVkLCB0aGUgY29udHJvbCBwb2ludHMgYW5kIHBhdGggYXJlIG5vdCBjYWNoZWQuXG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7ZHJhd1BvaW50LCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIENhcnRlc2lhblBhcnNlZERhdGEsXG4gIENoYXJ0QXJlYSxcbiAgUG9pbnQsXG4gIFBvaW50SG92ZXJPcHRpb25zLFxuICBQb2ludE9wdGlvbnMsXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gaW5SYW5nZShlbDogUG9pbnRFbGVtZW50LCBwb3M6IG51bWJlciwgYXhpczogJ3gnIHwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuXG5leHBvcnQgdHlwZSBQb2ludFByb3BzID0gUG9pbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudDxQb2ludFByb3BzLCBQb2ludE9wdGlvbnMgJiBQb2ludEhvdmVyT3B0aW9ucz4ge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2ludCc7XG5cbiAgcGFyc2VkOiBDYXJ0ZXNpYW5QYXJzZWREYXRhO1xuICBza2lwPzogYm9vbGVhbjtcbiAgc3RvcD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgaGl0UmFkaXVzOiAxLFxuICAgIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gICAgaG92ZXJSYWRpdXM6IDQsXG4gICAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gICAgcmFkaXVzOiAzLFxuICAgIHJvdGF0aW9uOiAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYOiBudW1iZXIsIG1vdXNlWTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWDogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG5cbiAgc2l6ZShvcHRpb25zPzogUGFydGlhbDxQb2ludE9wdGlvbnMgJiBQb2ludEhvdmVyT3B0aW9ucz4pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHJhZGl1cyAmJiBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG5cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEZhbGxiYWNrcyBzaG91bGQgbmV2ZXIgYmUgaGl0IGluIHByYWN0aWNlXG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge3RvVFJCTCwgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKiogQHR5cGVkZWYge3sgeDogbnVtYmVyLCB5OiBudW1iZXIsIGJhc2U6IG51bWJlciwgaG9yaXpvbnRhbDogYm9vbGVhbiwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gQmFyUHJvcHMgKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtCYXJFbGVtZW50fSBiYXIgdGhlIGJhclxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH0gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG5cbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcblxuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcblxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBhc3N1bWUgdGhlIHVzZXIga25vd3Mgd2hhdCB0aGV5IGFyZSBkb2luZ1xuICAvLyBhbmQgYXBwbHkgYXMgZGlyZWN0ZWQuXG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gKiBAcGFyYW0geyp9IHJlY3QgQm91bmRpbmcgcmVjdFxuICovXG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICAgIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAodGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cblxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG4iLCAiaW1wb3J0IHtEb3VnaG51dENvbnRyb2xsZXIsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIGRlZmF1bHRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMoKSB7XG4gIHJldHVybiBkZWZhdWx0cy5ib3JkZXJDb2xvciAhPT0gJ3JnYmEoMCwwLDAsMC4xKScgfHwgZGVmYXVsdHMuYmFja2dyb3VuZENvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGNvbnN0IGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uID0gKFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHxcbiAgICAgIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihjaGFydE9wdGlvbnMpIHx8XG4gICAgICAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpIHx8XG4gICAgICBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpKTtcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JpemVyID0gZ2V0Q29sb3JpemVyKGNoYXJ0KTtcblxuICAgIGRhdGFzZXRzLmZvckVhY2goY29sb3JpemVyKTtcbiAgfVxufTtcbiIsICJpbXBvcnQge19saW1pdFZhbHVlLCBfbG9va3VwQnlLZXksIGlzTnVsbE9yVW5kZWYsIHJlc29sdmV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTGFyZ2VzdCBUcmlhbmdsZSBUaHJlZSBCdWNrZXRzIGFsZ29yaXRobS5cbiAgICpcbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYnkgU3ZlaW5uIFN0ZWluYXJzc29uXG4gICAqIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVpbm4tc3RlaW5hcnNzb24vZmxvdC1kb3duc2FtcGxlL2Jsb2IvbWFzdGVyL2pxdWVyeS5mbG90LmRvd25zYW1wbGUuanNcbiAgICpcbiAgICogVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGlzIE1JVCBsaWNlbnNlZC5cbiAgICovXG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIC8vIFRoZXJlIGFyZSBsZXNzIHBvaW50cyB0aGFuIHRoZSB0aHJlc2hvbGQsIHJldHVybmluZyB0aGUgd2hvbGUgYXJyYXlcbiAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIH1cblxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcblxuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIC8vIFN0YXJ0aW5nIGZyb20gb2Zmc2V0XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuXG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG5cbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG5cbiAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgY2hhbmdlZCBmcm9tIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gd2hpY2ggaW5pdGlhbGl6ZXMgdGhlc2VcbiAgICAvLyB2YWx1ZXMgdG8gMS4gVGhlIHJlYXNvbiBmb3IgdGhpcyBjaGFuZ2UgaXMgdGhhdCBpZiB0aGUgYXJlYSBpcyBzbWFsbCwgbmV4dEFcbiAgICAvLyB3b3VsZCBuZXZlciBiZSBzZXQgYW5kIHRodXMgYSBjcmFzaCB3b3VsZCBvY2N1ciBpbiB0aGUgbmV4dCBsb29wIGFzIGBhYCB3b3VsZCBiZWNvbWVcbiAgICAvLyBgdW5kZWZpbmVkYC4gU2luY2UgdGhlIGFyZWEgaXMgYWx3YXlzIHBvc2l0aXZlLCBidXQgY291bGQgYmUgMCBpbiB0aGUgY2FzZSBvZiBhIGZsYXQgdHJhY2UsXG4gICAgLy8gaW5pdGlhbGl6aW5nIHdpdGggYSBuZWdhdGl2ZSBudW1iZXIgaXMgdGhlIGNvcnJlY3Qgc29sdXRpb24uXG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcblxuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcblxuICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICBuZXh0QSA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cblxuICAvLyBJbmNsdWRlIHRoZSBsYXN0IHBvaW50XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcblxuICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgY29uc3QgeE1heCA9IGRhdGFbZW5kSW5kZXhdLng7XG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuXG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIC8vIERldGVybWluZSBgbWluWWAgLyBgbWF4WWAgYW5kIGBhdmdYYCB3aGlsZSB3ZSBzdGF5IHdpdGhpbiBzYW1lIHgtcG9zaXRpb25cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIC8vIFVzZSBwb2ludC54IGhlcmUgYmVjYXVzZSB3ZSdyZSBjb21wdXRpbmcgdGhlIGF2ZXJhZ2UgZGF0YSBgeGAgdmFsdWVcbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFB1c2ggdXAgdG8gNCBwb2ludHMsIDMgZm9yIHRoZSBsYXN0IGludGVydmFsIGFuZCB0aGUgZmlyc3QgcG9pbnQgZm9yIHRoaXMgaW50ZXJ2YWxcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICAvLyBUaGUgaW50ZXJ2YWwgaXMgZGVmaW5lZCBieSA0IHBvaW50czogc3RhcnQsIG1pbiwgbWF4LCBlbmQuXG4gICAgICAgIC8vIFRoZSBzdGFydGluZyBwb2ludCBpcyBhbHJlYWR5IGNvbnNpZGVyZWQgYXQgdGhpcyBwb2ludCwgc28gd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgLy8gb2YgdGhlIG90aGVyIHBvaW50cyB0byBhZGQuIFdlIG5lZWQgdG8gc29ydCB0aGVzZSBwb2ludHMgdG8gZW5zdXJlIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgICAvLyBpcyBzdGlsbCBzb3J0ZWQgYW5kIHRoZW4gZW5zdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzLlxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuXG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICB4OiBhdmdYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDIgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbGFzdEluZGV4ID09PSBzdGFydEluZGV4IHdpbGwgb2NjdXIgd2hlbiBhIHJhbmdlIGhhcyBvbmx5IDEgcG9pbnQgd2hpY2ggY291bGRcbiAgICAgIC8vIGhhcHBlbiB3aXRoIHZlcnkgdW5ldmVuIGRhdGFcbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgLy8gTGFzdCBwb2ludCBpbiB0aGUgcHJldmlvdXMgaW50ZXJ2YWxcbiAgICAgICAgZGVjaW1hdGVkLnB1c2goZGF0YVtsYXN0SW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgb2YgdGhlIG5ldyBpbnRlcnZhbFxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50O1xuXG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG5cbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcblxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuXG4gIGJlZm9yZUVsZW1lbnRzVXBkYXRlOiAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgLy8gVGhlIGRlY2ltYXRpb24gcGx1Z2luIG1heSBoYXZlIGJlZW4gcHJldmlvdXNseSBlbmFibGVkLiBOZWVkIHRvIHJlbW92ZSBvbGQgYGRhdGFzZXQuX2RhdGFgIGhhbmRsZXJzXG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFzc3VtZSB0aGUgZW50aXJlIGNoYXJ0IGlzIGF2YWlsYWJsZSB0byBzaG93IGEgZmV3IG1vcmUgcG9pbnRzIHRoYW4gbmVlZGVkXG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcblxuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuXG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgLy8gRGVjaW1hdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbGluZXMgdGhhdCBoYXZlIGFuIFggaW5kZXhBeGlzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXRhLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZSBkYXRhc2V0cyBhcmUgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcbiAgICAgIGlmICh4QXhpcy50eXBlICE9PSAnbGluZWFyJyAmJiB4QXhpcy50eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgLy8gT25seSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIC8vIFBsdWdpbiBvbmx5IHN1cHBvcnRzIGRhdGEgdGhhdCBkb2VzIG5vdCBuZWVkIHBhcnNpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gTm8gZGVjaW1hdGlvbiBpcyByZXF1aXJlZCB1bnRpbCB3ZSBhcmUgYWJvdmUgdGhpcyB0aHJlc2hvbGRcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHdlIGFyZSBzZWVpbmcgdGhpcyBkYXRhc2V0XG4gICAgICAgIC8vIFdlIG92ZXJyaWRlIHRoZSAnZGF0YScgcHJvcGVydHkgd2l0aCBhIHNldHRlciB0aGF0IHN0b3JlcyB0aGVcbiAgICAgICAgLy8gcmF3IGRhdGEgaW4gX2RhdGEsIGJ1dCByZWFkcyB0aGUgZGVjaW1hdGVkIGRhdGEgZnJvbSBfZGVjaW1hdGVkXG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBvaW50IHRoZSBjaGFydCB0byB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcblxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcbiIsICJpbXBvcnQge19ib3VuZFNlZ21lbnQsIF9ib3VuZFNlZ21lbnRzLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG5cbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcblxuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGJvdW5kYXJ5IG5vdCBzdXBwb3J0aW5nIGBzZWdtZW50c2AgKHNpbXBsZUFyYylcbiAgICAgIC8vIEJvdW5kcyBhcmUgcHJvdmlkZWQgYXMgYHRhcmdldGAgZm9yIHBhcnRpYWwgY2lyY2xlLCBvciB1bmRlZmluZWQgZm9yIGZ1bGwgY2lyY2xlXG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBzZWdtZW50cyBmcm9tIGB0YXJnZXRgIHRoYXQgaW50ZXJzZWN0IHRoZSBib3VuZHMgb2YgY3VycmVudCBzZWdtZW50IG9mIGBsaW5lYFxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuXG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcblxuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19wb2ludHNGcm9tU2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W10gfCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB9fSBib3VuZGFyeVxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHJldHVybiB7TGluZUVsZW1lbnQ/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuXG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuIiwgImltcG9ydCB7aXNPYmplY3QsIGlzRmluaXRlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkZpbGxUYXJnZXQgfSBGaWxsVGFyZ2V0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5Db21wbGV4RmlsbFRhcmdldCB9IENvbXBsZXhGaWxsVGFyZ2V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuXG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cblxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cblxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICAvKiogQHR5cGUge3N0cmluZyB8IHt2YWx1ZTogbnVtYmVyfX0gKi9cbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcblxuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cblxuICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcblxuICBpZiAoaXNGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gIH1cblxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVRhcmdldEluZGV4KGZpcnN0Q2gsIGluZGV4LCB0YXJnZXQsIGNvdW50KSB7XG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG4gIH1cblxuICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICBsZXQgcGl4ZWwgPSBudWxsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHBpeGVsID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS50b3A7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgcmV0dXJuIHBpeGVsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgbGV0IHZhbHVlO1xuXG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqL1xuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcblxuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge19pc0JldHdlZW59IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7eyBjaGFydDogQ2hhcnQ7IHNjYWxlOiBTY2FsZTsgaW5kZXg6IG51bWJlcjsgbGluZTogTGluZUVsZW1lbnQ7IH19IHNvdXJjZVxuICogQHJldHVybiB7TGluZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50W119IGxpbmVzQmVsb3dcbiAqL1xuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG5cbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgb2YgYW4gc2VnbWVudCAtPiBuZWVkIHRvIGFkZCBhbm90aGVyIHBvaW50IGJlZm9yZSB0aGlzLFxuICAgICAgLy8gZnJvbSBuZXh0IGxpbmUgYmVsb3cuXG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAvLyBJbiB0aGUgbWlkZGxlIG9mIGFuIHNlZ21lbnQsIG5vIG5lZWQgdG8gYWRkIG1vcmUgcG9pbnRzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge3twb2ludD86IFBvaW50RWxlbWVudCwgZmlyc3Q/OiBib29sZWFuLCBsYXN0PzogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cbiIsICJpbXBvcnQge1RBVX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8vIFRPRE86IHVzZSBlbGVtZW50cy5BcmNFbGVtZW50IGluc3RlYWRcbmV4cG9ydCBjbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG5cbiAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgIHJldHVybiAhb3B0cy5ib3VuZHM7XG4gIH1cblxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0UGl4ZWwsIF9nZXRUYXJnZXRWYWx1ZX0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5pbXBvcnQge19idWlsZFN0YWNrTGluZX0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LnN0YWNrLmpzJztcbmltcG9ydCB7c2ltcGxlQXJjfSBmcm9tICcuL3NpbXBsZUFyYy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcblxuICBpZiAoaXNGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcblxuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcblxuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG5cbiAgaWYgKGlzRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcblxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4iLCAiaW1wb3J0IHtjbGlwQXJlYSwgdW5jbGlwQXJlYSwgZ2V0RGF0YXNldENsaXBBcmVhfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2ZpbmRTZWdtZW50RW5kLCBfZ2V0Qm91bmRzLCBfc2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0fSBmcm9tICcuL2ZpbGxlci50YXJnZXQuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2NoYXJ0LCBpbmRleCwgbGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKGNoYXJ0LCBtZXRhKTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXMsIGNsaXB9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGNsaXB9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG5cbiAgY3R4LnNhdmUoKTtcblxuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHksIGNsaXB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZSwgY2xpcH0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuXG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcblxuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIGJvdW5kcykge1xuICBjb25zdCBjaGFydEFyZWEgPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG5cbiAgaWYgKHByb3BlcnR5ID09PSAneCcgfHwgcHJvcGVydHkgPT09ICd5Jykge1xuICAgIGxldCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b207XG5cbiAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgbGVmdCA9IHN0YXJ0O1xuICAgICAgdG9wID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHJpZ2h0ID0gZW5kO1xuICAgICAgYm90dG9tID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgdG9wID0gc3RhcnQ7XG4gICAgICByaWdodCA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICAgIGJvdHRvbSA9IGVuZDtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIGNsaXAubGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBjbGlwLnJpZ2h0KTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY2xpcC50b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBjbGlwLmJvdHRvbSk7XG4gICAgfVxuXG4gICAgY3R4LnJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbiIsICIvKipcbiAqIFBsdWdpbiBiYXNlZCBvbiBkaXNjdXNzaW9uIGZyb20gdGhlIGZvbGxvd2luZyBDaGFydC5qcyBpc3N1ZXM6XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMzgwI2lzc3VlY29tbWVudC0yNzk5NjE1NjlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0NDAjaXNzdWVjb21tZW50LTI1NjQ2MTg5N1xuICovXG5cbmltcG9ydCBMaW5lRWxlbWVudCBmcm9tICcuLi8uLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnO1xuaW1wb3J0IHtfZHJhd2ZpbGx9IGZyb20gJy4vZmlsbGVyLmRyYXdpbmcuanMnO1xuaW1wb3J0IHtfc2hvdWxkQXBwbHlGaWxsfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZGVjb2RlRmlsbCwgX3Jlc29sdmVUYXJnZXR9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZmlsbGVyJyxcblxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcblxuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG5cbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGgsIGRyYXdQb2ludExlZ2VuZCwgcmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge1xuICBfaXNCZXR3ZWVuLFxuICBjYWxsYmFjayBhcyBjYWxsLFxuICBjbGlwQXJlYSxcbiAgZ2V0UnRsQWRhcHRlcixcbiAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLFxuICByZXN0b3JlVGV4dERpcmVjdGlvbixcbiAgdG9Gb250LFxuICB0b1BhZGRpbmcsXG4gIHVuY2xpcEFyZWEsXG4gIHZhbHVlT3JEZWZhdWx0LFxufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2FsaWduU3RhcnRFbmQsIF90ZXh0WCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7dG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKi9cblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuXG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5cbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuXG5leHBvcnQgY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG4gICAgLyoqXG4gXHRcdCAqIEBwcml2YXRlXG4gXHRcdCAqL1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcblxuICAgIC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcblxuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbChsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG5cbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG5cbiAgICAvLyBUaGUgbGVnZW5kIG1heSBub3QgYmUgZGlzcGxheWVkIGZvciBhIHZhcmlldHkgb2YgcmVhc29ucyBpbmNsdWRpbmdcbiAgICAvLyB0aGUgZmFjdCB0aGF0IHRoZSBkZWZhdWx0cyBnb3Qgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gV2hlbiB0aGUgbGVnZW5kIGlzIG5vdCBkaXNwbGF5ZWQsIHRoZXJlIGFyZSBubyBndWFyYW50ZWVzIHRoYXQgdGhlIG9wdGlvbnNcbiAgICAvLyBhcmUgY29ycmVjdGx5IGZvcm1hdHRlZCBzbyB3ZSBuZWVkIHRvIGJhaWwgb3V0IGFzIGVhcmx5IGFzIHBvc3NpYmxlLlxuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heFdpZHRoLCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgLy8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG4gICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFswXTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG5cbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG5cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuXG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuXG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBfaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG5cbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuXG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fSA9IGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpO1xuXG4gICAgICAvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2BcbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuXG4gICAgICAvLyBHZXQgbWF4IHdpZHRoXG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG5cbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuXG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcblxuICAgICAgdGhpcy5fZHJhdygpO1xuXG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge3BhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG5cbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuXG4gICAgLy8gQ2FudmFzIHNldHVwXG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXG4gICAgLy8gY3VycmVudCBwb3NpdGlvblxuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBjdHggZm9yIHRoZSBib3hcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcblxuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcblxuICAgICAgICAvLyBEcmF3IHBvaW50U3R5bGUgYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIC8vIEFkanVzdCBwb3NpdGlvbiB3aGVuIGJveEhlaWdodCA8IGZvbnRTaXplICh3YW50IGl0IGNlbnRlcmVkKVxuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBIb3Jpem9udGFsXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuXG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblxuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcblxuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gdGhpcy5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuXG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcblxuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuXG4gICAgICAvLyBGaWxsIHRoZSBhY3R1YWwgbGFiZWxcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZWdlbmRJdGVtLnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGZvbnRMaW5lSGVpZ2h0ID0gbGFiZWxGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgIGN1cnNvci55ICs9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcblxuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG5cbiAgICAvLyBUaGVzZSBkZWZhdWx0cyBhcmUgdXNlZCB3aGVuIHRoZSBsZWdlbmQgaXMgdmVydGljYWwuXG4gICAgLy8gV2hlbiBob3Jpem9udGFsLCB0aGV5IGFyZSBjb21wdXRlZCBiZWxvdy5cbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIE1vdmUgbGVmdCAvIHJpZ2h0IHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgbGluZXNcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xuICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIGxlZnQsIHRoaXMucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgZG93biBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIHN0YWNrIGluIGV2ZXJ5IGFsaWdubWVudFxuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGlubmVyIGxlZ2VuZCBib3gsIGNvbXB1dGUgdGhlIGNvcnJlY3RcbiAgICAvLyBYIGNvb3JkaW5hdGUgZnJvbSB0aGUgdGl0bGUgYWxpZ25tZW50XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuXG4gICAgLy8gQ2FudmFzIHNldHVwXG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuXG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICAvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuXG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIC8vIFRvdWNoaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblxuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbChvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KSB7XG4gIGNvbnN0IGl0ZW1XaWR0aCA9IGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpO1xuICBjb25zdCBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgbGFiZWxGb250LmxpbmVIZWlnaHQpO1xuICByZXR1cm4ge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpIHtcbiAgbGV0IGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbS50ZXh0O1xuICBpZiAobGVnZW5kSXRlbVRleHQgJiYgdHlwZW9mIGxlZ2VuZEl0ZW1UZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbVRleHQucmVkdWNlKChhLCBiKSA9PiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIpO1xuICB9XG4gIHJldHVybiBib3hXaWR0aCArIChsYWJlbEZvbnQuc2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW1UZXh0KS53aWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgbGV0IGl0ZW1IZWlnaHQgPSBfaXRlbUhlaWdodDtcbiAgaWYgKHR5cGVvZiBsZWdlbmRJdGVtLnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpO1xuICB9XG4gIHJldHVybiBpdGVtSGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGNvbnN0IGxhYmVsSGVpZ2h0ID0gbGVnZW5kSXRlbS50ZXh0ID8gbGVnZW5kSXRlbS50ZXh0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiBmb250TGluZUhlaWdodCAqIGxhYmVsSGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdsZWdlbmQnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBMZWdlbmQsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG5cbiAgLy8gRHVyaW5nIHRoZSBiZWZvcmVVcGRhdGUgc3RlcCwgdGhlIGxheW91dCBjb25maWd1cmF0aW9uIG5lZWRzIHRvIHJ1blxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiB0aGUgbGVnZW5kIHBvc2l0aW9uIGNoYW5nZXMgKHZpYSBhbiBvcHRpb24gdXBkYXRlKVxuICAvLyB0aGUgbGF5b3V0IHN5c3RlbSByZXNwZWN0cyB0aGUgY2hhbmdlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzc1MjdcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgLy8gVGhlIGxhYmVscyBuZWVkIHRvIGJlIGJ1aWx0IGFmdGVyIGRhdGFzZXRzIGFyZSB1cGRhdGVkIHRvIGVuc3VyZSB0aGF0IGNvbG9yc1xuICAvLyBhbmQgb3RoZXIgc3R5bGluZyBhcmUgY29ycmVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82OTY4XG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuXG4gICAgLy8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcblxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICAvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcbiAgICAgIC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuICAgICAgLy8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuICAgICAgLy8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG4gICAgICAvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG4gICAgICAvLyBsaW5lRGFzaFxuICAgICAgLy8gbGluZURhc2hPZmZzZXQgOlxuICAgICAgLy8gbGluZUpvaW4gOlxuICAgICAgLy8gbGluZVdpZHRoIDpcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3IsIHVzZUJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdXNlQm9yZGVyUmFkaXVzICYmIChib3JkZXJSYWRpdXMgfHwgc3R5bGUuYm9yZGVyUmFkaXVzKSxcblxuICAgICAgICAgICAgLy8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge1BJLCBpc0FycmF5LCB0b1BhZGRpbmcsIHRvRm9udH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge190b0xlZnRSaWdodENlbnRlciwgX2FsaWduU3RhcnRFbmR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtyZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcblxuZXhwb3J0IGNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuXG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuXG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndGl0bGUnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBUaXRsZSxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCB7VGl0bGV9IGZyb20gJy4vcGx1Z2luLnRpdGxlLmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3N1YnRpdGxlJyxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuXG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIGFuZCBzbWFsbGVyIHRoYW4gdGl0bGUgKDIwMDApXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi4vY29yZS9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtlYWNoLCBub29wLCBpc051bGxPclVuZGVmLCBpc0FycmF5LCBfZWxlbWVudHNFcXVhbCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7Z2V0UnRsQWRhcHRlciwgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCByZXN0b3JlVGV4dERpcmVjdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnJ0bC5qcyc7XG5pbXBvcnQge2Rpc3RhbmNlQmV0d2VlblBvaW50cywgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgZHJhd1BvaW50fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50IH0gQWN0aXZlRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcycpLkludGVyYWN0aW9uSXRlbSB9IEludGVyYWN0aW9uSXRlbVxuICovXG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuICAvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICovXG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHhTZXQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHhTZXQuYWRkKHBvcy54KTtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2aXNpYmxlIGl0ZW1zIHdoZXJlIGZvdW5kLCByZXR1cm4gZmFsc2Ugc28gd2UgZG9uJ3QgaGF2ZSB0byBkaXZpZGUgYnkgMCB3aGljaCByZWR1Y2VzIGluIE5hTlxuICAgIGlmIChjb3VudCA9PT0gMCB8fCB4U2V0LnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB4QXZlcmFnZSA9IFsuLi54U2V0XS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHhTZXQuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4QXZlcmFnZSxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxuXHQgKi9cbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5cbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcbiAgaWYgKHRvUHVzaCkge1xuICAgIGlmIChpc0FycmF5KHRvUHVzaCkpIHtcbiAgICAgIC8vIGJhc2UgPSBiYXNlLmNvbmNhdCh0b1B1c2gpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVcbiAqIEBwYXJhbSB7Kn0gc3RyIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN0cmluZ1tdfSB2YWx1ZSBpZiBuZXdsaW5lIHByZXNlbnQgLSBSZXR1cm5lZCBmcm9tIFN0cmluZyBzcGxpdCgpIG1ldGhvZFxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gIGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cblxuLyoqXG4gKiBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge0FjdGl2ZUVsZW1lbnR9IGl0ZW0gLSB7ZWxlbWVudCwgaW5kZXgsIGRhdGFzZXRJbmRleH0gdG8gY3JlYXRlIHRoZSB0b29sdGlwIGl0ZW0gZm9yXG4gKiBAcmV0dXJuIG5ldyB0b29sdGlwIGl0ZW1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuXG4gIHJldHVybiB7XG4gICAgY2hhcnQsXG4gICAgbGFiZWwsXG4gICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgZGF0YXNldEluZGV4LFxuICAgIGVsZW1lbnRcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG5cbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG5cbiAgLy8gQ291bnQgb2YgYWxsIGxpbmVzIGluIHRoZSBib2R5XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcblxuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSBoZWlnaHQgZGVwZW5kaW5nIG9uIGJveEhlaWdodFxuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cblxuICAvLyBUaXRsZSB3aWR0aFxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IHdpZHRoXG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcblxuICAvLyBSZXNldCBiYWNrIHRvIDBcbiAgd2lkdGhQYWRkaW5nID0gMDtcblxuICAvLyBGb290ZXIgd2lkdGhcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcblxuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG5cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuXG4gIHJldHVybiB4QWxpZ247XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgYWxpZ25tZW50IG9mIGEgdG9vbHRpcCBnaXZlbiB0aGUgc2l6ZVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcblxuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuXG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGxvY2F0aW9uIGEgdG9vbHRpcCBuZWVkcyB0byBiZSBwbGFjZWQgYXQgZ2l2ZW4gdGhlIGluaXRpYWwgcG9zaXRpb24gKHZpYSB0aGUgdm0pIGFuZCB0aGUgc2l6ZSBhbmQgYWxpZ25tZW50XG4gKi9cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcblxuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB4IC09IHBhZGRpbmdBbmRTaXplO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5cbmNvbnN0IGRlZmF1bHRDYWxsYmFja3MgPSB7XG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgYWZ0ZXJUaXRsZTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG5cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbDtcbiAgfSxcbiAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgfTtcbiAgfSxcbiAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gIH0sXG4gIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgfTtcbiAgfSxcbiAgYWZ0ZXJMYWJlbDogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYWZ0ZXJCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gIGZvb3Rlcjogbm9vcCxcbiAgYWZ0ZXJGb290ZXI6IG5vb3Bcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIGZyb20gb2JqZWN0IHdpdGggY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICogSWYgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlbiB3aWxsIGJlIGludm9rZWQgZGVmYXVsdCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7UmVjb3JkPGtleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzLCBGdW5jdGlvbj59IGNhbGxiYWNrc1xuICogQHBhcmFtIHtrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrc30gbmFtZVxuICogQHBhcmFtIHsqfSBjdHhcbiAqIEBwYXJhbSB7Kn0gYXJnXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsIG5hbWUsIGN0eCwgYXJnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrc1tuYW1lXS5jYWxsKGN0eCwgYXJnKTtcblxuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZGVmYXVsdENhbGxiYWNrc1tuYW1lXS5jYWxsKGN0eCwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xuICAgKi9cbiAgc3RhdGljIHBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgLy8gVE9ETzogVjQsIG1ha2UgdGhpcyBwcml2YXRlLCByZW5hbWUgdG8gYF9sYWJlbFN0eWxlc2AsIGFuZCBjb21iaW5lIHdpdGggYGxhYmVsUG9pbnRTdHlsZXNgXG4gICAgLy8gYW5kIGBsYWJlbFRleHRDb2xvcnNgIHRvIGNyZWF0ZSBhIHNpbmdsZSB2YXJpYWJsZVxuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cblxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVUaXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IHRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAndGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJUaXRsZScsIHRoaXMsIGNvbnRleHQpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdiZWZvcmVCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcblxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYmVmb3JlTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbCcsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdhZnRlckxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcblxuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuXG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2FmdGVyQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZUZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgZm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnZm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgZmlsdGVyIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc29ydGluZyBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxDb2xvcicsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbFBvaW50U3R5bGUnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbFRleHRDb2xvcicsIHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG5cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcblxuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcblxuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG5cbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblxuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQgJiYgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgb3B0aW9ucy5leHRlcm5hbC5jYWxsKHRoaXMsIHtjaGFydDogdGhpcy5jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG5cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuXG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cblxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcblxuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIExlZnQgZHJhd3MgYm90dG9tIC0+IHRvcCwgdGhpcyB5MSBpcyBvbiB0aGUgYm90dG9tXG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFJpZ2h0IGRyYXdzIHRvcCAtPiBib3R0b20sIHRodXMgeTEgaXMgb24gdGhlIHRvcFxuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuXG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBUb3AgZHJhd3MgbGVmdCAtPiByaWdodCwgdGh1cyB4MSBpcyBvbiB0aGUgbGVmdFxuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gQm90dG9tIGRyYXdzIHJpZ2h0IC0+IGxlZnQsIHRodXMgeDEgaXMgb24gdGhlIHJpZ2h0XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG5cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuXG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcblxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZzsgLy8gSWYgTGFzdCwgYWRkIG1hcmdpbiwgcmVtb3ZlIHNwYWNpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9yID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGh9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcblxuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMiwgLy8gZml0IHRoZSBjaXJjbGUgaW4gdGhlIGJveFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuXG4gICAgICAvLyBGaWxsIHRoZSBwb2ludCB3aXRoIHdoaXRlIHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcblxuICAgICAgLy8gRHJhdyB0aGUgcG9pbnRcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvcmRlclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzT2JqZWN0KGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpID8gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhsYWJlbENvbG9yLmJvcmRlcldpZHRoKSkgOiAobGFiZWxDb2xvci5ib3JkZXJXaWR0aCB8fCAxKTsgLy8gVE9ETywgdjQgcmVtb3ZlIGZhbGxiYWNrXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3IuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9yLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcblxuICAgICAgLy8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3IuYm9yZGVyUmFkaXVzKTtcblxuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgcmVjdFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGZpbGxTdHlsZVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuXG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcblxuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuXG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEJlZm9yZSBib2R5IGxpbmVzXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcblxuICAgIC8vIERyYXcgYm9keSBsaW5lcyBub3dcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIC8vIFJlc2V0IGZvciBhbnkgbGluZXMgdGhhdCBkb24ndCBpbmNsdWRlIGNvbG9yYm94XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuXG4gICAgLy8gQWZ0ZXIgYm9keSBsaW5lc1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcbiAgfVxuXG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuXG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICBjdHguZmlsbCgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSB4L3kgYW5pbWF0aW9uIHRhcmdldHMgd2hlbiBfYWN0aXZlIGVsZW1lbnRzIGFyZSBhbmltYXRpbmcgdG9vXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgdG9vbHRpcCB3aWxsIGRyYXcgYW55dGhpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRvb2x0aXAgd2lsbCByZW5kZXJcbiAgICovXG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcblxuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueVxuICAgIH07XG5cbiAgICAvLyBJRTExL0VkZ2UgZG9lcyBub3QgbGlrZSB2ZXJ5IHNtYWxsIG9wYWNpdGllcywgc28gc25hcCB0byAwXG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gICAgLy8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG5cbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblxuICAgICAgLy8gRHJhdyBCYWNrZ3JvdW5kXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcblxuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcblxuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcblxuICAgICAgLy8gVGl0bGVzXG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgLy8gQm9keVxuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgLy8gRm9vdGVyXG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGUgdG9vbHRpcFxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZUVsZW1lbnRzIEFycmF5IG9mIGFjdGl2ZSBkYXRhc2V0SW5kZXgvaW5kZXggcGFpcnMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFBvc2l0aW9uIFN5bnRoZXRpYyBldmVudCBwb3NpdGlvbiB1c2VkIGluIHBvc2l0aW9uaW5nXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyBzaG93biwgYnV0IHRoZSB0b29sdGlwIHBvc2l0aW9uIGlzIG5lYXJlc3QgbW9kZVxuICAgIC8vIGFuIHVwZGF0ZSBtYXkgbmVlZCB0byBiZSBtYWRlIGJlY2F1c2Ugb3VyIHBvc2l0aW9uIG1heSBoYXZlIGNoYW5nZWQgZXZlbiB0aG91Z2hcbiAgICAvLyB0aGUgaXRlbXMgYXJlIHRoZSBzYW1lIGFzIGJlZm9yZS5cbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcblxuICAgIC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuICAgIGNvbnN0IGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuXG4gICAgLy8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcblxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcblx0ICogSGVscGVyIGZvciBkZXRlcm1pbmluZyB0aGUgYWN0aXZlIGVsZW1lbnRzIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25JdGVtW119IGxhc3RBY3RpdmUgLSBQcmV2aW91c2x5IGFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge0ludGVyYWN0aW9uSXRlbVtdfSAtIEFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIC8vIEJ1dCBtYWtlIHN1cmUgdGhhdCBhY3RpdmUgZWxlbWVudHMgYXJlIHN0aWxsIHZhbGlkLlxuICAgICAgcmV0dXJuIGxhc3RBY3RpdmUuZmlsdGVyKGkgPT5cbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2kuZGF0YXNldEluZGV4XSAmJlxuICAgICAgICB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFBhcnNlZChpLmluZGV4KSAhPT0gdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3RpdmU7XG4gIH1cblxuICAvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBhY3RpdmUgZWxlbWVudHMgKyBldmVudCBjb21iaW5hdGlvbiBjaGFuZ2VzIHRoZVxuXHQgKiB0b29sdGlwIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZSAtIEFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBFdmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgcG9zaXRpb24gY2hhbmdlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuXHQgKi9cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcblxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuXG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fd2lsbFJlbmRlcigpKSB7XG4gICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICB0b29sdGlwXG4gICAgICB9O1xuXG4gICAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCB7Li4uYXJncywgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuXG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGxheWVkIGZyb20gYHVwZGF0ZWAsIHdlIHNob3VsZCBldmFsdWF0ZSB3aXRoIHRoZSBmaW5hbCBwb3NpdGlvbnMuXG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICAvLyBub3RpZnkgY2hhcnQgYWJvdXQgdGhlIGNoYW5nZSwgc28gaXQgd2lsbCByZW5kZXJcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczogZGVmYXVsdENhbGxiYWNrc1xuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXNvbHZlIGFkZGl0aW9uYWxseSBmcm9tIGBpbnRlcmFjdGlvbmAgb3B0aW9ucyBhbmQgZGVmYXVsdHMuXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcbiIsICJpbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHQsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5cbmZ1bmN0aW9uIF9nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdjYXRlZ29yeSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBfZ2V0TGFiZWxGb3JWYWx1ZVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICAgIC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG5cbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRMYWJlbEZvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHZlcnRpY2FsIGNhdGVnb3J5IHNjYWxlIHJldmVyc2UgaXMgaW52ZXJ0ZWQuXG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICAvLyBNdXN0IG92ZXJyaWRlIGJhc2UgaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBjYWxscyBnZXRQaXhlbEZvclZhbHVlXG4gIC8vIGFuZCBjYXRlZ29yeSBzY2FsZSBjYW4gaGF2ZSBkdXBsaWNhdGUgdmFsdWVzXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FsbW9zdEVxdWFscywgYWxtb3N0V2hvbGUsIG5pY2VOdW0sIF9kZWNpbWFsUGxhY2VzLCBfc2V0TWluQW5kTWF4QnlLZXksIHNpZ24sIHRvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrcyBmb3IgYW4gYXhpc1xuICogMS4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwIGFyZSBkZWZpbmVkOlxuICogICAgaWYgKG1heCAtIG1pbikgLyBzdGVwIGlzIGFuIGludGVnZXIsIHRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3RlcCwgLi4uLCBtYXhdXG4gKiAgICBOb3RlIHRoYXQgdGhlIGdlbmVyYXRpb25PcHRpb25zLm1heENvdW50IHNldHRpbmcgaXMgcmVzcGVjdGVkIGluIHRoaXMgc2NlbmFyaW9cbiAqXG4gKiAyLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIGNvdW50XG4gKiAgICBUaWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHNwYWNpbmcsIC4uLiwgbWF4XVxuICpcbiAqIDMuIElmIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gY291bnRcbiAqXG4gKiA0LiBDb21wdXRlIG9wdGltYWwgc3BhY2luZyBvZiB0aWNrcyB1c2luZyBuaWNlTnVtIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcbiAgLy8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3NcbiAgLy8gZm9yIGRldGFpbHMuXG5cbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuXG4gIC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXG4gIC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3NcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cblxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG5cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG5cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgLy8gQ2FzZSAxOiBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgYXJlIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxuICAgIC8vIHNwYWNpbmcgPSBzdGVwO1xuICAgIC8vIG51bVNwYWNlcyA9IChtYXggLSBtaW4pIC8gc3BhY2luZztcbiAgICAvLyBOb3RlIHRoYXQgd2Ugcm91bmQgaGVyZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYWxtb3N0V2hvbGUgdHJhbnNsYXRlZCBhbiBGUCBlcnJvclxuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgLy8gQ2FzZXMgMiAmIDMsIHdlIGhhdmUgYSBjb3VudCBzcGVjaWZpZWQuIEhhbmRsZSBvcHRpb25hbCB1c2VyIGRlZmluZWQgZWRnZXMgdG8gdGhlIHJhbmdlLlxuICAgIC8vIFNvbWV0aW1lcyB0aGVzZSBhcmUgbm8tb3BzLCBidXQgaXQgbWFrZXMgdGhlIGNvZGUgYSBsb3QgY2xlYXJlclxuICAgIC8vIGFuZCB3aGVuIGEgdXNlciBkZWZpbmVkIHJhbmdlIGlzIHNwZWNpZmllZCwgd2Ugd2FudCB0aGUgY29ycmVjdCB0aWNrc1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIENhc2UgNFxuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXG4gICAgLy8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgc3BhY2luZyB3aWxsIGhhdmUgY2hhbmdlZCBpbiBjYXNlcyAxLCAyLCBhbmQgMyBzbyB0aGUgZmFjdG9yIGNhbm5vdCBiZSBjb21wdXRlZFxuICAvLyB1bnRpbCB0aGlzIHBvaW50XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG5cbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKzsgLy8gU2tpcCBuaWNlTWluXG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbmV4dCBuaWNlIHRpY2sgaXMgY2xvc2UgdG8gbWluLCBza2lwIGl0XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIGNvbnN0IHRpY2tWYWx1ZSA9IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGlmIChtYXhEZWZpbmVkICYmIHRpY2tWYWx1ZSA+IG1heCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsdWV9KTtcbiAgfVxuXG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRpY2sgaXMgdG9vIGNsb3NlIHRvIG1heCwgcmVwbGFjZSBpdCB3aXRoIG1heCwgZWxzZSBhZGQgbWF4XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiArcmF3O1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuXG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gbWF4ID09PSAwID8gMSA6IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuXG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcblxuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuXG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuXG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG4gICAgLy8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG4gICAgLy8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cbiAgICAvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcblxuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfVxuICB9O1xuXG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IG1heCA6IDE7XG5cbiAgICAvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgbWluLCBtYXgsIGJlZ2luQXRaZXJvXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG5cbiAgLy8gVXRpbHNcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG4iLCAiaW1wb3J0IHtmaW5pdGVPckRlZmF1bHQsIGlzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtfc2V0TWluQW5kTWF4QnlLZXksIGxvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuXG5jb25zdCBsb2cxMEZsb29yID0gdiA9PiBNYXRoLmZsb29yKGxvZzEwKHYpKTtcbmNvbnN0IGNoYW5nZUV4cG9uZW50ID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHYpICsgbSk7XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHRpY2tWYWwpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5cbmZ1bmN0aW9uIHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkge1xuICBjb25zdCByYW5nZVN0ZXAgPSBNYXRoLnBvdygxMCwgcmFuZ2VFeHApO1xuICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IobWluIC8gcmFuZ2VTdGVwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5jZWlsKG1heCAvIHJhbmdlU3RlcCk7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn1cblxuZnVuY3Rpb24gc3RhcnRFeHAobWluLCBtYXgpIHtcbiAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGxldCByYW5nZUV4cCA9IGxvZzEwRmxvb3IocmFuZ2UpO1xuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA+IDEwKSB7XG4gICAgcmFuZ2VFeHArKztcbiAgfVxuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA8IDEwKSB7XG4gICAgcmFuZ2VFeHAtLTtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4ocmFuZ2VFeHAsIGxvZzEwRmxvb3IobWluKSk7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywge21pbiwgbWF4fSkge1xuICBtaW4gPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBtaW4pO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtaW5FeHAgPSBsb2cxMEZsb29yKG1pbik7XG4gIGxldCBleHAgPSBzdGFydEV4cChtaW4sIG1heCk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLnBvdygxMCwgZXhwKTtcbiAgY29uc3QgYmFzZSA9IG1pbkV4cCA+IGV4cCA/IE1hdGgucG93KDEwLCBtaW5FeHApIDogMDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLnJvdW5kKChtaW4gLSBiYXNlKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IoKG1pbiAtIGJhc2UpIC8gc3RlcFNpemUgLyAxMCkgKiBzdGVwU2l6ZSAqIDEwO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKChzdGFydCAtIG9mZnNldCkgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCB2YWx1ZSA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICB3aGlsZSAodmFsdWUgPCBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZSwgbWFqb3I6IGlzTWFqb3IodmFsdWUpLCBzaWduaWZpY2FuZH0pO1xuICAgIGlmIChzaWduaWZpY2FuZCA+PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCA8IDE1ID8gMTUgOiAyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmlmaWNhbmQrKztcbiAgICB9XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDIwKSB7XG4gICAgICBleHArKztcbiAgICAgIHNpZ25pZmljYW5kID0gMjtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdmFsdWUpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKGxhc3RUaWNrKSwgc2lnbmlmaWNhbmR9KTtcblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xvZ2FyaXRobWljJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZGF0YSBoYXMgYDBgIGluIGl0IG9yIGBiZWdpbkF0WmVyb2AgaXMgdHJ1ZSwgbWluIChub24gemVybykgdmFsdWUgaXMgYXQgYm90dG9tXG4gICAgLy8gb2Ygc2NhbGUsIGFuZCBpdCBkb2VzIG5vdCBlcXVhbCBzdWdnZXN0ZWRNaW4sIGxvd2VyIHRoZSBtaW4gYm91bmQgYnkgb25lIGV4cC5cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmICFpc0Zpbml0ZSh0aGlzLl91c2VyTWluKSkge1xuICAgICAgdGhpcy5taW4gPSBtaW4gPT09IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKSA/IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAtMSkgOiBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHsgLy8gaW5jbHVkZXMgbnVsbFxuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuXG4gICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWluLCArMSkpO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge19sb25nZXN0VGV4dCwgYWRkUm91bmRlZFJlY3RQYXRoLCByZW5kZXJUZXh0LCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge0hBTEZfUEksIFRBVSwgdG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9ub3JtYWxpemVBbmdsZSwgUEl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cbiAgLy8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuICAvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcbiAgLy9cbiAgLy8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuICAvL1xuICAvLyBTb2x1dGlvbjpcbiAgLy9cbiAgLy8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG4gIC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG4gIC8vXG4gIC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG4gIC8vXG4gIC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuICAvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG4gIC8vXG4gIC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG4gIC8vIGFsb25nIHdpdGggbGFiZWxzLlxuICAvL1xuICAvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG4gIC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuICAvL1xuICAvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcbiAgLy8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcbiAgLy9cbiAgLy8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cbiAgLy8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG4gIC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuXG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuXG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG5cbiAgLy8gTm93IHRoYXQgdGV4dCBzaXplIGlzIGRldGVybWluZWQsIGNvbXB1dGUgdGhlIGZ1bGwgcG9zaXRpb25zXG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaW5kZXgsIGl0ZW1PcHRzKSB7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3Qge2V4dHJhLCBhZGRpdGlvbmFsQW5nbGUsIHBhZGRpbmcsIHNpemV9ID0gaXRlbU9wdHM7XG4gIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmcsIGFkZGl0aW9uYWxBbmdsZSk7XG4gIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gIHJldHVybiB7XG4gICAgLy8gaWYgdG8gZHJhdyBvciBvdmVybGFwcGVkXG4gICAgdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8vIFRleHQgcG9zaXRpb25cbiAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICB5LFxuXG4gICAgLy8gVGV4dCByZW5kZXJpbmcgZGF0YVxuICAgIHRleHRBbGlnbixcblxuICAgIC8vIEJvdW5kaW5nIGJveFxuICAgIGxlZnQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgIGJvdHRvbTogeSArIHNpemUuaFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSkge1xuICBpZiAoIWFyZWEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IGFwZXhlc0luQXJlYSA9IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogYm90dG9tfSwgYXJlYSkgfHxcbiAgICBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogYm90dG9tfSwgYXJlYSk7XG4gIHJldHVybiAhYXBleGVzSW5BcmVhO1xufVxuXG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IHtjZW50ZXJQb2ludExhYmVscywgZGlzcGxheX0gPSBvcHRzLnBvaW50TGFiZWxzO1xuICBjb25zdCBpdGVtT3B0cyA9IHtcbiAgICBleHRyYTogZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMixcbiAgICBhZGRpdGlvbmFsQW5nbGU6IGNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMFxuICB9O1xuICBsZXQgYXJlYTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGl0ZW1PcHRzLnBhZGRpbmcgPSBwYWRkaW5nW2ldO1xuICAgIGl0ZW1PcHRzLnNpemUgPSBsYWJlbFNpemVzW2ldO1xuXG4gICAgY29uc3QgaXRlbSA9IGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpLCBpdGVtT3B0cyk7XG4gICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtLnZpc2libGUgPSBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSk7XG4gICAgICBpZiAoaXRlbS52aXNpYmxlKSB7XG4gICAgICAgIGFyZWEgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuXG4gIHJldHVybiAncmlnaHQnO1xufVxuXG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzLCBpdGVtKSB7XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0cztcblxuICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHMuYm9yZGVyUmFkaXVzKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcblxuICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgfSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcblxuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgaXRlbSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgaWYgKCFpdGVtLnZpc2libGUpIHtcbiAgICAgIC8vIG92ZXJsYXBwaW5nXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHNBdEluZGV4LCBpdGVtKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbn0gPSBpdGVtO1xuXG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIERyYXcgY2lyY3VsYXIgYXJjcyBiZXR3ZWVuIHRoZSBwb2ludHNcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50LCBib3JkZXJPcHRzKSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG5cbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuXG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJPcHRzLmRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJPcHRzLmRhc2hPZmZzZXQ7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAncmFkaWFsTGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcbiAgICBhbmltYXRlOiB0cnVlLFxuICAgIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBib3JkZXJEYXNoOiBbXSxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICAgIH0sXG5cbiAgICBncmlkOiB7XG4gICAgICBjaXJjdWxhcjogZmFsc2VcbiAgICB9LFxuXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH0sXG5cbiAgICBwb2ludExhYmVsczoge1xuICAgICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG4gICAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgICAvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAgICBmb250OiB7XG4gICAgICAgIHNpemU6IDEwXG4gICAgICB9LFxuXG4gICAgICAvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcbiAgICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG5cbiAgICAgIC8vIE51bWJlciAtIEFkZGl0aW9ubCBwYWRkaW5nIGJldHdlZW4gc2NhbGUgYW5kIHBvaW50TGFiZWxcbiAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBjZW50ZXIgcG9pbnQgbGFiZWxzIHRvIHNsaWNlcyBpbiBwb2xhciBjaGFydFxuICAgICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAgICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG5cbiAgICAvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgbWluLCBtYXgsIGJlZ2luQXRaZXJvXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuXG4gICAgLy8gUG9pbnQgbGFiZWxzXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsQ2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG5cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuXG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIC8vIFRha2UgaW50byBhY2NvdW50IGhhbGYgZm9udCBzaXplICsgdGhlIHlQYWRkaW5nIG9mIHRoZSB0b3AgdmFsdWVcbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuXG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cblxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cblxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZCwgYm9yZGVyfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcblxuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuXG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwIHx8IChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA8IDApKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGluZGV4KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCwgb3B0c0F0SW5kZXhCb3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuXG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHt9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoKGluZGV4ID09PSAwICYmIHRoaXMubWluID49IDApICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3I6IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7fVxufVxuIiwgImltcG9ydCBhZGFwdGVycyBmcm9tICcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBpc0Zpbml0ZSwgaXNOdWxsT3JVbmRlZiwgbWVyZ2VJZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBpc051bWJlciwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtfYXJyYXlVbmlxdWUsIF9maWx0ZXJCZXR3ZWVuLCBfbG9va3VwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcycpLlRpbWVVbml0IH0gVW5pdFxuICogQHR5cGVkZWYge3tjb21tb246IGJvb2xlYW4sIHNpemU6IG51bWJlciwgc3RlcHM/OiBudW1iZXJ9fSBJbnRlcnZhbFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcycpLkRhdGVBZGFwdGVyIH0gRGF0ZUFkYXB0ZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8VW5pdCwgSW50ZXJ2YWw+fVxuICovXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gIG1pbGxpc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxLCBzdGVwczogMTAwMH0sXG4gIHNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMTAwMCwgc3RlcHM6IDYwfSxcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcbiAgaG91cjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMzYwMDAwMCwgc3RlcHM6IDI0fSxcbiAgZGF5OiB7Y29tbW9uOiB0cnVlLCBzaXplOiA4NjQwMDAwMCwgc3RlcHM6IDMwfSxcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxuICBtb250aDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMi42MjhlOSwgc3RlcHM6IDEyfSxcbiAgcXVhcnRlcjoge2NvbW1vbjogZmFsc2UsIHNpemU6IDcuODg0ZTksIHN0ZXBzOiA0fSxcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XG59O1xuXG4vKipcbiAqIEB0eXBlIHtVbml0W119XG4gKi9cbmNvbnN0IFVOSVRTID0gLyoqIEB0eXBlIFVuaXRbXSAqLyAvKiAjX19QVVJFX18gKi8gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICovXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0geyp9IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gIH1cblxuICAvLyBPbmx5IHBhcnNlIGlmIGl0J3Mgbm90IGEgdGltZXN0YW1wIGFscmVhZHlcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBwYXJzZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIHBhcnNlcilcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG5cbiAgcmV0dXJuICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1UaWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtVbml0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VW5pdH0gdW5pdFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcltdfSBbdGltZXN0YW1wc10gLSBpZiBkZWZpbmVkLCBzbmFwIHRvIHRoZXNlIHRpbWVzdGFtcHNcbiAqL1xuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwXG4gKiBAcGFyYW0ge1VuaXR9IG1ham9yVW5pdFxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuXG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuICogQHBhcmFtIHtVbml0fHVuZGVmaW5lZH0gW21ham9yVW5pdF1cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvKiogQHR5cGUge09iamVjdDxudW1iZXIsb2JqZWN0Pn0gKi9cbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuXG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2Ugc2V0IHRoZSBtYWpvciB0aWNrcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSBjYWxsaW5nIHN0YXJ0T2YgZm9yIGV2ZXJ5IHRpY2tcbiAgLy8gaXMgZXhwZW5zaXZlIHdoZW4gdGhlcmUgaXMgYSBsYXJnZSBudW1iZXIgb2YgdGlja3NcbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ2RhdGEnLFxuXG4gICAgYWRhcHRlcnM6IHt9LFxuICAgIHRpbWU6IHtcbiAgICAgIHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIHRpbWVzdGFtcFxuICAgICAgdW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICByb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheVxuICAgICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICAgIH0sXG4gICAgdGlja3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG4gICAgICAgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cbiAgICAgICAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuICAgICAgICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcbiAgICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAgICovXG4gICAgICBzb3VyY2U6ICdhdXRvJyxcblxuICAgICAgY2FsbGJhY2s6IGZhbHNlLFxuXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7e2RhdGE6IG51bWJlcltdLCBsYWJlbHM6IG51bWJlcltdLCBhbGw6IG51bWJlcltdfX0gKi9cbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuXG4gICAgLyoqIEB0eXBlIHtVbml0fSAqL1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICAvKiogQHR5cGUge1VuaXQ9fSAqL1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIC8qKiBAdHlwZSB7RGF0ZUFkYXB0ZXJ9ICovXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuXG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuXG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYmVmb3JlIGludHJvZHVjaW5nIGFkYXB0ZXIsIGBkaXNwbGF5Rm9ybWF0c2Agd2FzXG4gICAgLy8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxuICAgIC8vIHdoZW4gbG9hZGluZyB0aGUgc2NhbGUgKGFkYXB0ZXJzIGFyZSBsb2FkZWQgYWZ0ZXJ3YXJkKSwgc28gbGV0J3MgcG9wdWxhdGVcbiAgICAvLyBtaXNzaW5nIGZvcm1hdHMgb24gdXBkYXRlXG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuXG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcj99IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cblxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICAvKipcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzXG5cdFx0ICovXG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdXNlciBwcm92aWRlZCBgbWluYCBhbmQgYG1heGAgbGFiZWxzIC8gZGF0YSBib3VuZHMgY2FuIGJlIGlnbm9yZWRcbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIC8vIExhYmVscyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQsIHdoZW4gdXNlciBkaWQgbm90IGZvcmNlIGJvdW5kc1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuXG4gICAgICAvLyBJZiBgYm91bmRzYCBpcyBgJ3RpY2tzJ2AgYW5kIGB0aWNrcy5zb3VyY2VgIGlzIGAnbGFiZWxzJ2AsXG4gICAgICAvLyBkYXRhIGJvdW5kcyBhcmUgaWdub3JlZCAoYW5kIGRvbid0IG5lZWQgdG8gYmUgZGV0ZXJtaW5lZClcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSB0aW1lc2VyaWVzIGxvb2t1cCB0YWJsZSlcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuXG4gICAgLy8gUFJJVkFURVxuICAgIC8vIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIHJlbGllcyBvbiB0aGUgbnVtYmVyIG9mIHRpY2tzIHNvIHdlIGRvbid0IHVzZSBpdCB3aGVuXG4gICAgLy8gYXV0b1NraXAgaXMgZW5hYmxlZCBiZWNhdXNlIHdlIGRvbid0IHlldCBrbm93IHdoYXQgdGhlIGZpbmFsIG51bWJlciBvZiB0aWNrcyB3aWxsIGJlXG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG5cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICAvLyBPZmZzZXRzIGZvciBiYXIgY2hhcnRzIG5lZWQgdG8gYmUgaGFuZGxlZCB3aXRoIHRoZSBhdXRvIHNraXBwZWRcbiAgICAvLyB0aWNrcy4gT25jZSB0aWNrcyBoYXZlIGJlZW4gc2tpcHBlZCwgd2UgcmUtY29tcHV0ZSB0aGUgb2Zmc2V0cy5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZnJvbSBlZGdlcyBpbiB0aGUgZm9ybSBvZiB7c3RhcnQsIGVuZH1cblx0ICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cblx0ICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxuXHQgKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzID0gW10pIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuXG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cblxuICAvKipcblx0ICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcblx0ICogYG1pbm9yYCB1bml0IHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cblx0ICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3Muc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcblxuICAgIC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cblxuICAgIC8vIEFsaWduIGZpcnN0IHRpY2tzIG9uIHVuaXRcbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuICAgIC8vIFByZXZlbnQgYnJvd3NlciBmcm9tIGZyZWV6aW5nIGluIGNhc2UgdXNlciBvcHRpb25zIHJlcXVlc3QgbWlsbGlvbnMgb2YgbWlsbGlzZWNvbmRzXG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KHNvcnRlcikubWFwKHggPT4gK3gpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcblxuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBmb3JtYXRcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgZm10ID0gZm9ybWF0IHx8IGZvcm1hdHNbdW5pdF07XG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHZhbHVlLCBmbXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBbZm9ybWF0XVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNhbGwoZm9ybWF0dGVyLCBbdGltZSwgaW5kZXgsIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuXHQgKiBAcmV0dXJuIHt7dzpudW1iZXIsIGg6bnVtYmVyfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZXhhbXBsZVRpbWVcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG5cbiAgICAvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3N0aW1hdGlvblxuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICAvLyBzdWJ0cmFjdCAxIC0gaWYgb2Zmc2V0IHRoZW4gdGhlcmUncyBvbmUgbGVzcyBsYWJlbCB0aGFuIHRpY2tcbiAgICAvLyBpZiBub3Qgb2Zmc2V0IHRoZW4gb25lIGhhbGYgbGFiZWwgcGFkZGluZyBpcyBhZGRlZCB0byBlYWNoIGVuZCBsZWF2aW5nIHJvb20gZm9yIG9uZSBsZXNzIGxhYmVsXG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG5cbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAvLyBJdCBzZWVtcyB0byBiZSBzb21ld2hhdCBmYXN0ZXIgdG8gZG8gc29ydGluZyBmaXJzdFxuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgVGltZVNjYWxlIGZyb20gJy4vc2NhbGUudGltZS5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWxgIHVzaW5nIHRoZSB0YWJsZS4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzXG4gKiBhdCBlZGdlcyBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIGxvb2t1cCB0aW1lIGJhc2VkIG9uIHBvc2l0aW9uIGluc3RlYWQgb2YgdmljZSB2ZXJzYVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cblxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cblxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZXNlcmllcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge29iamVjdFtdfSAqL1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuXHQgKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuXHQgKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcblx0ICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG5cdCAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuXHQgKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbGVzcyB0aGF0IDIgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCB0aGUgc2NhbGUgaXMgZGVmaW5lZCBieSBtaW4gYW5kIG1heFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2VuZXJhdGVzIGFsbCB0aW1lc3RhbXBzIGRlZmluZWQgaW4gdGhlIGRhdGEuXG4gICAgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gICAgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGxldCB0aW1lc3RhbXBzID0gc3VwZXIuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWluKSB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMuc3BsaWNlKDAsIDAsIG1pbik7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtYXgpIHx8IHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYWxsIHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7bnVtYmVyW119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBjb21iaW5pbmcgbGFiZWxzIGFuZCBkYXRhIChkYXRhIG1pZ2h0IG5vdCBjb250YWluIGFsbCBsYWJlbHMpLFxuICAgICAgLy8gd2UgbmVlZCB0byByZWNoZWNrIHVuaXF1ZW5lc3MgYW5kIHNvcnRcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1NjYWxlO1xuIiwgImV4cG9ydCAqIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgc2NhbGVzIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtB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QUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsYUFBYTtBQUFBLEVBQ2IsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsVUFBVTtBQUFBLEVBQ1YsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsYUFBYTtBQUFBLEVBQ2IsSUFBSTtBQUFBLEVBQ0osVUFBVTtBQUFBLEVBQ1YsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsUUFBUTtB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LGlCQUFhLGlCQUFpQixTQUFTLE1BQU07QUFDekMsV0FBSyxTQUFTLEtBQUs7QUFDbkIsV0FBSyxNQUFNO0FBQUEsSUFDZixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUEsVUFBVTtBQUNOLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsY0FBVSxNQUFNO0FBQUEsRUFDcEI7QUFDSjsiLAogICJuYW1lcyI6IFsiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJ1bmRlZmluZWQiLCAiaXNBcnJheSIsICJBcnJheSIsICJ0eXBlIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzbGljZSIsICJpc09iamVjdCIsICJpc051bWJlckZpbml0ZSIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiZmluaXRlT3JEZWZhdWx0IiwgImRlZmF1bHRWYWx1ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1BlcmNlbnRhZ2UiLCAiZGltZW5zaW9uIiwgImVuZHNXaXRoIiwgInBhcnNlRmxvYXQiLCAidG9EaW1lbnNpb24iLCAiY2FsbGJhY2siLCAiZm4iLCAiYXJncyIsICJ0aGlzQXJnIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImxlbmd0aCIsICJfZWxlbWVudHNFcXVhbCIsICJhMCIsICJhMSIsICJpbGVuIiwgInYwIiwgInYxIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJjbG9uZSIsICJzb3VyY2UiLCAibWFwIiwgInRhcmdldCIsICJjcmVhdGUiLCAia2xlbiIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgIm1lcmdlciIsICJjdXJyZW50IiwgIm1lcmdlSWYiLCAiX21lcmdlcklmIiwgImhhc093blByb3BlcnR5IiwgImtleVJlc29sdmVycyIsICJ2IiwgIngiLCAibyIsICJ5IiwgIl9zcGxpdEtleSIsICJrZXkiLCAicGFydHMiLCAic3BsaXQiLCAia2V5cyIsICJ0bXAiLCAicGFydCIsICJlbmRzV2l0aCIsICJzbGljZSIsICJwdXNoIiwgIl9nZXRLZXlSZXNvbHZlciIsICJvYmoiLCAiayIsICJyZXNvbHZlT2JqZWN0S2V5IiwgInJlc29sdmVyIiwgIl9jYXBpdGFsaXplIiwgInN0ciIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiZGVmaW5lZCIsICJ2YWx1ZSIsICJpc0Z1bmN0aW9uIiwgInNldHNFcXVhbCIsICJhIiwgImIiLCAic2l6ZSIsICJpdGVtIiwgImhhcyIsICJfaXNDbGlja0V2ZW50IiwgImUiLCAidHlwZSIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAiZXBzaWxvbiIsICJhYnMiLCAibmljZU51bSIsICJyYW5nZSIsICJyb3VuZGVkUmFuZ2UiLCAicm91bmQiLCAibmljZVJhbmdlIiwgInBvdyIsICJmbG9vciIsICJmcmFjdGlvbiIsICJuaWNlRnJhY3Rpb24iLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAic3FydCIsICJpIiwgInNvcnQiLCAicG9wIiwgImlzTm9uUHJpbWl0aXZlIiwgIm4iLCAiU3ltYm9sIiwgInRvUHJpbWl0aXZlIiwgImlzTnVtYmVyIiwgImlzTmFOIiwgInBhcnNlRmxvYXQiLCAiaXNGaW5pdGUiLCAiYWxtb3N0V2hvbGUiLCAicm91bmRlZCIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiYXJyYXkiLCAidGFyZ2V0IiwgInByb3BlcnR5IiwgImlsZW4iLCAibGVuZ3RoIiwgIm1pbiIsICJtYXgiLCAidG9SYWRpYW5zIiwgImRlZ3JlZXMiLCAidG9EZWdyZWVzIiwgInJhZGlhbnMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaXNGaW5pdGVOdW1iZXIiLCAicCIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJjZW50cmVQb2ludCIsICJhbmdsZVBvaW50IiwgImRpc3RhbmNlRnJvbVhDZW50ZXIiLCAiZGlzdGFuY2VGcm9tWUNlbnRlciIsICJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCAiYW5nbGUiLCAiYXRhbjIiLCAiZGlzdGFuY2UiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInB0MSIsICJwdDIiLCAiX2FuZ2xlRGlmZiIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiYW5nbGVUb1N0YXJ0IiwgImFuZ2xlVG9FbmQiLCAic3RhcnRUb0FuZ2xlIiwgImVuZFRvQW5nbGUiLCAiX2xpbWl0VmFsdWUiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJfbG9va3VwIiwgInRhYmxlIiwgImNtcCIsICJpbmRleCIsICJoaSIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImxhc3QiLCAidGkiLCAiX3Jsb29rdXBCeUtleSIsICJfZmlsdGVyQmV0d2VlbiIsICJ2YWx1ZXMiLCAiYXJyYXlFdmVudHMiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAibGlzdGVuZXIiLCAiX2NoYXJ0anMiLCAibGlzdGVuZXJzIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAiQXJyYXkiLCAiZnJvbSIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgIndpbmRvdyIsICJjYWxsYmFjayIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAidGhyb3R0bGVkIiwgImZuIiwgInRoaXNBcmciLCAiYXJnc1RvVXNlIiwgInRpY2tpbmciLCAiYXJncyIsICJjYWxsIiwgImFwcGx5IiwgImRlYm91bmNlIiwgImRlbGF5IiwgInRpbWVvdXQiLCAiY2xlYXJUaW1lb3V0IiwgInNldFRpbWVvdXQiLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgImFsaWduIiwgIl9hbGlnblN0YXJ0RW5kIiwgInN0YXJ0IiwgImVuZCIsICJfdGV4dFgiLCAibGVmdCIsICJyaWdodCIsICJydGwiLCAiY2hlY2siLCAiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCAibWV0YSIsICJwb2ludHMiLCAiYW5pbWF0aW9uc0Rpc2FibGVkIiwgInBvaW50Q291bnQiLCAibGVuZ3RoIiwgImNvdW50IiwgIl9zb3J0ZWQiLCAiaVNjYWxlIiwgInZTY2FsZSIsICJfcGFyc2VkIiwgInNwYW5HYXBzIiwgImRhdGFzZXQiLCAib3B0aW9ucyIsICJheGlzIiwgIm1pbiIsICJtYXgiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgImdldFVzZXJCb3VuZHMiLCAiTWF0aCIsICJfbG9va3VwQnlLZXkiLCAibG8iLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgInJldmVyc2UiLCAiZmluZEluZGV4IiwgInBvaW50IiwgImlzTnVsbE9yVW5kZWYiLCAiX2xpbWl0VmFsdWUiLCAiaGkiLCAiZGlzdGFuY2VUb0RlZmluZWRIaSIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAiX3NjYWxlUmFuZ2VzIiwgIm5ld1JhbmdlcyIsICJ4bWluIiwgInhtYXgiLCAieW1pbiIsICJ5bWF4IiwgImNoYW5nZWQiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgInBvdyIsICJzaW4iLCAiVEFVIiwgImVsYXN0aWNPdXQiLCAiZWZmZWN0cyIsICJsaW5lYXIiLCAiZWFzZUluUXVhZCIsICJlYXNlT3V0UXVhZCIsICJlYXNlSW5PdXRRdWFkIiwgImVhc2VJbkN1YmljIiwgImVhc2VPdXRDdWJpYyIsICJlYXNlSW5PdXRDdWJpYyIsICJlYXNlSW5RdWFydCIsICJlYXNlT3V0UXVhcnQiLCAiZWFzZUluT3V0UXVhcnQiLCAiZWFzZUluUXVpbnQiLCAiZWFzZU91dFF1aW50IiwgImVhc2VJbk91dFF1aW50IiwgImVhc2VJblNpbmUiLCAiY29zIiwgIkhBTEZfUEkiLCAiZWFzZU91dFNpbmUiLCAiZWFzZUluT3V0U2luZSIsICJQSSIsICJlYXNlSW5FeHBvIiwgImVhc2VPdXRFeHBvIiwgImVhc2VJbk91dEV4cG8iLCAiZWFzZUluQ2lyYyIsICJzcXJ0IiwgImVhc2VPdXRDaXJjIiwgImVhc2VJbk91dENpcmMiLCAiZWFzZUluRWxhc3RpYyIsICJlYXNlT3V0RWxhc3RpYyIsICJlYXNlSW5PdXRFbGFzdGljIiwgImVhc2VJbkJhY2siLCAiZWFzZU91dEJhY2siLCAiZWFzZUluT3V0QmFjayIsICJlYXNlSW5Cb3VuY2UiLCAiZWFzZU91dEJvdW5jZSIsICJtIiwgImQiLCAiZWFzZUluT3V0Qm91bmNlIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAidmFsdWUiLCAidHlwZSIsICJ0b1N0cmluZyIsICJjb2xvciIsICJDb2xvciIsICJnZXRIb3ZlckNvbG9yIiwgInNhdHVyYXRlIiwgImRhcmtlbiIsICJoZXhTdHJpbmciLCAibnVtYmVycyIsICJjb2xvcnMiLCAiYXBwbHlBbmltYXRpb25zRGVmYXVsdHMiLCAiZGVmYXVsdHMiLCAic2V0IiwgInVuZGVmaW5lZCIsICJkdXJhdGlvbiIsICJlYXNpbmciLCAiZnJvbSIsICJsb29wIiwgInRvIiwgImRlc2NyaWJlIiwgIl9mYWxsYmFjayIsICJfaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAicHJvcGVydGllcyIsICJhY3RpdmUiLCAiYW5pbWF0aW9uIiwgInJlc2l6ZSIsICJzaG93IiwgImFuaW1hdGlvbnMiLCAidmlzaWJsZSIsICJoaWRlIiwgInYiLCAiYXBwbHlMYXlvdXRzRGVmYXVsdHMiLCAiYXV0b1BhZGRpbmciLCAicGFkZGluZyIsICJ0b3AiLCAiYm90dG9tIiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJjYWNoZUtleSIsICJKU09OIiwgInN0cmluZ2lmeSIsICJmb3JtYXR0ZXIiLCAiZ2V0IiwgIkludGwiLCAiTnVtYmVyRm9ybWF0IiwgImZvcm1hdE51bWJlciIsICJudW0iLCAiZm9ybWF0IiwgImZvcm1hdHRlcnMiLCAidmFsdWVzIiwgImlzQXJyYXkiLCAibnVtZXJpYyIsICJ0aWNrVmFsdWUiLCAiaW5kZXgiLCAidGlja3MiLCAiY2hhcnQiLCAibm90YXRpb24iLCAiZGVsdGEiLCAibWF4VGljayIsICJhYnMiLCAiY2FsY3VsYXRlRGVsdGEiLCAibG9nRGVsdGEiLCAibG9nMTAiLCAibnVtRGVjaW1hbCIsICJpc05hTiIsICJmbG9vciIsICJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgImxvZ2FyaXRobWljIiwgInJlbWFpbiIsICJzaWduaWZpY2FuZCIsICJpbmNsdWRlcyIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgImRhdGEiLCAiZ2MiLCAibG9uZ2VzdCIsICJzdHJpbmciLCAidGV4dFdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgInB1c2giLCAiX2xvbmdlc3RUZXh0IiwgImFycmF5T2ZUaGluZ3MiLCAiY2FjaGUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAic2F2ZSIsICJpbGVuIiwgImoiLCAiamxlbiIsICJ0aGluZyIsICJuZXN0ZWRUaGluZyIsICJyZXN0b3JlIiwgImdjTGVuIiwgInNwbGljZSIsICJfYWxpZ25QaXhlbCIsICJwaXhlbCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJoYWxmV2lkdGgiLCAicm91bmQiLCAiY2xlYXJDYW52YXMiLCAiY2FudmFzIiwgImdldENvbnRleHQiLCAicmVzZXRUcmFuc2Zvcm0iLCAiY2xlYXJSZWN0IiwgImhlaWdodCIsICJkcmF3UG9pbnQiLCAieCIsICJ5IiwgImRyYXdQb2ludExlZ2VuZCIsICJ3IiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJjb3JuZXJSYWRpdXMiLCAieE9mZnNldFciLCAieU9mZnNldFciLCAicG9pbnRTdHlsZSIsICJyb3RhdGlvbiIsICJyYWRpdXMiLCAicmFkIiwgIlJBRF9QRVJfREVHIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAiZHJhd0ltYWdlIiwgImJlZ2luUGF0aCIsICJlbGxpcHNlIiwgImFyYyIsICJjbG9zZVBhdGgiLCAibW92ZVRvIiwgIlRXT19USElSRFNfUEkiLCAibGluZVRvIiwgIlFVQVJURVJfUEkiLCAiU1FSVDFfMiIsICJyZWN0IiwgImZpbGwiLCAiYm9yZGVyV2lkdGgiLCAic3Ryb2tlIiwgIl9pc1BvaW50SW5BcmVhIiwgImFyZWEiLCAibWFyZ2luIiwgImNsaXBBcmVhIiwgInVuY2xpcEFyZWEiLCAiX3N0ZXBwZWRMaW5lVG8iLCAicHJldmlvdXMiLCAiZmxpcCIsICJtaWRwb2ludCIsICJfYmV6aWVyQ3VydmVUbyIsICJiZXppZXJDdXJ2ZVRvIiwgImNwMXgiLCAiY3AyeCIsICJjcDF5IiwgImNwMnkiLCAic2V0UmVuZGVyT3B0cyIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgImRlY29yYXRlVGV4dCIsICJsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImRlY29yYXRpb25XaWR0aCIsICJkcmF3QmFja2Ryb3AiLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAicmVuZGVyVGV4dCIsICJsaW5lcyIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiaCIsICJ0b3BMZWZ0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicHJvcHMiLCAicmV0IiwgIm9ialByb3BzIiwgInJlYWQiLCAicHJvcCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJ0b1BhZGRpbmciLCAib2JqIiwgInRvRm9udCIsICJmYWxsYmFjayIsICJwYXJzZUludCIsICJjb25zb2xlIiwgIndhcm4iLCAicmVzb2x2ZSIsICJpbnB1dHMiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJjaGFuZ2UiLCAidG9EaW1lbnNpb24iLCAia2VlcFplcm8iLCAiYWRkIiwgImNyZWF0ZUNvbnRleHQiLCAicGFyZW50Q29udGV4dCIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9nZXRUYXJnZXQiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAiX2tleXMiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAib3duS2V5cyIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAic2V0Q29udGV4dCIsICJyZWNlaXZlciIsICJfcmVzb2x2ZVdpdGhDb250ZXh0IiwgImFsbEtleXMiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIl9jYXBpdGFsaXplIiwgIm5lZWRzU3ViUmVzb2x2ZXIiLCAicHJvdG90eXBlIiwgImhhc093blByb3BlcnR5IiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgImdldFZhbHVlIiwgIkVycm9yIiwgIkFycmF5IiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAiaXRlbSIsICJyZXNvbHZlciIsICJyZXNvbHZlRmFsbGJhY2siLCAicGFyZW50IiwgInJlc29sdmVPYmplY3RLZXkiLCAiYWRkU2NvcGVzIiwgInBhcmVudFNjb3BlcyIsICJwYXJlbnRGYWxsYmFjayIsICJhbGxTY29wZXMiLCAiYWRkU2NvcGVzRnJvbUtleSIsICJzdWJHZXRUYXJnZXQiLCAicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJfcGFyc2luZyIsICJwYXJzZWQiLCAiciIsICJwYXJzZSIsICJFUFNJTE9OIiwgImdldFBvaW50IiwgInNraXAiLCAiZ2V0VmFsdWVBeGlzIiwgInNwbGluZUN1cnZlIiwgImZpcnN0UG9pbnQiLCAibWlkZGxlUG9pbnQiLCAiYWZ0ZXJQb2ludCIsICJjdXJyZW50IiwgIm5leHQiLCAiZDAxIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJkMTIiLCAiczAxIiwgInMxMiIsICJmYSIsICJmYiIsICJtb25vdG9uZUFkanVzdCIsICJkZWx0YUsiLCAibUsiLCAicG9pbnRzTGVuIiwgImFscGhhSyIsICJiZXRhSyIsICJ0YXVLIiwgInNxdWFyZWRNYWduaXR1ZGUiLCAicG9pbnRDdXJyZW50IiwgInBvaW50QWZ0ZXIiLCAiYWxtb3N0RXF1YWxzIiwgIm1vbm90b25lQ29tcHV0ZSIsICJ2YWx1ZUF4aXMiLCAicG9pbnRCZWZvcmUiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJzcGxpbmVDdXJ2ZU1vbm90b25lIiwgInNsb3BlRGVsdGEiLCAic2lnbiIsICJjYXBDb250cm9sUG9pbnQiLCAicHQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImluQXJlYSIsICJpbkFyZWFQcmV2IiwgImluQXJlYU5leHQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiY29udHJvbFBvaW50cyIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgInByZXYiLCAidGVuc2lvbiIsICJfaXNEb21TdXBwb3J0ZWQiLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnROb2RlIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAicG9zIiwgInBhcnNlRmxvYXQiLCAidXNlT2Zmc2V0UG9zIiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiYm94IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhIZWlnaHQiLCAiY29udGFpbmVyIiwgImNsaWVudFdpZHRoIiwgImNsaWVudEhlaWdodCIsICJjb250YWluZXJTdHlsZSIsICJjb250YWluZXJCb3JkZXIiLCAiY29udGFpbmVyUGFkZGluZyIsICJJTkZJTklUWSIsICJyb3VuZDEiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWFpbnRhaW5IZWlnaHQiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgIl9wb2ludEluTGluZSIsICJwMSIsICJwMiIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiY3AxIiwgImNwMiIsICJhIiwgImIiLCAiYyIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAic2V0V2lkdGgiLCAieFBsdXMiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiZGlyZWN0aW9uIiwgIm9yaWdpbmFsIiwgImdldFByb3BlcnR5UHJpb3JpdHkiLCAic2V0UHJvcGVydHkiLCAicHJldlRleHREaXJlY3Rpb24iLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAicHJvcGVydHlGbiIsICJiZXR3ZWVuIiwgIl9hbmdsZUJldHdlZW4iLCAiY29tcGFyZSIsICJfYW5nbGVEaWZmIiwgIm5vcm1hbGl6ZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2lzQmV0d2VlbiIsICJub3JtYWxpemVTZWdtZW50IiwgImdldFNlZ21lbnQiLCAic2VnbWVudCIsICJzdGFydEJvdW5kIiwgImVuZEJvdW5kIiwgIl9ib3VuZFNlZ21lbnQiLCAiaW5zaWRlIiwgInN1YlN0YXJ0IiwgInByZXZWYWx1ZSIsICJzdGFydElzQmVmb3JlIiwgImVuZElzQmVmb3JlIiwgInNob3VsZFN0YXJ0IiwgInNob3VsZFN0b3AiLCAiX2JvdW5kU2VnbWVudHMiLCAic2VnbWVudHMiLCAic3ViIiwgImZpbmRTdGFydEFuZEVuZCIsICJzb2xpZFNlZ21lbnRzIiwgImxhc3QiLCAiY3VyIiwgInN0b3AiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJzZWdtZW50T3B0aW9ucyIsICJfbG9vcCIsICJzcGxpdEJ5U3R5bGVzIiwgImNvbXBsZXRlTG9vcCIsICJfZnVsbExvb3AiLCAiZG9TcGxpdEJ5U3R5bGVzIiwgImNoYXJ0Q29udGV4dCIsICJfY2hhcnQiLCAiYmFzZVN0eWxlIiwgInJlYWRTdHlsZSIsICJfZGF0YXNldEluZGV4IiwgImRhdGFzZXRJbmRleCIsICJwcmV2U3R5bGUiLCAiYWRkU3R5bGUiLCAibCIsICJzdCIsICJkaXIiLCAicDAiLCAicDBEYXRhSW5kZXgiLCAicDFEYXRhSW5kZXgiLCAic3R5bGVDaGFuZ2VkIiwgImJvcmRlckNhcFN0eWxlIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJib3JkZXJKb2luU3R5bGUiLCAicmVwbGFjZXIiLCAiZ2V0U2l6ZUZvckFyZWEiLCAiY2hhcnRBcmVhIiwgImZpZWxkIiwgImdldERhdGFzZXRBcmVhIiwgImdldERhdGFzZXRDbGlwQXJlYSIsICJfY2xpcCIsICJkaXNhYmxlZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiZm91bmQiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAic3RhY2tJbmRleCIsICJyZWN0cyIsICJudW1iZXJzIiwgIm92ZXJyaWRlcyIsICJfaW5kZXhfIiwgIm9mZnNldCIsICJncmlkIiwgIl92YWx1ZV8iLCAiYmVnaW5BdFplcm8iLCAiQnViYmxlQ29udHJvbGxlciIsICJyYWRpdXMiLCAicG9pbnRzIiwgInBvaW50IiwgImlQaXhlbCIsICJ2UGl4ZWwiLCAic2tpcCIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiY29zIiwgInN0YXJ0WSIsICJzaW4iLCAiZW5kWCIsICJlbmRZIiwgImNhbGNNYXgiLCAiYW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJjYWxjTWluIiwgIm1heFgiLCAibWF4WSIsICJIQUxGX1BJIiwgIm1pblgiLCAiUEkiLCAibWluWSIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaW5uZXJSYWRpdXMiLCAib3V0ZXJSYWRpdXMiLCAiZ2V0dGVyIiwgIl9nZXRSb3RhdGlvbiIsICJ0b1JhZGlhbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ0b1BlcmNlbnRhZ2UiLCAiY2hhcnRXZWlnaHQiLCAiX2dldFJpbmdXZWlnaHQiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgIm1heFJhZGl1cyIsICJ0b0RpbWVuc2lvbiIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAiX2NpcmN1bWZlcmVuY2UiLCAiYW5pbWF0ZVJvdGF0ZSIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJjZW50ZXJZIiwgImFuaW1hdGVTY2FsZSIsICJhcmMiLCAibWV0YURhdGEiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgImhvdmVyT2Zmc2V0IiwgInJpbmdXZWlnaHRPZmZzZXQiLCAid2VpZ2h0IiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAic3RhcnRzV2l0aCIsICJhc3BlY3RSYXRpbyIsICJwbHVnaW5zIiwgImxlZ2VuZCIsICJnZW5lcmF0ZUxhYmVscyIsICJwb2ludFN0eWxlIiwgIm1hcCIsICJzdHlsZSIsICJ0ZXh0IiwgImZpbGxTdHlsZSIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZm9udENvbG9yIiwgImxpbmVXaWR0aCIsICJvbkNsaWNrIiwgImUiLCAibGVnZW5kSXRlbSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJMaW5lQ29udHJvbGxlciIsICJsaW5lIiwgIl9kYXRhc2V0IiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgIl9kYXRhc2V0SW5kZXgiLCAiX2RlY2ltYXRlZCIsICJzaG93TGluZSIsICJzZWdtZW50IiwgImFuaW1hdGVkIiwgInNwYW5HYXBzIiwgIm1heEdhcExlbmd0aCIsICJpc051bWJlciIsICJkaXJlY3RVcGRhdGUiLCAicG9pbnRzQ291bnQiLCAicHJldlBhcnNlZCIsICJudWxsRGF0YSIsICJib3JkZXIiLCAiZmlyc3RQb2ludCIsICJsYXN0UG9pbnQiLCAidXBkYXRlQ29udHJvbFBvaW50cyIsICJQb2xhckFyZWFDb250cm9sbGVyIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJiaW5kIiwgIl91cGRhdGVSYWRpdXMiLCAibWluU2l6ZSIsICJjdXRvdXRQZXJjZW50YWdlIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAieENlbnRlciIsICJ5Q2VudGVyIiwgImRhdGFzZXRTdGFydEFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAiZGVmYXVsdEFuZ2xlIiwgImNvdW50VmlzaWJsZUVsZW1lbnRzIiwgIl9jb21wdXRlQW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAiYW5nbGVMaW5lcyIsICJkaXNwbGF5IiwgImNpcmN1bGFyIiwgInBvaW50TGFiZWxzIiwgIlBpZUNvbnRyb2xsZXIiLCAiUmFkYXJDb250cm9sbGVyIiwgIl9mdWxsTG9vcCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJTY2F0dGVyQ29udHJvbGxlciIsICJyZWdpc3RyeSIsICJnZXRFbGVtZW50IiwgImludGVyYWN0aW9uIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgInByb3RvdHlwZSIsICJpbml0IiwgImZvcm1hdHMiLCAiZm9ybWF0IiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJpbnRlcnNlY3QiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgInJlc3VsdCIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgImxvIiwgImZpbmRJbmRleCIsICJkaXN0YW5jZVRvRGVmaW5lZEhpIiwgImhpIiwgImVsIiwgImdldFJhbmdlIiwgImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsICJwb3NpdGlvbiIsICJoYW5kbGVyIiwgImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCAiaiIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgImRlbHRhWSIsICJzcXJ0IiwgInBvdyIsICJnZXRJbnRlcnNlY3RJdGVtcyIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImluY2x1ZGVJbnZpc2libGUiLCAiaXNQb2ludEluQXJlYSIsICJldmFsdWF0aW9uRnVuYyIsICJfaXNQb2ludEluQXJlYSIsICJpblJhbmdlIiwgImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsICJnZXRQcm9wcyIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiZ2V0Q2VudGVyUG9pbnQiLCAicG9pbnRJbkFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0TmVhcmVzdEl0ZW1zIiwgImdldEF4aXNJdGVtcyIsICJyYW5nZU1ldGhvZCIsICJpbnRlcnNlY3RzSXRlbSIsICJtb2RlcyIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJ2MCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2tXZWlnaHQiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJ3cmFwIiwgImluY2x1ZGVzIiwgIl9zdGFjayIsICJwbGFjZWQiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImF2YWlsYWJsZVdpZHRoIiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJyaWdodEFuZEJvdHRvbSIsICJ2ZXJ0aWNhbCIsICJnZXRDb21iaW5lZE1heCIsICJtYXhQYWRkaW5nIiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImFkZEJveCIsICJfbGF5ZXJzIiwgInoiLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJyZWxlYXNlQ29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgImxpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJnZXRNYXhpbXVtU2l6ZSIsICJpc0F0dGFjaGVkIiwgInVwZGF0ZUNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiYm94U2l6aW5nIiwgImRpc3BsYXlXaWR0aCIsICJyZWFkVXNlZFNpemUiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJyZXNpemUiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgIkRvbVBsYXRmb3JtIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImZpbmFsIiwgInJldCIsICJkZWZhdWx0Um91dGVzIiwgImF1dG9Ta2lwIiwgInRpY2tPcHRzIiwgImRldGVybWluZWRNYXhUaWNrcyIsICJkZXRlcm1pbmVNYXhUaWNrcyIsICJ0aWNrc0xpbWl0IiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJuZXdUaWNrcyIsICJza2lwTWFqb3JzIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgInRpY2tMZW5ndGgiLCAiX3RpY2tTaXplIiwgIm1heFNjYWxlIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJTY2FsZSIsICJfbWFyZ2lucyIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJmaW5pdGVPckRlZmF1bHQiLCAibWV0YXMiLCAiZ2V0VGlja3MiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJtYXJnaW5zIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAicGl4ZWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVDb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgInNhdmUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdCb3JkZXIiLCAibGFzdExpbmVXaWR0aCIsICJkcmF3TGFiZWxzIiwgImNsaXBBcmVhIiwgInJlbmRlclRleHRPcHRpb25zIiwgInJlbmRlclRleHQiLCAidW5jbGlwQXJlYSIsICJkcmF3VGl0bGUiLCAidHoiLCAiZ3oiLCAiYnoiLCAiYXhpc0lEIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiX2VhY2giLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImVycm9yIiwgIl9wcm94eSIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAicmVzaXplRGVsYXkiLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiQ29udHJvbGxlckNsYXNzIiwgIl9yZXNldEVsZW1lbnRzIiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9kcmF3RGF0YXNldCIsICJnZXREYXRhc2V0Q2xpcEFyZWEiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJoaWRlIiwgInNob3ciLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJfYWRkIiwgIl9yZW1vdmUiLCAiZGV0YWNoZWQiLCAidXBkYXRlSG92ZXJTdHlsZSIsICJwcmVmaXgiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJfZWxlbWVudHNFcXVhbCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJ2ZXJzaW9uIiwgImNsaXBBcmMiLCAicGl4ZWxNYXJnaW4iLCAiYW5nbGVNYXJnaW4iLCAiY2xvc2VQYXRoIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJvdXRlckFyY0xpbWl0IiwgIm91dGVyU3RhcnQiLCAib3V0ZXJFbmQiLCAiaW5uZXJTdGFydCIsICJpbm5lckVuZCIsICJyVGhldGFUb1hZIiwgInRoZXRhIiwgInBhdGhBcmMiLCAiaW5uZXJSIiwgInNwYWNpbmdPZmZzZXQiLCAiYWxwaGEiLCAibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCAibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCAiYXZOb2dTcGFjaW5nUmFkaXVzIiwgImFkanVzdGVkQW5nbGUiLCAiYmV0YSIsICJhbmdsZU9mZnNldCIsICJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCAiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCAiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwQ2VudGVyIiwgInA0IiwgImlubmVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwOCIsICJvdXRlclN0YXJ0WCIsICJvdXRlclN0YXJ0WSIsICJvdXRlckVuZFgiLCAib3V0ZXJFbmRZIiwgImRyYXdBcmMiLCAiZnVsbENpcmNsZXMiLCAiYm9yZGVySm9pblN0eWxlIiwgImlubmVyIiwgImxpbmVKb2luIiwgIkFyY0VsZW1lbnQiLCAiY2hhcnRYIiwgImNoYXJ0WSIsICJyQWRqdXN0IiwgIm5vblplcm9CZXR3ZWVuIiwgImJldHdlZW5BbmdsZXMiLCAid2l0aGluUmFkaXVzIiwgIl9pc0JldHdlZW4iLCAiaGFsZkFuZ2xlIiwgImhhbGZSYWRpdXMiLCAidHJhbnNsYXRlIiwgImZpeCIsICJyYWRpdXNPZmZzZXQiLCAic2V0U3R5bGUiLCAibGluZUNhcCIsICJib3JkZXJDYXBTdHlsZSIsICJwcmV2aW91cyIsICJnZXRMaW5lTWV0aG9kIiwgInN0ZXBwZWQiLCAiX3N0ZXBwZWRMaW5lVG8iLCAidGVuc2lvbiIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgIl9iZXppZXJDdXJ2ZVRvIiwgInBhdGhWYXJzIiwgInBhcmFtc1N0YXJ0IiwgInBhcmFtc0VuZCIsICJzZWdtZW50U3RhcnQiLCAic2VnbWVudEVuZCIsICJvdXRzaWRlIiwgInBhdGhTZWdtZW50IiwgImxpbmVNZXRob2QiLCAiZmFzdFBhdGhTZWdtZW50IiwgImF2Z1giLCAiY291bnRYIiwgInByZXZYIiwgImxhc3RZIiwgInBvaW50SW5kZXgiLCAiZHJhd1giLCAidHJ1bmNYIiwgIl9nZXRTZWdtZW50TWV0aG9kIiwgInVzZUZhc3RQYXRoIiwgIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJfcG9pbnRJbkxpbmUiLCAic3Ryb2tlUGF0aFdpdGhDYWNoZSIsICJwYXRoIiwgIl9wYXRoIiwgIlBhdGgyRCIsICJzdHJva2VQYXRoRGlyZWN0IiwgInNlZ21lbnRzIiwgInNlZ21lbnRNZXRob2QiLCAidXNlUGF0aDJEIiwgIkxpbmVFbGVtZW50IiwgIl9wb2ludHMiLCAiX3NlZ21lbnRzIiwgIl9wb2ludHNVcGRhdGVkIiwgIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwgIl9jb21wdXRlU2VnbWVudHMiLCAiaW50ZXJwb2xhdGUiLCAiX2JvdW5kU2VnbWVudHMiLCAiX2ludGVycG9sYXRlIiwgImludGVycG9sYXRlZCIsICJjYXBCZXppZXJQb2ludHMiLCAiaGl0UmFkaXVzIiwgIlBvaW50RWxlbWVudCIsICJtb3VzZVgiLCAibW91c2VZIiwgImluWFJhbmdlIiwgImluWVJhbmdlIiwgImhvdmVyUmFkaXVzIiwgImRyYXdQb2ludCIsICJnZXRCYXJCb3VuZHMiLCAiYmFyIiwgImhhbGYiLCAic2tpcE9yTGltaXQiLCAicGFyc2VCb3JkZXJXaWR0aCIsICJtYXhXIiwgIm1heEgiLCAidG9UUkJMIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgIm91dGVyIiwgInNraXBYIiwgInNraXBZIiwgInNraXBCb3RoIiwgImhhc1JhZGl1cyIsICJhZGROb3JtYWxSZWN0UGF0aCIsICJyZWN0IiwgImluZmxhdGVSZWN0IiwgImFtb3VudCIsICJyZWZSZWN0IiwgIkJhckVsZW1lbnQiLCAiYWRkUmVjdFBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgIkJPUkRFUl9DT0xPUlMiLCAiQkFDS0dST1VORF9DT0xPUlMiLCAicmVwbGFjZSIsICJnZXRCb3JkZXJDb2xvciIsICJnZXRCYWNrZ3JvdW5kQ29sb3IiLCAiY29sb3JpemVEZWZhdWx0RGF0YXNldCIsICJjb2xvcml6ZURvdWdobnV0RGF0YXNldCIsICJjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQiLCAiZ2V0Q29sb3JpemVyIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMiLCAiayIsICJjb250YWluc0NvbG9yc0RlZmluaXRpb24iLCAiY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMiLCAiZm9yY2VPdmVycmlkZSIsICJfYXJncyIsICJjaGFydE9wdGlvbnMiLCAiY29udGFpbnNDb2xvckRlZmVuaXRpb24iLCAiY29sb3JpemVyIiwgImx0dGJEZWNpbWF0aW9uIiwgInNhbXBsZXMiLCAiZGVjaW1hdGVkIiwgImJ1Y2tldFdpZHRoIiwgInNhbXBsZWRJbmRleCIsICJlbmRJbmRleCIsICJtYXhBcmVhUG9pbnQiLCAibWF4QXJlYSIsICJuZXh0QSIsICJhdmdZIiwgImF2Z1JhbmdlU3RhcnQiLCAiYXZnUmFuZ2VFbmQiLCAiYXZnUmFuZ2VMZW5ndGgiLCAicmFuZ2VPZmZzIiwgInJhbmdlVG8iLCAicG9pbnRBeCIsICJwb2ludEF5IiwgIm1pbk1heERlY2ltYXRpb24iLCAibWluSW5kZXgiLCAibWF4SW5kZXgiLCAic3RhcnRJbmRleCIsICJ4TWluIiwgInhNYXgiLCAiZHgiLCAibGFzdEluZGV4IiwgImludGVybWVkaWF0ZUluZGV4MSIsICJpbnRlcm1lZGlhdGVJbmRleDIiLCAiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgIndyaXRhYmxlIiwgImNsZWFuRGVjaW1hdGVkRGF0YSIsICJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsICJwb2ludENvdW50IiwgImFsZ29yaXRobSIsICJiZWZvcmVFbGVtZW50c1VwZGF0ZSIsICJ4QXhpcyIsICJ0aHJlc2hvbGQiLCAidHBvaW50cyIsICJfZmluZFNlZ21lbnRFbmQiLCAiX2dldEJvdW5kcyIsICJ0YXJnZXRTZWdtZW50cyIsICJ0Z3QiLCAic3ViQm91bmRzIiwgImZpbGxTb3VyY2VzIiwgIl9ib3VuZFNlZ21lbnQiLCAiZmlsbFNvdXJjZSIsICJfZ2V0RWRnZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX3BvaW50c0Zyb21TZWdtZW50cyIsICJib3VuZGFyeSIsICJsaW5lUG9pbnRzIiwgIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCAiX3Nob3VsZEFwcGx5RmlsbCIsICJfcmVzb2x2ZVRhcmdldCIsICJzb3VyY2VzIiwgInByb3BhZ2F0ZSIsICJ2aXNpdGVkIiwgIl9kZWNvZGVGaWxsIiwgInBhcnNlRmlsbE9wdGlvbiIsICJwYXJzZUZsb2F0IiwgImRlY29kZVRhcmdldEluZGV4IiwgImZpcnN0Q2giLCAiX2dldFRhcmdldFBpeGVsIiwgIl9nZXRUYXJnZXRWYWx1ZSIsICJmaWxsT3B0aW9uIiwgIl9idWlsZFN0YWNrTGluZSIsICJzb3VyY2VQb2ludHMiLCAibGluZXNCZWxvdyIsICJnZXRMaW5lc0JlbG93IiwgImFkZFBvaW50c0JlbG93IiwgImJlbG93IiwgInVuc2hpZnQiLCAic291cmNlUG9pbnQiLCAicG9zdHBvbmVkIiwgImZpbmRQb2ludCIsICJwb2ludFZhbHVlIiwgImZpcnN0VmFsdWUiLCAibGFzdFZhbHVlIiwgInNpbXBsZUFyYyIsICJfZ2V0VGFyZ2V0IiwgImdldExpbmVCeUluZGV4IiwgImNvbXB1dGVCb3VuZGFyeSIsICJjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeSIsICJjb21wdXRlTGluZWFyQm91bmRhcnkiLCAiX2RyYXdmaWxsIiwgImxpbmVPcHRzIiwgImFib3ZlIiwgImRvRmlsbCIsICJjbGlwVmVydGljYWwiLCAiY2xpcFkiLCAibGluZUxvb3AiLCAic3JjIiwgIm5vdFNoYXBlIiwgImNsaXBCb3VuZHMiLCAiaW50ZXJwb2xhdGVkTGluZVRvIiwgInRhcmdldExvb3AiLCAiaW50ZXJwb2xhdGVkUG9pbnQiLCAiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsICIkZmlsbGVyIiwgImJlZm9yZURyYXciLCAiZHJhd1RpbWUiLCAiYmVmb3JlRGF0YXNldHNEcmF3IiwgImJlZm9yZURhdGFzZXREcmF3IiwgImdldEJveFNpemUiLCAibGFiZWxPcHRzIiwgImJveEhlaWdodCIsICJib3hXaWR0aCIsICJ1c2VQb2ludFN0eWxlIiwgInBvaW50U3R5bGVXaWR0aCIsICJpdGVtSGVpZ2h0IiwgIml0ZW1zRXF1YWwiLCAiTGVnZW5kIiwgIl9hZGRlZCIsICJsZWdlbmRIaXRCb3hlcyIsICJfaG92ZXJlZEl0ZW0iLCAiZG91Z2hudXRNb2RlIiwgImxlZ2VuZEl0ZW1zIiwgImNvbHVtblNpemVzIiwgImxpbmVXaWR0aHMiLCAiYnVpbGRMYWJlbHMiLCAibGFiZWxGb250IiwgIl9jb21wdXRlVGl0bGVIZWlnaHQiLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAiaGl0Ym94ZXMiLCAidG90YWxIZWlnaHQiLCAicm93IiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJhZGp1c3RIaXRCb3hlcyIsICJydGwiLCAicnRsSGVscGVyIiwgImdldFJ0bEFkYXB0ZXIiLCAiaGl0Ym94IiwgImxlZnRGb3JMdHIiLCAiX2RyYXciLCAiZGVmYXVsdENvbG9yIiwgImhhbGZGb250U2l6ZSIsICJjdXJzb3IiLCAiZHJhd0xlZ2VuZEJveCIsICJsaW5lRGFzaCIsICJkcmF3T3B0aW9ucyIsICJTUVJUMiIsICJ4UGx1cyIsICJkcmF3UG9pbnRMZWdlbmQiLCAieUJveFRvcCIsICJ4Qm94TGVmdCIsICJmaWxsVGV4dCIsICJzdHJpa2V0aHJvdWdoIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJ0ZXh0RGlyZWN0aW9uIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZUZvbnQiLCAidGl0bGVQYWRkaW5nIiwgInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwgIl9nZXRMZWdlbmRJdGVtQXQiLCAiaGl0Qm94IiwgImxoIiwgImhhbmRsZUV2ZW50IiwgImlzTGlzdGVuZWQiLCAiaG92ZXJlZEl0ZW0iLCAic2FtZUl0ZW0iLCAib25MZWF2ZSIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJfZWxlbWVudCIsICJhZnRlckV2ZW50IiwgImNpIiwgInVzZUJvcmRlclJhZGl1cyIsICJUaXRsZSIsICJfcGFkZGluZyIsICJ0ZXh0U2l6ZSIsICJfZHJhd0FyZ3MiLCAiZm9udE9wdHMiLCAiY3JlYXRlVGl0bGUiLCAidGl0bGVCbG9jayIsICJXZWFrTWFwIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAieFNldCIsICJ4QXZlcmFnZSIsICJldmVudFBvc2l0aW9uIiwgIm5lYXJlc3RFbGVtZW50IiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAidG9QdXNoIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJjcmVhdGVUb29sdGlwSXRlbSIsICJmb3JtYXR0ZWRWYWx1ZSIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJkZXRlcm1pbmVZQWxpZ24iLCAiZG9lc05vdEZpdFdpdGhBbGlnbiIsICJ4QWxpZ24iLCAiY2FyZXQiLCAiY2FyZXRTaXplIiwgImNhcmV0UGFkZGluZyIsICJkZXRlcm1pbmVYQWxpZ24iLCAieUFsaWduIiwgImNoYXJ0V2lkdGgiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAiZ2V0QWxpZ25lZFgiLCAiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCAiY3JlYXRlVG9vbHRpcENvbnRleHQiLCAidG9vbHRpcEl0ZW1zIiwgIm92ZXJyaWRlQ2FsbGJhY2tzIiwgImRlZmF1bHRDYWxsYmFja3MiLCAiYmVmb3JlVGl0bGUiLCAibm9vcCIsICJsYWJlbENvdW50IiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAibGFiZWxDb2xvciIsICJsYWJlbFRleHRDb2xvciIsICJib2R5Q29sb3IiLCAibGFiZWxQb2ludFN0eWxlIiwgImFmdGVyTGFiZWwiLCAiYmVmb3JlRm9vdGVyIiwgImFmdGVyRm9vdGVyIiwgImludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrIiwgIlRvb2x0aXAiLCAib3BhY2l0eSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJpdGVtU29ydCIsICJwb3NpdGlvbkFuZFNpemUiLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgIngzIiwgInkzIiwgInB0WCIsICJwdFkiLCAicHQiLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgIm91dGVyWCIsICJpbm5lclgiLCAic3Ryb2tlUmVjdCIsICJkcmF3Qm9keSIsICJib2R5QWxpZ24iLCAieExpbmVQYWRkaW5nIiwgImZpbGxMaW5lT2ZUZXh0IiwgImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwgInRleHRDb2xvciIsICJkcmF3Rm9vdGVyIiwgImZvb3RlckFsaWduIiwgImZvb3RlckNvbG9yIiwgInRvb2x0aXBTaXplIiwgInF1YWRyYXRpY0N1cnZlVG8iLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltWCIsICJhbmltWSIsICJfd2lsbFJlbmRlciIsICJoYXNUb29sdGlwQ29udGVudCIsICJnbG9iYWxBbHBoYSIsICJwb3NpdGlvbkNoYW5nZWQiLCAiX3Bvc2l0aW9uQ2hhbmdlZCIsICJfaWdub3JlUmVwbGF5RXZlbnRzIiwgImFmdGVySW5pdCIsICJhZnRlckRyYXciLCAiX2ZhbGxiYWNrIiwgImFkZElmU3RyaW5nIiwgImFkZGVkTGFiZWxzIiwgImZpbmRPckFkZExhYmVsIiwgImxhc3RJbmRleE9mIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgIkNhdGVnb3J5U2NhbGUiLCAiX3N0YXJ0VmFsdWUiLCAiX3ZhbHVlUmFuZ2UiLCAiX2FkZGVkTGFiZWxzIiwgImFkZGVkIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInByZWNpc2lvbiIsICJtYXhUaWNrcyIsICJtYXhEaWdpdHMiLCAiaW5jbHVkZUJvdW5kcyIsICJ1bml0IiwgIm1heFNwYWNlcyIsICJybWluIiwgInJtYXgiLCAiY291bnREZWZpbmVkIiwgIm1pblNwYWNpbmciLCAibmljZU51bSIsICJuaWNlTWluIiwgIm5pY2VNYXgiLCAibnVtU3BhY2VzIiwgImFsbW9zdFdob2xlIiwgImFsbW9zdEVxdWFscyIsICJkZWNpbWFsUGxhY2VzIiwgIl9kZWNpbWFsUGxhY2VzIiwgInJlbGF0aXZlTGFiZWxTaXplIiwgInRpY2tWYWx1ZSIsICJyYWQiLCAiTGluZWFyU2NhbGVCYXNlIiwgIl9lbmRWYWx1ZSIsICJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwgInNldE1pbiIsICJzZXRNYXgiLCAibWluU2lnbiIsICJtYXhTaWduIiwgImdldFRpY2tMaW1pdCIsICJzdGVwU2l6ZSIsICJjb21wdXRlVGlja0xpbWl0IiwgIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJMaW5lYXJTY2FsZSIsICJUaWNrcyIsICJmb3JtYXR0ZXJzIiwgIm51bWVyaWMiLCAibG9nMTBGbG9vciIsICJsb2cxMCIsICJjaGFuZ2VFeHBvbmVudCIsICJtIiwgImlzTWFqb3IiLCAidGlja1ZhbCIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAibWluRXhwIiwgImV4cCIsICJzaWduaWZpY2FuZCIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgIl96ZXJvIiwgImxvZ2FyaXRobWljIiwgImdldFRpY2tCYWNrZHJvcEhlaWdodCIsICJtZWFzdXJlTGFiZWxTaXplIiwgIl9sb25nZXN0VGV4dCIsICJkZXRlcm1pbmVMaW1pdHMiLCAiZml0V2l0aFBvaW50TGFiZWxzIiwgImxpbWl0cyIsICJ2YWx1ZUNvdW50IiwgIl9wb2ludExhYmVscyIsICJwb2ludExhYmVsT3B0cyIsICJhZGRpdGlvbmFsQW5nbGUiLCAiY2VudGVyUG9pbnRMYWJlbHMiLCAiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCAiZ2V0UG9pbnRQb3NpdGlvbiIsICJkcmF3aW5nQXJlYSIsICJwbEZvbnQiLCAiaExpbWl0cyIsICJ2TGltaXRzIiwgInVwZGF0ZUxpbWl0cyIsICJzZXRDZW50ZXJQb2ludCIsICJfcG9pbnRMYWJlbEl0ZW1zIiwgImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwgImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwgIml0ZW1PcHRzIiwgIm91dGVyRGlzdGFuY2UiLCAiZXh0cmEiLCAicG9pbnRMYWJlbFBvc2l0aW9uIiwgInlGb3JBbmdsZSIsICJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsICJsZWZ0Rm9yVGV4dEFsaWduIiwgImlzTm90T3ZlcmxhcHBlZCIsICJhcGV4ZXNJbkFyZWEiLCAiZHJhd1BvaW50TGFiZWxCb3giLCAiYmFja2Ryb3BMZWZ0IiwgImJhY2tkcm9wVG9wIiwgImJhY2tkcm9wV2lkdGgiLCAiYmFja2Ryb3BIZWlnaHQiLCAiZHJhd1BvaW50TGFiZWxzIiwgInBhdGhSYWRpdXNMaW5lIiwgImRyYXdSYWRpdXNMaW5lIiwgImdyaWRMaW5lT3B0cyIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJSYWRpYWxMaW5lYXJTY2FsZSIsICJsZWZ0TW92ZW1lbnQiLCAicmlnaHRNb3ZlbWVudCIsICJ0b3BNb3ZlbWVudCIsICJib3R0b21Nb3ZlbWVudCIsICJhbmdsZU11bHRpcGxpZXIiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImRpc3RhbmNlRnJvbUNlbnRlciIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwgInJvdGF0ZSIsICJhbmltYXRlIiwgIklOVEVSVkFMUyIsICJtaWxsaXNlY29uZCIsICJjb21tb24iLCAic2Vjb25kIiwgIm1pbnV0ZSIsICJob3VyIiwgImRheSIsICJ3ZWVrIiwgIm1vbnRoIiwgInF1YXJ0ZXIiLCAieWVhciIsICJVTklUUyIsICJzb3J0ZXIiLCAiaW5wdXQiLCAiYWRhcHRlciIsICJfYWRhcHRlciIsICJwYXJzZXIiLCAiaXNvV2Vla2RheSIsICJfcGFyc2VPcHRzIiwgImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCAibWluVW5pdCIsICJjYXBhY2l0eSIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgImRldGVybWluZU1ham9yVW5pdCIsICJhZGRUaWNrIiwgInRpbWUiLCAidGltZXN0YW1wcyIsICJfbG9va3VwIiwgInRpbWVzdGFtcCIsICJzZXRNYWpvclRpY2tzIiwgIm1ham9yVW5pdCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJfdW5pdCIsICJfbWFqb3JVbml0IiwgIl9vZmZzZXRzIiwgIl9ub3JtYWxpemVkIiwgImFkYXB0ZXJzIiwgImRpc3BsYXlGb3JtYXRzIiwgIm5vcm1hbGl6ZWQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJnZXRMYWJlbFRpbWVzdGFtcHMiLCAidGltZU9wdHMiLCAiX2dlbmVyYXRlIiwgIl9maWx0ZXJCZXR3ZWVuIiwgIl9nZXRMYWJlbENhcGFjaXR5IiwgImluaXRPZmZzZXRzIiwgIm9mZnNldEFmdGVyQXV0b3NraXAiLCAiZ2V0RGVjaW1hbEZvclZhbHVlIiwgIm1pbm9yIiwgIndlZWtkYXkiLCAiaGFzV2Vla2RheSIsICJnZXREYXRhVGltZXN0YW1wcyIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibm9ybWFsaXplIiwgInRhYmxlIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAic3BhbiIsICJUaW1lU2VyaWVzU2NhbGUiLCAiX3RhYmxlIiwgIl9taW5Qb3MiLCAiX3RhYmxlUmFuZ2UiLCAiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsICJidWlsZExvb2t1cFRhYmxlIiwgInJlZ2lzdGVyYWJsZXMiLCAiX2EiLCAiX2IiLCAicmF3U3RhdHVzIiwgImRhdGVGb3JtYXQiLCAiaGFiaXRTdGF0c1R5cGUiLCAiaW5kZXgiLCAiY2FsbGJhY2siXQp9Cg==
